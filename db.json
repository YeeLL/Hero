{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"bf224830daff40194f8333f9272cdc410475b84a","modified":1480390994000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1479018142000},{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1479018142000},{"_id":"themes/maupassant/README.md","hash":"75d8c42569809961953d1934de445418c00ab94c","modified":1479018142000},{"_id":"themes/maupassant/_config.yml","hash":"07d65d0cf21a76e561f62e903b6dfd37f753a305","modified":1479089415000},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1479018142000},{"_id":"source/_posts/ANR.md","hash":"d0769de56afea295085f00e1f89004acdb7191f9","modified":1480392601000},{"_id":"source/_posts/.DS_Store","hash":"6f1897eab2f1c52b906c056a2163dda01308239b","modified":1481701455000},{"_id":"source/_posts/Activity生命周期.md","hash":"1431d011b9660d2485ea382b8776bf593f1ce150","modified":1480392101000},{"_id":"source/_posts/Android-Application类.md","hash":"cae5c0ea7aaf52e1250a73249d7492a032a3b88b","modified":1480389616000},{"_id":"source/_posts/Android消息机制——Handler的工作原理.md","hash":"95982da0adcac74f021298bd2fa853e7c819f540","modified":1480385919000},{"_id":"source/_posts/Android-属性动画.md","hash":"9dd456a8910fd74dabd4851c1a33cc360c6ef63b","modified":1480399895000},{"_id":"source/_posts/Android消息机制——Looper的工作原理.md","hash":"d916ba984225b23f8b563554eb29da0eb1bc61fb","modified":1480384330000},{"_id":"source/_posts/Android消息机制——ThreadLocal.md","hash":"1e683c0bdcd1955df05165624e5ab84eaebd3b9b","modified":1480385975000},{"_id":"source/_posts/Android消息机制——消息队列工作原理.md","hash":"75275dfc147d863565118bf54db1604a68ed0693","modified":1480383756000},{"_id":"source/_posts/Android消息机制——总结.md","hash":"b63ed7bc6802dc22aa8c2ece9716bf8b107289ca","modified":1480386555000},{"_id":"source/_posts/Android的线程和线程池——AsyncTask.md","hash":"01199015e5ada015c7cd13771f73ead55aec2171","modified":1480386568000},{"_id":"source/_posts/Builder模式.md","hash":"ce0ed3d610843ae3ef61d7a9bfc7195963cea7e0","modified":1480400349000},{"_id":"source/_posts/JAVA反射.md","hash":"58c19a07308e39553c55ef89d7ec69663185ec5b","modified":1480400612000},{"_id":"source/_posts/Java-7之基础-强引用、弱引用、软引用、虚引用-转载.md","hash":"5c624914a62c3a68d1ed9fadb08c68f67abc1c72","modified":1480392665000},{"_id":"source/_posts/This-Static，对象，对象的引用-等关键字的理解.md","hash":"a5a0e9aa2fd0db021d5604d592084e26906870ab","modified":1480400265000},{"_id":"source/_posts/LruCache.md","hash":"fb740397f06c4449dd2d3cf42be87e58254dcdee","modified":1480400476000},{"_id":"source/_posts/String-StringBuffer与StringBuilder的区别.md","hash":"4e4cd43514d8b93a62ca043a5aac0d82d481e110","modified":1480400720000},{"_id":"source/_posts/permission-0.md","hash":"d43524964b2ffec0663305619069d657cdad27dd","modified":1479027260000},{"_id":"source/_posts/retrofit-rxjava-Gson解析的坑.md","hash":"1009ae6c407bfdb2247367484e76417787befbff","modified":1481851493000},{"_id":"source/_posts/线程和线程池-handlerThread.md","hash":"8dde5990f4cbd04ea20caa6e0de0e21b9d55eac2","modified":1480400089000},{"_id":"source/_posts/代码规范的一些总结.md","hash":"9d40e69da261ddc44c73d1809ae67aea27290103","modified":1483496889000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1479018142000},{"_id":"source/_posts/如何提高代码的可读性.md","hash":"b464535b1c71f41f199f01c33cc8af7fd65eaf9d","modified":1481703606000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1479018031000},{"_id":"source/_posts/静态的内部类和普通的内部类的区别（面试遇到的坑）.md","hash":"c9d1fd5e7c79070c37427d96d25837637294261c","modified":1480668139000},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1479018142000},{"_id":"source/_posts/自己的内部链式存储机制.md","hash":"588e53d8b4a1ae5b8c8c6d615a48121f47658c5a","modified":1480400496000},{"_id":"themes/maupassant/.git/index","hash":"03b1f3e29b3e7bf4529515eefdfd0ef488ce60d3","modified":1479019978000},{"_id":"themes/maupassant/.git/packed-refs","hash":"53e4275068b4dbaa003c4f6e8f4eeaa4ed2360d0","modified":1479018142000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1479018142000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1479018142000},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1479018142000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1479018142000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1479018142000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1479018142000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1479018142000},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1479018142000},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"1ad721de96784bf4253316b796db6200148d4152","modified":1479018142000},{"_id":"themes/maupassant/layout/index.jade","hash":"7466ce52023ed8a413a6b4461354a9e20e62fc14","modified":1479018142000},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1479018142000},{"_id":"themes/maupassant/layout/post.jade","hash":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1479018142000},{"_id":"themes/maupassant/layout/base.jade","hash":"852c610ac392ef2fa130dbe73bcf4f96f423c869","modified":1479018142000},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1479018142000},{"_id":"themes/maupassant/layout/timeline.jade","hash":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1479018142000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1479018031000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1479018031000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1479018031000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1479018031000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1479018031000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1479018031000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1479018031000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1479018031000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1479018031000},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1479018031000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"f4894733bba6624cef7a9172e7782a044ae5cf93","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"3dbcc9a9f0d6e55da191d3393c18bbfcfe99fa69","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1479018142000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1479018142000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1479018142000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1479018142000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"193546282908e499813534f86d27ef6e0a1357b3","modified":1479018142000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1479018142000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1479018142000},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1479018142000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1479018142000},{"_id":"themes/maupassant/source/css/style.scss","hash":"158f1ebecf7b994ffae5332a627465f6bf38113b","modified":1479018142000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1479018142000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1479018142000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1479018142000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1479018142000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1479018142000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1479018142000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1479018142000},{"_id":"themes/maupassant/source/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1479018142000},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1479018142000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1479018142000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1479018142000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1479018142000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"9138f76c9461186fe7e14add27270f388fdabe2f","modified":1479018142000},{"_id":"themes/maupassant/.git/objects/pack/pack-e7cf019b13db06c00e956f23565138b3085dba01.idx","hash":"494a352d63726097f521c14dfa56cb8c35a0bf8c","modified":1479018142000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"f4894733bba6624cef7a9172e7782a044ae5cf93","modified":1479018142000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1479018142000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"f4894733bba6624cef7a9172e7782a044ae5cf93","modified":1479018142000},{"_id":"themes/maupassant/.git/objects/pack/pack-e7cf019b13db06c00e956f23565138b3085dba01.pack","hash":"2628f25ffb5ae14bb965b2571be844159242f710","modified":1479018142000},{"_id":"public/2017/01/04/代码规范的一些总结/index.html","hash":"419ea031417c54f110cf518150bb11e96e07c0f1","modified":1488180804278},{"_id":"public/2016/12/02/静态的内部类和普通的内部类的区别（面试遇到的坑）/index.html","hash":"878aded8f8a3b9d2765f294d367121d711079152","modified":1488180804278},{"_id":"public/2016/11/29/String-StringBuffer与StringBuilder的区别/index.html","hash":"a9018c00c28e61b7500808250f711c1dd70f3311","modified":1488180804278},{"_id":"public/2016/11/13/permission-0/index.html","hash":"3ffd56a26da35c8cb7a456073654a56cac03d40f","modified":1488180804279},{"_id":"public/2016/10/12/Android-属性动画/index.html","hash":"92d821c467a2deb417e525d1181e1bd79d496211","modified":1488180804279},{"_id":"public/2016/09/28/LruCache/index.html","hash":"019eb60452a97e641d885379fbdafdb3959aac60","modified":1488180804279},{"_id":"public/2016/09/27/线程和线程池-handlerThread/index.html","hash":"6fe0161cf915f8bbf333cd8606b706c7899004fc","modified":1488180804279},{"_id":"public/2016/09/22/JAVA反射/index.html","hash":"d0afbecf62cdc9c1b2fa76486b877a31bc003b54","modified":1488180804279},{"_id":"public/2016/09/12/ANR/index.html","hash":"1254a6ddc0aa08d7fc1dc662b6cea346cf2a0fb2","modified":1488180804279},{"_id":"public/2016/09/08/自己的内部链式存储机制/index.html","hash":"f01f4a60a902325be687131b90ac6e0357863c39","modified":1488180804279},{"_id":"public/2016/07/26/This-Static，对象，对象的引用-等关键字的理解/index.html","hash":"631eb8f584357aaf3bdf6bb19e66d88bdcd61dfd","modified":1488180804279},{"_id":"public/2016/07/20/Activity生命周期/index.html","hash":"9665e1952b6a8f935e4c4003cb4406ed1eb84b07","modified":1488180804279},{"_id":"public/2016/06/29/Builder模式/index.html","hash":"f215c133c508aeec95df71abd3f4a59ce51220a5","modified":1488180804279},{"_id":"public/2016/04/10/Android的线程和线程池——AsyncTask/index.html","hash":"f324308c4f52f39708dca19322f4421a4d81cdf3","modified":1488180804279},{"_id":"public/2016/03/25/Android消息机制——总结/index.html","hash":"08787020e85b680a6abf0df4ce26b3f0eea54540","modified":1488180804279},{"_id":"public/2016/03/10/Android-Application类/index.html","hash":"d354b0de3a55326e3d8131dc2e35b469a41489f2","modified":1488180804279},{"_id":"public/2016/02/13/Android消息机制——ThreadLocal/index.html","hash":"248d5c2c5a27f1b070731c7c78df58bfb07e256b","modified":1488180804279},{"_id":"public/2016/02/15/Android消息机制——Looper的工作原理/index.html","hash":"9de84506a3114a4b27ffdcfd7d34c501ababf8bb","modified":1488180804279},{"_id":"public/archives/index.html","hash":"859ca9262af6e72bd8789fb9dc3d8423208752fc","modified":1488180804279},{"_id":"public/archives/page/2/index.html","hash":"c3936a4c8d81cdd7e2f9492860b4b8abb3132c0b","modified":1488180804279},{"_id":"public/archives/page/3/index.html","hash":"5b3a85f92bf3b5eebc09e1acec99a1c3a1dd2320","modified":1488180804279},{"_id":"public/archives/2016/index.html","hash":"e421df4d6a6f8f46f3990ab81258b249d2ccc0d4","modified":1488180804279},{"_id":"public/archives/2016/page/2/index.html","hash":"9fb25496808f88144c84d2880d66e22f9a78f4ac","modified":1488180804279},{"_id":"public/archives/2016/page/3/index.html","hash":"d7ad1029a94427f94131b02fb04dcf9009f57e10","modified":1488180804279},{"_id":"public/archives/2016/02/index.html","hash":"12d173f6b2e6b6f52476c289699267be0d0fdbb7","modified":1488180804279},{"_id":"public/archives/2016/03/index.html","hash":"ef78b43d59d8e8b0a5e3efc22f466415e8524115","modified":1488180804280},{"_id":"public/archives/2016/04/index.html","hash":"1f2f84bb44dee3802732a6bc24aa040613e87255","modified":1488180804280},{"_id":"public/archives/2016/06/index.html","hash":"6b7740aadb1e0f746d85dbb1297ba3346f6e0531","modified":1488180804280},{"_id":"public/archives/2016/07/index.html","hash":"abe74c06fbd71db28b487e97688b9671f82d7e7f","modified":1488180804280},{"_id":"public/archives/2016/09/index.html","hash":"0df37f4cfee498dd4899b4994c201299117493ea","modified":1488180804280},{"_id":"public/archives/2016/10/index.html","hash":"f35fe5867eb8e7cb3aac05e51aa24cb821d034f6","modified":1488180804280},{"_id":"public/archives/2016/11/index.html","hash":"400a47efea35108af03b4c1f52cab94dbf1a7c02","modified":1488180804280},{"_id":"public/archives/2017/index.html","hash":"9df2ae3e6d780f4817ec8b5b856c797150ba3513","modified":1488180804280},{"_id":"public/archives/2016/12/index.html","hash":"1617a8896fd15177195b46f4cd3d600d12675abe","modified":1488180804280},{"_id":"public/archives/2017/01/index.html","hash":"9df2ae3e6d780f4817ec8b5b856c797150ba3513","modified":1488180804280},{"_id":"public/index.html","hash":"bec118f869a9853a776b937e8b911e27d5e6710f","modified":1488180804280},{"_id":"public/page/3/index.html","hash":"512aded0c73f0f0f5acdf4375b4900ca2b60be55","modified":1488180804280},{"_id":"public/tags/Android/index.html","hash":"fc497e36fb6d0ef62b6adda15381e4d4c51f4957","modified":1488180804280},{"_id":"public/tags/Android/page/2/index.html","hash":"f2db2ff9e9c9507e403ec55320ef115b9380b33b","modified":1488180804280},{"_id":"public/tags/JAVA/index.html","hash":"b6d01190189ffbc33822fd7eff6634d96302073a","modified":1488180804280},{"_id":"public/tags/设计模式/index.html","hash":"0229f72b15e4a70c36946d185a8653bf8129c663","modified":1488180804280},{"_id":"public/tags/Java/index.html","hash":"5a51052bf70bc8bc553f64f52cbff12e6977a1ba","modified":1488180804280},{"_id":"public/tags/代码规范/index.html","hash":"086b9a149486d62af863ea588a6c8b3c4066ee99","modified":1488180804281},{"_id":"public/2016/12/14/retrofit-rxjava-Gson解析的坑/index.html","hash":"565c519493c43b89f74812f9796e93304eb805c4","modified":1488180804281},{"_id":"public/2016/12/14/如何提高代码的可读性/index.html","hash":"3ccaf877a4125901f227fface784cf2c10a02342","modified":1488180804281},{"_id":"public/2016/09/15/Java-7之基础-强引用、弱引用、软引用、虚引用-转载/index.html","hash":"39e449e80f00de7d92dcfe9fa13d8ce87f50a132","modified":1488180804281},{"_id":"public/2016/03/10/Android消息机制——Handler的工作原理/index.html","hash":"d8423184d3c046bfabec2f06680a07033a7a4eb6","modified":1488180804281},{"_id":"public/2016/02/19/Android消息机制——消息队列工作原理/index.html","hash":"e0da2128dc0e3f862d36865fd63d456292642d8a","modified":1488180804281},{"_id":"public/page/2/index.html","hash":"9257e28450eccf71a22f4806eac563d316639b24","modified":1488180804281},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1488180804287},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488180804287},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488180804287},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1488180804287},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1488180804287},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1488180804287},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1488180804345},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1488180804345},{"_id":"public/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1488180804345},{"_id":"public/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1488180804345},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1488180804345},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1488180804345},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1488180804345},{"_id":"public/css/style.css","hash":"2afb6e7e24abf81c8b7b7d472fb0bb9b9a1eac16","modified":1488180804345}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"ANR","date":"2016-09-12T09:48:00.000Z","_content":"\n什么是ANR\n\nANR全称Application Not Responding，意思就是程序未响应。如果一个应用无法响应用户的输入，系统就会弹出一个ANR对话框，如下图所示,用户可以自行选择继续等待亦或者是停止当前程序。<!--more-->   \n出现场景\n\n* 主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。\n* 主线程中存在耗时的计算\n* 主线程中错误的操作，比如Thread.wait或者Thread.sleep等\nAndroid系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框\n\n* 应用在5秒内未响应用户的输入事件（如按键或者触摸）\n* BroadcastReceiver未在10秒内完成相关的处理   \n\n\n\n  \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  ","source":"_posts/ANR.md","raw":"---\ntitle: ANR\ndate: 2016-9-12 17:48:00\ntags: Android\n---\n\n什么是ANR\n\nANR全称Application Not Responding，意思就是程序未响应。如果一个应用无法响应用户的输入，系统就会弹出一个ANR对话框，如下图所示,用户可以自行选择继续等待亦或者是停止当前程序。<!--more-->   \n出现场景\n\n* 主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。\n* 主线程中存在耗时的计算\n* 主线程中错误的操作，比如Thread.wait或者Thread.sleep等\nAndroid系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框\n\n* 应用在5秒内未响应用户的输入事件（如按键或者触摸）\n* BroadcastReceiver未在10秒内完成相关的处理   \n\n\n\n  \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  ","slug":"ANR","published":1,"updated":"2016-11-29T04:10:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcxa00004jp5325an8m1","content":"<p>什么是ANR</p>\n<p>ANR全称Application Not Responding，意思就是程序未响应。如果一个应用无法响应用户的输入，系统就会弹出一个ANR对话框，如下图所示,用户可以自行选择继续等待亦或者是停止当前程序。<a id=\"more\"></a><br>出现场景</p>\n<ul>\n<li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li>\n<li>主线程中存在耗时的计算</li>\n<li><p>主线程中错误的操作，比如Thread.wait或者Thread.sleep等<br>Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框</p>\n</li>\n<li><p>应用在5秒内未响应用户的输入事件（如按键或者触摸）</p>\n</li>\n<li>BroadcastReceiver未在10秒内完成相关的处理   </li>\n</ul>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"<p>什么是ANR</p>\n<p>ANR全称Application Not Responding，意思就是程序未响应。如果一个应用无法响应用户的输入，系统就会弹出一个ANR对话框，如下图所示,用户可以自行选择继续等待亦或者是停止当前程序。","more":"<br>出现场景</p>\n<ul>\n<li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li>\n<li>主线程中存在耗时的计算</li>\n<li><p>主线程中错误的操作，比如Thread.wait或者Thread.sleep等<br>Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框</p>\n</li>\n<li><p>应用在5秒内未响应用户的输入事件（如按键或者触摸）</p>\n</li>\n<li>BroadcastReceiver未在10秒内完成相关的处理   </li>\n</ul>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>"},{"title":"Android消息机制——Handler的工作原理","date":"2016-03-10T04:43:49.000Z","_content":"Handler的工作主要包含消息的发送和接收的过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现。post的一系列方法最终是通过send的一系列方法来实现的。   <!--more-->   \n\n```java   \n/**\n * Pushes a message onto the end of the message queue after all pending messages\n * before the current time. It will be received in {@link #handleMessage},\n * in the thread attached to this handler.\n * \n * @return Returns true if the message was successfully placed in to the \n *         message queue.  Returns false on failure, usually because the\n *         looper processing the message queue is exiting.\n */\npublic final boolean sendMessage(Message msg)\n{\n    return sendMessageDelayed(msg, 0);\n}\n\n/**\n * Enqueue a message into the message queue after all pending messages\n * before (current time + delayMillis). You will receive it in\n * {@link #handleMessage}, in the thread attached to this handler.\n * \n * @return Returns true if the message was successfully placed in to the \n *         message queue.  Returns false on failure, usually because the\n *         looper processing the message queue is exiting.  Note that a\n *         result of true does not mean the message will be processed -- if\n *         the looper is quit before the delivery time of the message\n *         occurs then the message will be dropped.\n */\npublic final boolean sendMessageDelayed(Message msg, long delayMillis)\n{\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\n/**\n * Enqueue a message into the message queue after all pending messages\n * before the absolute time (in milliseconds) <var>uptimeMillis</var>.\n * <b>The time-base is {@link android.os.SystemClock#uptimeMillis}.</b>\n * Time spent in deep sleep will add an additional delay to execution.\n * You will receive it in {@link #handleMessage}, in the thread attached\n * to this handler.\n * \n * @param uptimeMillis The absolute time at which the message should be\n *         delivered, using the\n *         {@link android.os.SystemClock#uptimeMillis} time-base.\n *         \n * @return Returns true if the message was successfully placed in to the \n *         message queue.  Returns false on failure, usually because the\n *         looper processing the message queue is exiting.  Note that a\n *         result of true does not mean the message will be processed -- if\n *         the looper is quit before the delivery time of the message\n *         occurs then the message will be dropped.\n */\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\n\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n    msg.target = this;\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n\n```   \n\n可以看见sendMessage方法最后会执行enqueueMessage方法，把消息插入消息队列中。\n然后MessageQueue的next方法就会取出这条消息给Looper，Looper拿到消息后就开始处理，最后消息由\nLooper交给Hanlder处理，Hanlder就会调用dispatchMessage方法，然后回调handleMessage方法，最\n后在handleMessage方法里面处理消息。\n\n```java\n\n/**\n * Handle system messages here.\n */\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n\n```\n回调方法：   \n\n```java\n/**\n * Callback interface you can use when instantiating a Handler to avoid\n * having to implement your own subclass of Handler.\n *\n * @param msg A {@link android.os.Message Message} object\n * @return True if no further handling is desired\n */\npublic interface Callback {\n    public boolean handleMessage(Message msg);\n}\n\n/**\n * Subclasses must implement this to receive messages.\n */\npublic void handleMessage(Message msg) {\n}\n\n```\n\n例子：  \n \n```java\n   Handler handler1 = new Handler(){\n    @Override\n    public void handleMessage(Message msg) {\n        super.handleMessage(msg);\n    }\n};\n```   \n通过回调方法，消息就会到handleMessage(Message msg)中，然后在方法中处理消息。\nHandler handler = new Handler(Looper looper)；\n这种初始化的方式，是用handler来绑定线程。一般looper 为 Looper.getMainLooper（）\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢    \n邮箱：yee.xin.work@gmail.com\n\n\n","source":"_posts/Android消息机制——Handler的工作原理.md","raw":"---\ntitle: Android消息机制——Handler的工作原理\ndate: 2016-3-10 12:43:49\ntags: Android\n---\nHandler的工作主要包含消息的发送和接收的过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现。post的一系列方法最终是通过send的一系列方法来实现的。   <!--more-->   \n\n```java   \n/**\n * Pushes a message onto the end of the message queue after all pending messages\n * before the current time. It will be received in {@link #handleMessage},\n * in the thread attached to this handler.\n * \n * @return Returns true if the message was successfully placed in to the \n *         message queue.  Returns false on failure, usually because the\n *         looper processing the message queue is exiting.\n */\npublic final boolean sendMessage(Message msg)\n{\n    return sendMessageDelayed(msg, 0);\n}\n\n/**\n * Enqueue a message into the message queue after all pending messages\n * before (current time + delayMillis). You will receive it in\n * {@link #handleMessage}, in the thread attached to this handler.\n * \n * @return Returns true if the message was successfully placed in to the \n *         message queue.  Returns false on failure, usually because the\n *         looper processing the message queue is exiting.  Note that a\n *         result of true does not mean the message will be processed -- if\n *         the looper is quit before the delivery time of the message\n *         occurs then the message will be dropped.\n */\npublic final boolean sendMessageDelayed(Message msg, long delayMillis)\n{\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\n/**\n * Enqueue a message into the message queue after all pending messages\n * before the absolute time (in milliseconds) <var>uptimeMillis</var>.\n * <b>The time-base is {@link android.os.SystemClock#uptimeMillis}.</b>\n * Time spent in deep sleep will add an additional delay to execution.\n * You will receive it in {@link #handleMessage}, in the thread attached\n * to this handler.\n * \n * @param uptimeMillis The absolute time at which the message should be\n *         delivered, using the\n *         {@link android.os.SystemClock#uptimeMillis} time-base.\n *         \n * @return Returns true if the message was successfully placed in to the \n *         message queue.  Returns false on failure, usually because the\n *         looper processing the message queue is exiting.  Note that a\n *         result of true does not mean the message will be processed -- if\n *         the looper is quit before the delivery time of the message\n *         occurs then the message will be dropped.\n */\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\n\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n    msg.target = this;\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n\n```   \n\n可以看见sendMessage方法最后会执行enqueueMessage方法，把消息插入消息队列中。\n然后MessageQueue的next方法就会取出这条消息给Looper，Looper拿到消息后就开始处理，最后消息由\nLooper交给Hanlder处理，Hanlder就会调用dispatchMessage方法，然后回调handleMessage方法，最\n后在handleMessage方法里面处理消息。\n\n```java\n\n/**\n * Handle system messages here.\n */\npublic void dispatchMessage(Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n\n```\n回调方法：   \n\n```java\n/**\n * Callback interface you can use when instantiating a Handler to avoid\n * having to implement your own subclass of Handler.\n *\n * @param msg A {@link android.os.Message Message} object\n * @return True if no further handling is desired\n */\npublic interface Callback {\n    public boolean handleMessage(Message msg);\n}\n\n/**\n * Subclasses must implement this to receive messages.\n */\npublic void handleMessage(Message msg) {\n}\n\n```\n\n例子：  \n \n```java\n   Handler handler1 = new Handler(){\n    @Override\n    public void handleMessage(Message msg) {\n        super.handleMessage(msg);\n    }\n};\n```   \n通过回调方法，消息就会到handleMessage(Message msg)中，然后在方法中处理消息。\nHandler handler = new Handler(Looper looper)；\n这种初始化的方式，是用handler来绑定线程。一般looper 为 Looper.getMainLooper（）\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢    \n邮箱：yee.xin.work@gmail.com\n\n\n","slug":"Android消息机制——Handler的工作原理","published":1,"updated":"2016-11-29T02:18:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcxf00014jp5h8bqzgoh","content":"<p>Handler的工作主要包含消息的发送和接收的过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现。post的一系列方法最终是通过send的一系列方法来实现的。   <a id=\"more\"></a>   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Pushes a message onto the end of the message queue after all pending messages</div><div class=\"line\"> * before the current time. It will be received in &#123;<span class=\"doctag\">@link</span> #handleMessage&#125;,</div><div class=\"line\"> * in the thread attached to this handler.</div><div class=\"line\"> * </div><div class=\"line\"> * <span class=\"doctag\">@return</span> Returns true if the message was successfully placed in to the </div><div class=\"line\"> *         message queue.  Returns false on failure, usually because the</div><div class=\"line\"> *         looper processing the message queue is exiting.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(Message msg)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Enqueue a message into the message queue after all pending messages</div><div class=\"line\"> * before (current time + delayMillis). You will receive it in</div><div class=\"line\"> * &#123;<span class=\"doctag\">@link</span> #handleMessage&#125;, in the thread attached to this handler.</div><div class=\"line\"> * </div><div class=\"line\"> * <span class=\"doctag\">@return</span> Returns true if the message was successfully placed in to the </div><div class=\"line\"> *         message queue.  Returns false on failure, usually because the</div><div class=\"line\"> *         looper processing the message queue is exiting.  Note that a</div><div class=\"line\"> *         result of true does not mean the message will be processed -- if</div><div class=\"line\"> *         the looper is quit before the delivery time of the message</div><div class=\"line\"> *         occurs then the message will be dropped.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> delayMillis)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        delayMillis = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Enqueue a message into the message queue after all pending messages</div><div class=\"line\"> * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</div><div class=\"line\"> * &lt;b&gt;The time-base is &#123;<span class=\"doctag\">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</div><div class=\"line\"> * Time spent in deep sleep will add an additional delay to execution.</div><div class=\"line\"> * You will receive it in &#123;<span class=\"doctag\">@link</span> #handleMessage&#125;, in the thread attached</div><div class=\"line\"> * to this handler.</div><div class=\"line\"> * </div><div class=\"line\"> * <span class=\"doctag\">@param</span> uptimeMillis The absolute time at which the message should be</div><div class=\"line\"> *         delivered, using the</div><div class=\"line\"> *         &#123;<span class=\"doctag\">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</div><div class=\"line\"> *         </div><div class=\"line\"> * <span class=\"doctag\">@return</span> Returns true if the message was successfully placed in to the </div><div class=\"line\"> *         message queue.  Returns false on failure, usually because the</div><div class=\"line\"> *         looper processing the message queue is exiting.  Note that a</div><div class=\"line\"> *         result of true does not mean the message will be processed -- if</div><div class=\"line\"> *         the looper is quit before the delivery time of the message</div><div class=\"line\"> *         occurs then the message will be dropped.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">    MessageQueue queue = mQueue;</div><div class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">```   </div><div class=\"line\"></div><div class=\"line\">可以看见sendMessage方法最后会执行enqueueMessage方法，把消息插入消息队列中。</div><div class=\"line\">然后MessageQueue的next方法就会取出这条消息给Looper，Looper拿到消息后就开始处理，最后消息由</div><div class=\"line\">Looper交给Hanlder处理，Hanlder就会调用dispatchMessage方法，然后回调handleMessage方法，最</div><div class=\"line\">后在handleMessage方法里面处理消息。</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Handle system messages here.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        handleCallback(msg);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>回调方法：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Callback interface you can use when instantiating a Handler to avoid</div><div class=\"line\"> * having to implement your own subclass of Handler.</div><div class=\"line\"> *</div><div class=\"line\"> * <span class=\"doctag\">@param</span> msg A &#123;<span class=\"doctag\">@link</span> android.os.Message Message&#125; object</div><div class=\"line\"> * <span class=\"doctag\">@return</span> True if no further handling is desired</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Subclasses must implement this to receive messages.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例子：  </p>\n<pre><code class=\"java\">   Handler handler1 = <span class=\"keyword\">new</span> Handler(){\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n        <span class=\"keyword\">super</span>.handleMessage(msg);\n    }\n};\n</code></pre>\n<p>通过回调方法，消息就会到handleMessage(Message msg)中，然后在方法中处理消息。<br>Handler handler = new Handler(Looper looper)；<br>这种初始化的方式，是用handler来绑定线程。一般looper 为 Looper.getMainLooper（）</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com</p>\n","excerpt":"<p>Handler的工作主要包含消息的发送和接收的过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现。post的一系列方法最终是通过send的一系列方法来实现的。","more":"</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Pushes a message onto the end of the message queue after all pending messages</div><div class=\"line\"> * before the current time. It will be received in &#123;<span class=\"doctag\">@link</span> #handleMessage&#125;,</div><div class=\"line\"> * in the thread attached to this handler.</div><div class=\"line\"> * </div><div class=\"line\"> * <span class=\"doctag\">@return</span> Returns true if the message was successfully placed in to the </div><div class=\"line\"> *         message queue.  Returns false on failure, usually because the</div><div class=\"line\"> *         looper processing the message queue is exiting.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(Message msg)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Enqueue a message into the message queue after all pending messages</div><div class=\"line\"> * before (current time + delayMillis). You will receive it in</div><div class=\"line\"> * &#123;<span class=\"doctag\">@link</span> #handleMessage&#125;, in the thread attached to this handler.</div><div class=\"line\"> * </div><div class=\"line\"> * <span class=\"doctag\">@return</span> Returns true if the message was successfully placed in to the </div><div class=\"line\"> *         message queue.  Returns false on failure, usually because the</div><div class=\"line\"> *         looper processing the message queue is exiting.  Note that a</div><div class=\"line\"> *         result of true does not mean the message will be processed -- if</div><div class=\"line\"> *         the looper is quit before the delivery time of the message</div><div class=\"line\"> *         occurs then the message will be dropped.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> delayMillis)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        delayMillis = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Enqueue a message into the message queue after all pending messages</div><div class=\"line\"> * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</div><div class=\"line\"> * &lt;b&gt;The time-base is &#123;<span class=\"doctag\">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</div><div class=\"line\"> * Time spent in deep sleep will add an additional delay to execution.</div><div class=\"line\"> * You will receive it in &#123;<span class=\"doctag\">@link</span> #handleMessage&#125;, in the thread attached</div><div class=\"line\"> * to this handler.</div><div class=\"line\"> * </div><div class=\"line\"> * <span class=\"doctag\">@param</span> uptimeMillis The absolute time at which the message should be</div><div class=\"line\"> *         delivered, using the</div><div class=\"line\"> *         &#123;<span class=\"doctag\">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</div><div class=\"line\"> *         </div><div class=\"line\"> * <span class=\"doctag\">@return</span> Returns true if the message was successfully placed in to the </div><div class=\"line\"> *         message queue.  Returns false on failure, usually because the</div><div class=\"line\"> *         looper processing the message queue is exiting.  Note that a</div><div class=\"line\"> *         result of true does not mean the message will be processed -- if</div><div class=\"line\"> *         the looper is quit before the delivery time of the message</div><div class=\"line\"> *         occurs then the message will be dropped.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">    MessageQueue queue = mQueue;</div><div class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">```   </div><div class=\"line\"></div><div class=\"line\">可以看见sendMessage方法最后会执行enqueueMessage方法，把消息插入消息队列中。</div><div class=\"line\">然后MessageQueue的next方法就会取出这条消息给Looper，Looper拿到消息后就开始处理，最后消息由</div><div class=\"line\">Looper交给Hanlder处理，Hanlder就会调用dispatchMessage方法，然后回调handleMessage方法，最</div><div class=\"line\">后在handleMessage方法里面处理消息。</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Handle system messages here.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        handleCallback(msg);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>回调方法：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Callback interface you can use when instantiating a Handler to avoid</div><div class=\"line\"> * having to implement your own subclass of Handler.</div><div class=\"line\"> *</div><div class=\"line\"> * <span class=\"doctag\">@param</span> msg A &#123;<span class=\"doctag\">@link</span> android.os.Message Message&#125; object</div><div class=\"line\"> * <span class=\"doctag\">@return</span> True if no further handling is desired</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Subclasses must implement this to receive messages.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例子：  </p>\n<pre><code class=\"java\">   Handler handler1 = <span class=\"keyword\">new</span> Handler(){\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>{\n        <span class=\"keyword\">super</span>.handleMessage(msg);\n    }\n};\n</code></pre>\n<p>通过回调方法，消息就会到handleMessage(Message msg)中，然后在方法中处理消息。<br>Handler handler = new Handler(Looper looper)；<br>这种初始化的方式，是用handler来绑定线程。一般looper 为 Looper.getMainLooper（）</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com</p>"},{"title":"Activity生命周期","date":"2016-07-20T12:39:24.000Z","_content":"\nActivity是Android最重要的组件，因为它是与用户交互的。所以我们要弄明白Activity的生命周期。   \nActivity的生命周期有两种情况，第一种是正常情况下的创建，销毁。第二种是Activity被内存回收的情况。   \n\n1.正常情况下的生命周期   \n    1.onCreate   \n     表示Activity正在被创建,在这个方法中我们可以做一些初始化的工作，比如setContentView去加载资源布局、初始化Activity所需的数据。   \n     2.OnRestart   \n      表示Activity正在重新启动，Activity由不可见重新变为可见状态。这个过程一般是用户导致的。   \n     3.OnStart   \n       表示Activity正在被启动，即将开始，这个时候Activity已经可见，但是还没有出现到前台，无法和用户交互。   \n     4.OnResum   \n       表示Activity已经可见，并且出现在前台并开始活动，可以与用户用户做一些交互。它与OnStart都表示Activity可见。   \n     5.OnPause   \n        表示Activity正在停止，此时可以做一些操作，但是不能太耗时，因为新的Activity的onStart要等OnPause执行完才能执行。   \n     6.OnStop   \n        表示Activity即将停止，可以做一些重量级的回收操作，同样不能太耗时。   \n     7.OnDestory   \n        表示Acitivity即将被销毁，这个是Activity的最后一个毁掉，在这里我们可以做一些回收工作和最终的资源的释放。   \n\n问题1：onStart 和onResum ,OnPause和OnStop从描述上来看差不多，对我们来说有什么实质上的不同呢？   \n在我的理解中实质上的不同就是 能否与用户进行交互。onResum,OnPause都是在前台，而其他两个可见但是不在前台。   \n\n2.异常情况下的生命周期。   \n有几种情况     \n1.资源相关的系统废纸发生改变导致Activity被杀死并重建。      \n最典型的情况就是横竖屏，当横竖屏切换的时候，Activity会被销毁并重新创建。   \n在这种情况下Android会先调用它的onSaveInstanceState方法，保存当前状态。并且会把onSaveInstanceState保存的Bundle对象作为参数传给onRestoreInstanceState和onCreate方法。      \n我们可以从这两个方法中取出之前保存的数据并回复。   \n\n问题2:onRestoreInstanceState和onCreate方法既然都可以取出之前保存的数据，那么为什么还会有两个方法。   \n首先调用时机不同，onRestoreInstanceState是在onStart之后调用。   \n第二onRestoreInstanceState方法一旦被调用，那么Bundle一定是有值得。而OnCreate方法每次还需要判断是否为空。   \n\n2.资源内存不足导致低优先级的Activity被杀死   \n这种情况下的资源存储和恢复过程和第一种情况是相同的。主要讲述下Activity的优先级情况。由高到低分为以下三种。   \n1.前台Activity——正在和用户交互。优先级最高。   \n2.可见但非前台Activity——比如弹出一个对话框，导致Activity可见但是位于后台无法和用户直接交互。   \n3.后台Activity——已经被暂停的Activity，优先级最低。   \n\n  \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n\n","source":"_posts/Activity生命周期.md","raw":"---\ntitle: Activity生命周期  \ndate: 2016-07-20 20:39:24\ntags: Android\n---\n\nActivity是Android最重要的组件，因为它是与用户交互的。所以我们要弄明白Activity的生命周期。   \nActivity的生命周期有两种情况，第一种是正常情况下的创建，销毁。第二种是Activity被内存回收的情况。   \n\n1.正常情况下的生命周期   \n    1.onCreate   \n     表示Activity正在被创建,在这个方法中我们可以做一些初始化的工作，比如setContentView去加载资源布局、初始化Activity所需的数据。   \n     2.OnRestart   \n      表示Activity正在重新启动，Activity由不可见重新变为可见状态。这个过程一般是用户导致的。   \n     3.OnStart   \n       表示Activity正在被启动，即将开始，这个时候Activity已经可见，但是还没有出现到前台，无法和用户交互。   \n     4.OnResum   \n       表示Activity已经可见，并且出现在前台并开始活动，可以与用户用户做一些交互。它与OnStart都表示Activity可见。   \n     5.OnPause   \n        表示Activity正在停止，此时可以做一些操作，但是不能太耗时，因为新的Activity的onStart要等OnPause执行完才能执行。   \n     6.OnStop   \n        表示Activity即将停止，可以做一些重量级的回收操作，同样不能太耗时。   \n     7.OnDestory   \n        表示Acitivity即将被销毁，这个是Activity的最后一个毁掉，在这里我们可以做一些回收工作和最终的资源的释放。   \n\n问题1：onStart 和onResum ,OnPause和OnStop从描述上来看差不多，对我们来说有什么实质上的不同呢？   \n在我的理解中实质上的不同就是 能否与用户进行交互。onResum,OnPause都是在前台，而其他两个可见但是不在前台。   \n\n2.异常情况下的生命周期。   \n有几种情况     \n1.资源相关的系统废纸发生改变导致Activity被杀死并重建。      \n最典型的情况就是横竖屏，当横竖屏切换的时候，Activity会被销毁并重新创建。   \n在这种情况下Android会先调用它的onSaveInstanceState方法，保存当前状态。并且会把onSaveInstanceState保存的Bundle对象作为参数传给onRestoreInstanceState和onCreate方法。      \n我们可以从这两个方法中取出之前保存的数据并回复。   \n\n问题2:onRestoreInstanceState和onCreate方法既然都可以取出之前保存的数据，那么为什么还会有两个方法。   \n首先调用时机不同，onRestoreInstanceState是在onStart之后调用。   \n第二onRestoreInstanceState方法一旦被调用，那么Bundle一定是有值得。而OnCreate方法每次还需要判断是否为空。   \n\n2.资源内存不足导致低优先级的Activity被杀死   \n这种情况下的资源存储和恢复过程和第一种情况是相同的。主要讲述下Activity的优先级情况。由高到低分为以下三种。   \n1.前台Activity——正在和用户交互。优先级最高。   \n2.可见但非前台Activity——比如弹出一个对话框，导致Activity可见但是位于后台无法和用户直接交互。   \n3.后台Activity——已经被暂停的Activity，优先级最低。   \n\n  \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n\n","slug":"Activity生命周期","published":1,"updated":"2016-11-29T04:01:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcxm00034jp53bjgzq98","content":"<p>Activity是Android最重要的组件，因为它是与用户交互的。所以我们要弄明白Activity的生命周期。<br>Activity的生命周期有两种情况，第一种是正常情况下的创建，销毁。第二种是Activity被内存回收的情况。   </p>\n<p>1.正常情况下的生命周期<br>    1.onCreate<br>     表示Activity正在被创建,在这个方法中我们可以做一些初始化的工作，比如setContentView去加载资源布局、初始化Activity所需的数据。<br>     2.OnRestart<br>      表示Activity正在重新启动，Activity由不可见重新变为可见状态。这个过程一般是用户导致的。<br>     3.OnStart<br>       表示Activity正在被启动，即将开始，这个时候Activity已经可见，但是还没有出现到前台，无法和用户交互。<br>     4.OnResum<br>       表示Activity已经可见，并且出现在前台并开始活动，可以与用户用户做一些交互。它与OnStart都表示Activity可见。<br>     5.OnPause<br>        表示Activity正在停止，此时可以做一些操作，但是不能太耗时，因为新的Activity的onStart要等OnPause执行完才能执行。<br>     6.OnStop<br>        表示Activity即将停止，可以做一些重量级的回收操作，同样不能太耗时。<br>     7.OnDestory<br>        表示Acitivity即将被销毁，这个是Activity的最后一个毁掉，在这里我们可以做一些回收工作和最终的资源的释放。   </p>\n<p>问题1：onStart 和onResum ,OnPause和OnStop从描述上来看差不多，对我们来说有什么实质上的不同呢？<br>在我的理解中实质上的不同就是 能否与用户进行交互。onResum,OnPause都是在前台，而其他两个可见但是不在前台。   </p>\n<p>2.异常情况下的生命周期。<br>有几种情况<br>1.资源相关的系统废纸发生改变导致Activity被杀死并重建。<br>最典型的情况就是横竖屏，当横竖屏切换的时候，Activity会被销毁并重新创建。<br>在这种情况下Android会先调用它的onSaveInstanceState方法，保存当前状态。并且会把onSaveInstanceState保存的Bundle对象作为参数传给onRestoreInstanceState和onCreate方法。<br>我们可以从这两个方法中取出之前保存的数据并回复。   </p>\n<p>问题2:onRestoreInstanceState和onCreate方法既然都可以取出之前保存的数据，那么为什么还会有两个方法。<br>首先调用时机不同，onRestoreInstanceState是在onStart之后调用。<br>第二onRestoreInstanceState方法一旦被调用，那么Bundle一定是有值得。而OnCreate方法每次还需要判断是否为空。   </p>\n<p>2.资源内存不足导致低优先级的Activity被杀死<br>这种情况下的资源存储和恢复过程和第一种情况是相同的。主要讲述下Activity的优先级情况。由高到低分为以下三种。<br>1.前台Activity——正在和用户交互。优先级最高。<br>2.可见但非前台Activity——比如弹出一个对话框，导致Activity可见但是位于后台无法和用户直接交互。<br>3.后台Activity——已经被暂停的Activity，优先级最低。   </p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"","more":"<p>Activity是Android最重要的组件，因为它是与用户交互的。所以我们要弄明白Activity的生命周期。<br>Activity的生命周期有两种情况，第一种是正常情况下的创建，销毁。第二种是Activity被内存回收的情况。   </p>\n<p>1.正常情况下的生命周期<br>    1.onCreate<br>     表示Activity正在被创建,在这个方法中我们可以做一些初始化的工作，比如setContentView去加载资源布局、初始化Activity所需的数据。<br>     2.OnRestart<br>      表示Activity正在重新启动，Activity由不可见重新变为可见状态。这个过程一般是用户导致的。<br>     3.OnStart<br>       表示Activity正在被启动，即将开始，这个时候Activity已经可见，但是还没有出现到前台，无法和用户交互。<br>     4.OnResum<br>       表示Activity已经可见，并且出现在前台并开始活动，可以与用户用户做一些交互。它与OnStart都表示Activity可见。<br>     5.OnPause<br>        表示Activity正在停止，此时可以做一些操作，但是不能太耗时，因为新的Activity的onStart要等OnPause执行完才能执行。<br>     6.OnStop<br>        表示Activity即将停止，可以做一些重量级的回收操作，同样不能太耗时。<br>     7.OnDestory<br>        表示Acitivity即将被销毁，这个是Activity的最后一个毁掉，在这里我们可以做一些回收工作和最终的资源的释放。   </p>\n<p>问题1：onStart 和onResum ,OnPause和OnStop从描述上来看差不多，对我们来说有什么实质上的不同呢？<br>在我的理解中实质上的不同就是 能否与用户进行交互。onResum,OnPause都是在前台，而其他两个可见但是不在前台。   </p>\n<p>2.异常情况下的生命周期。<br>有几种情况<br>1.资源相关的系统废纸发生改变导致Activity被杀死并重建。<br>最典型的情况就是横竖屏，当横竖屏切换的时候，Activity会被销毁并重新创建。<br>在这种情况下Android会先调用它的onSaveInstanceState方法，保存当前状态。并且会把onSaveInstanceState保存的Bundle对象作为参数传给onRestoreInstanceState和onCreate方法。<br>我们可以从这两个方法中取出之前保存的数据并回复。   </p>\n<p>问题2:onRestoreInstanceState和onCreate方法既然都可以取出之前保存的数据，那么为什么还会有两个方法。<br>首先调用时机不同，onRestoreInstanceState是在onStart之后调用。<br>第二onRestoreInstanceState方法一旦被调用，那么Bundle一定是有值得。而OnCreate方法每次还需要判断是否为空。   </p>\n<p>2.资源内存不足导致低优先级的Activity被杀死<br>这种情况下的资源存储和恢复过程和第一种情况是相同的。主要讲述下Activity的优先级情况。由高到低分为以下三种。<br>1.前台Activity——正在和用户交互。优先级最高。<br>2.可见但非前台Activity——比如弹出一个对话框，导致Activity可见但是位于后台无法和用户直接交互。<br>3.后台Activity——已经被暂停的Activity，优先级最低。   </p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n"},{"title":"Android Application类","date":"2016-03-10T15:29:38.000Z","_content":"Android中提供了Application这样一个类。看一下Android官方文档对此类的解释：\n> Base class for those who need to maintain global application state.   \nYou can provide your own implementation by specifying its name in your AndroidManifest.xml's <application> tag,\nwhich will cause that class to be instantiated for ou when the process for your application/package is created.   \n   \n\n大概意思就是：需要为应用程序提供全局变量，在AndroidManifest.xml中指定所实现的Application子类；<!--more-->   \n当你的Application进程被建立时，此类被实例化；   \n\n文档解释中也提到，实现Application子类并不是必须的；\n就是程序运行还是有Application概念的但不是核心，一个Application是一个进程，Application为整个程序提供Context； 此类使用非常简单；      \n\n[http://blog.csdn.net/maxleng/article/details/5621345](http://blog.csdn.net/maxleng/article/details/5621345)\n\n用法：   \n在application中初始化或者定义变量和方法，这些变量和方法可以全局使用。\n例子：\n   \n   \n```java\npublic class test extends Application {\n\n    private String name = \"yixin\";//可以全局使用\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n    }\n\n    /**\n     *  可以全局使用 在Activity中getApplication（）获取实例\n     *  然后就可以调用application中的对象和方法 并且是全局的\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n}\n\n```   \n\n当然还需要在AndroidManifest中去申明:   \n\n```xml\n\n<application\nandroid:name=\".app.test\"\nandroid:allowBackup=\"true\"\nandroid:largeHeap=\"true\"\nandroid:icon=\"@drawable/ic_launcher\"\nandroid:label=\"@string/app_name\">\n\n```   \n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢    \n邮箱：yee.xin.work@gmail.com\n\n\n","source":"_posts/Android-Application类.md","raw":"---\ntitle: Android Application类\ndate: 2016-3-10 23:29:38\ntags: Android\n---\nAndroid中提供了Application这样一个类。看一下Android官方文档对此类的解释：\n> Base class for those who need to maintain global application state.   \nYou can provide your own implementation by specifying its name in your AndroidManifest.xml's <application> tag,\nwhich will cause that class to be instantiated for ou when the process for your application/package is created.   \n   \n\n大概意思就是：需要为应用程序提供全局变量，在AndroidManifest.xml中指定所实现的Application子类；<!--more-->   \n当你的Application进程被建立时，此类被实例化；   \n\n文档解释中也提到，实现Application子类并不是必须的；\n就是程序运行还是有Application概念的但不是核心，一个Application是一个进程，Application为整个程序提供Context； 此类使用非常简单；      \n\n[http://blog.csdn.net/maxleng/article/details/5621345](http://blog.csdn.net/maxleng/article/details/5621345)\n\n用法：   \n在application中初始化或者定义变量和方法，这些变量和方法可以全局使用。\n例子：\n   \n   \n```java\npublic class test extends Application {\n\n    private String name = \"yixin\";//可以全局使用\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n    }\n\n    /**\n     *  可以全局使用 在Activity中getApplication（）获取实例\n     *  然后就可以调用application中的对象和方法 并且是全局的\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n}\n\n```   \n\n当然还需要在AndroidManifest中去申明:   \n\n```xml\n\n<application\nandroid:name=\".app.test\"\nandroid:allowBackup=\"true\"\nandroid:largeHeap=\"true\"\nandroid:icon=\"@drawable/ic_launcher\"\nandroid:label=\"@string/app_name\">\n\n```   \n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢    \n邮箱：yee.xin.work@gmail.com\n\n\n","slug":"Android-Application类","published":1,"updated":"2016-11-29T03:20:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcxq00044jp540cojmrp","content":"<p>Android中提供了Application这样一个类。看一下Android官方文档对此类的解释：</p>\n<blockquote>\n<p>Base class for those who need to maintain global application state.<br>You can provide your own implementation by specifying its name in your AndroidManifest.xml’s <application> tag,<br>which will cause that class to be instantiated for ou when the process for your application/package is created.   </application></p>\n</blockquote>\n<p>大概意思就是：需要为应用程序提供全局变量，在AndroidManifest.xml中指定所实现的Application子类；<a id=\"more\"></a><br>当你的Application进程被建立时，此类被实例化；   </p>\n<p>文档解释中也提到，实现Application子类并不是必须的；<br>就是程序运行还是有Application概念的但不是核心，一个Application是一个进程，Application为整个程序提供Context； 此类使用非常简单；      </p>\n<p><a href=\"http://blog.csdn.net/maxleng/article/details/5621345\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/maxleng/article/details/5621345</a></p>\n<p>用法：<br>在application中初始化或者定义变量和方法，这些变量和方法可以全局使用。<br>例子：</p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>{\n\n    <span class=\"keyword\">private</span> String name = <span class=\"string\">\"yixin\"</span>;<span class=\"comment\">//可以全局使用</span>\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n        <span class=\"keyword\">super</span>.onCreate();\n    }\n\n    <span class=\"comment\">/**\n     *  可以全局使用 在Activity中getApplication（）获取实例\n     *  然后就可以调用application中的对象和方法 并且是全局的\n     * <span class=\"doctag\">@return</span>\n     */</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>{\n        <span class=\"keyword\">return</span> name;\n    }\n}\n</code></pre>\n<p>当然还需要在AndroidManifest中去申明:   </p>\n<pre><code class=\"xml\">\n<span class=\"tag\">&lt;<span class=\"name\">application</span>\n<span class=\"attr\">android:name</span>=<span class=\"string\">\".app.test\"</span>\n<span class=\"attr\">android:allowBackup</span>=<span class=\"string\">\"true\"</span>\n<span class=\"attr\">android:largeHeap</span>=<span class=\"string\">\"true\"</span>\n<span class=\"attr\">android:icon</span>=<span class=\"string\">\"@drawable/ic_launcher\"</span>\n<span class=\"attr\">android:label</span>=<span class=\"string\">\"@string/app_name\"</span>&gt;</span>\n</code></pre>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com</p>\n","excerpt":"<p>Android中提供了Application这样一个类。看一下Android官方文档对此类的解释：</p>\n<blockquote>\n<p>Base class for those who need to maintain global application state.<br>You can provide your own implementation by specifying its name in your AndroidManifest.xml’s <application> tag,<br>which will cause that class to be instantiated for ou when the process for your application/package is created.   </p>\n</blockquote>\n<p>大概意思就是：需要为应用程序提供全局变量，在AndroidManifest.xml中指定所实现的Application子类；","more":"<br>当你的Application进程被建立时，此类被实例化；   </p>\n<p>文档解释中也提到，实现Application子类并不是必须的；<br>就是程序运行还是有Application概念的但不是核心，一个Application是一个进程，Application为整个程序提供Context； 此类使用非常简单；      </p>\n<p><a href=\"http://blog.csdn.net/maxleng/article/details/5621345\">http://blog.csdn.net/maxleng/article/details/5621345</a></p>\n<p>用法：<br>在application中初始化或者定义变量和方法，这些变量和方法可以全局使用。<br>例子：</p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>{\n\n    <span class=\"keyword\">private</span> String name = <span class=\"string\">\"yixin\"</span>;<span class=\"comment\">//可以全局使用</span>\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>{\n        <span class=\"keyword\">super</span>.onCreate();\n    }\n\n    <span class=\"comment\">/**\n     *  可以全局使用 在Activity中getApplication（）获取实例\n     *  然后就可以调用application中的对象和方法 并且是全局的\n     * <span class=\"doctag\">@return</span>\n     */</span>\n    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>{\n        <span class=\"keyword\">return</span> name;\n    }\n}\n</code></pre>\n<p>当然还需要在AndroidManifest中去申明:   </p>\n<pre><code class=\"xml\">\n<span class=\"tag\">&lt;<span class=\"name\">application</span>\n<span class=\"attr\">android:name</span>=<span class=\"string\">\".app.test\"</span>\n<span class=\"attr\">android:allowBackup</span>=<span class=\"string\">\"true\"</span>\n<span class=\"attr\">android:largeHeap</span>=<span class=\"string\">\"true\"</span>\n<span class=\"attr\">android:icon</span>=<span class=\"string\">\"@drawable/ic_launcher\"</span>\n<span class=\"attr\">android:label</span>=<span class=\"string\">\"@string/app_name\"</span>&gt;</span>\n</code></pre>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com</p>"},{"title":"Android 属性动画","date":"2016-10-12T06:10:14.000Z","_content":"Android属性动画主要分为两种：   \nValueAnimator和ObjectAnimator两种,总体来说区别并不大。   \nObjectAnimator是继承的ValueAnimator。就相当于对ValueAnimator的一种封装，操作更方便点。   \n所以先来了解下ValueAnimator：   \n我们要使用一个东西 当然避免不了要初始化一个变量：   \nValueAnimator有很多的静态方法来获取ValueAnimator。   \nstatic ValueAnimator\tofArgb(int... values)   \nConstructs and returns a ValueAnimator that animates between color values.    \nstatic ValueAnimator\tofFloat(float... values)   \nConstructs and returns a ValueAnimator that animates between float values.   \nstatic ValueAnimator\tofInt(int... values)   \nConstructs and returns a ValueAnimator that animates between int values.   \nstatic ValueAnimator\tofObject(TypeEvaluator evaluator, Object... values)   \nConstructs and returns a ValueAnimator that animates between Object values.   \nstatic ValueAnimator\tofPropertyValuesHolder(PropertyValuesHolder... values)   \nConstructs and returns a ValueAnimator that animates between the values specified in the PropertyValuesHolder objects.   \n\n例子：   \nValueAnimator animator = ValueAnimator.ofObject(new PenghuiEvaluator(), new Penghui(155, 45.54f), new Penghui(777, 888));\n","source":"_posts/Android-属性动画.md","raw":"---\ntitle: Android 属性动画\ndate: 2016-10-12 14:10:14\ntags: Android\n---\nAndroid属性动画主要分为两种：   \nValueAnimator和ObjectAnimator两种,总体来说区别并不大。   \nObjectAnimator是继承的ValueAnimator。就相当于对ValueAnimator的一种封装，操作更方便点。   \n所以先来了解下ValueAnimator：   \n我们要使用一个东西 当然避免不了要初始化一个变量：   \nValueAnimator有很多的静态方法来获取ValueAnimator。   \nstatic ValueAnimator\tofArgb(int... values)   \nConstructs and returns a ValueAnimator that animates between color values.    \nstatic ValueAnimator\tofFloat(float... values)   \nConstructs and returns a ValueAnimator that animates between float values.   \nstatic ValueAnimator\tofInt(int... values)   \nConstructs and returns a ValueAnimator that animates between int values.   \nstatic ValueAnimator\tofObject(TypeEvaluator evaluator, Object... values)   \nConstructs and returns a ValueAnimator that animates between Object values.   \nstatic ValueAnimator\tofPropertyValuesHolder(PropertyValuesHolder... values)   \nConstructs and returns a ValueAnimator that animates between the values specified in the PropertyValuesHolder objects.   \n\n例子：   \nValueAnimator animator = ValueAnimator.ofObject(new PenghuiEvaluator(), new Penghui(155, 45.54f), new Penghui(777, 888));\n","slug":"Android-属性动画","published":1,"updated":"2016-11-29T06:11:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcxr00054jp58ohhchtp","content":"<p>Android属性动画主要分为两种：<br>ValueAnimator和ObjectAnimator两种,总体来说区别并不大。<br>ObjectAnimator是继承的ValueAnimator。就相当于对ValueAnimator的一种封装，操作更方便点。<br>所以先来了解下ValueAnimator：<br>我们要使用一个东西 当然避免不了要初始化一个变量：<br>ValueAnimator有很多的静态方法来获取ValueAnimator。<br>static ValueAnimator    ofArgb(int… values)<br>Constructs and returns a ValueAnimator that animates between color values.<br>static ValueAnimator    ofFloat(float… values)<br>Constructs and returns a ValueAnimator that animates between float values.<br>static ValueAnimator    ofInt(int… values)<br>Constructs and returns a ValueAnimator that animates between int values.<br>static ValueAnimator    ofObject(TypeEvaluator evaluator, Object… values)<br>Constructs and returns a ValueAnimator that animates between Object values.<br>static ValueAnimator    ofPropertyValuesHolder(PropertyValuesHolder… values)<br>Constructs and returns a ValueAnimator that animates between the values specified in the PropertyValuesHolder objects.   </p>\n<p>例子：<br>ValueAnimator animator = ValueAnimator.ofObject(new PenghuiEvaluator(), new Penghui(155, 45.54f), new Penghui(777, 888));</p>\n","excerpt":"","more":"<p>Android属性动画主要分为两种：<br>ValueAnimator和ObjectAnimator两种,总体来说区别并不大。<br>ObjectAnimator是继承的ValueAnimator。就相当于对ValueAnimator的一种封装，操作更方便点。<br>所以先来了解下ValueAnimator：<br>我们要使用一个东西 当然避免不了要初始化一个变量：<br>ValueAnimator有很多的静态方法来获取ValueAnimator。<br>static ValueAnimator    ofArgb(int… values)<br>Constructs and returns a ValueAnimator that animates between color values.<br>static ValueAnimator    ofFloat(float… values)<br>Constructs and returns a ValueAnimator that animates between float values.<br>static ValueAnimator    ofInt(int… values)<br>Constructs and returns a ValueAnimator that animates between int values.<br>static ValueAnimator    ofObject(TypeEvaluator evaluator, Object… values)<br>Constructs and returns a ValueAnimator that animates between Object values.<br>static ValueAnimator    ofPropertyValuesHolder(PropertyValuesHolder… values)<br>Constructs and returns a ValueAnimator that animates between the values specified in the PropertyValuesHolder objects.   </p>\n<p>例子：<br>ValueAnimator animator = ValueAnimator.ofObject(new PenghuiEvaluator(), new Penghui(155, 45.54f), new Penghui(777, 888));</p>\n"},{"title":"Android消息机制——Looper的工作原理","date":"2016-02-15T11:44:43.000Z","_content":"Looper在Android消息机制中扮演消息循环者的角色，具体就是会不停的从MessageQueue中查看是否有新的消息，如果有新的消息就会处理，否则就会阻塞在那里。Handler的工作需要Looper，没有Looper的线程就会报错。通过Looper.prepare()就可以为当前的线程创建一个Looper，然后通过Looper.looper()来开启消息循环。<!--more-->   \nLooper为主线程（ActivityThread）提供了创建Looper的方法——prepareMainLooper，这个方法的本质也是也是用的Looper.prepare().   \n主线程也可以通过getMainLooper获取主线程的Looper。（这个方法可以在其他地方获取到主线程的Looper）   \nLooper也是可以退出的，Looper提供了quit和quitsafely方法。两个的区别是quit是直接退出，quitsafely是设置一个退出标记，然后把消息队列中的已有消息处理完毕后再安全的退出。Looper退出后，通过Handler发送消息会失败。   \n在子线程中手动创建了Looper，在所有的事情完成只有要调用quit方法来终止消息的循环，否则这个子线程就会一直处于等待状态，退出Looper以后，这个线程就会立即终止，因此在不需要的时候终止Looper。   \nLooper的loop方法是一个死循环，唯一的跳出循环的方法就是MessageQueue的next方法返回null。当Looper的quit方法被调用的时候Looper就会调用MessageQueue的quit方法，当消息队列被标记为退出状态时，他的next方法就会返回null。也就是说，Looper必须退出，否者loop方法就会无限循环下去。loop会调用MessageQueue的next方法，但是next方法本身就是一个阻塞方法，所以loop就会一直阻塞在那里。  \n只有UI线程也就是主线程会默认调用Looper.prepare()和Looper.loop();\n\n---\n\n### Looper.loop()方法：\n```java\n/**\n * Run the message queue in this thread. Be sure to call\n * {@link #quit()} to end the loop.\n */\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    // Make sure the identity of this thread is that of the local process,\n    // and keep track of what that identity token actually is.\n    Binder.clearCallingIdentity();\n    final long ident = Binder.clearCallingIdentity();\n\n    for (;;) {//死循环\n        Message msg = queue.next(); // might block  next方法本身也是一个阻塞方法\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n\n        // This must be in a local variable, in case a UI event sets the logger\n        Printer logging = me.mLogging;\n        if (logging != null) {\n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                    msg.callback + \": \" + msg.what);\n        }\n\n        msg.target.dispatchMessage(msg);\n\n        if (logging != null) {\n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n        }\n\n        // Make sure that during the course of dispatching the\n        // identity of the thread wasn't corrupted.\n        final long newIdent = Binder.clearCallingIdentity();\n        if (ident != newIdent) {\n            Log.wtf(TAG, \"Thread identity changed from 0x\"\n                    + Long.toHexString(ident) + \" to 0x\"\n                    + Long.toHexString(newIdent) + \" while dispatching to \"\n                    + msg.target.getClass().getName() + \" \"\n                    + msg.callback + \" what=\" + msg.what);\n        }\n\n        msg.recycleUnchecked();\n    }\n}\n```\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢 邮箱：yee.xin.work@gmail.com","source":"_posts/Android消息机制——Looper的工作原理.md","raw":"---\ntitle: Android消息机制——Looper的工作原理\ndate: 2016-2-15 19:44:43\ntags: Android\n---\nLooper在Android消息机制中扮演消息循环者的角色，具体就是会不停的从MessageQueue中查看是否有新的消息，如果有新的消息就会处理，否则就会阻塞在那里。Handler的工作需要Looper，没有Looper的线程就会报错。通过Looper.prepare()就可以为当前的线程创建一个Looper，然后通过Looper.looper()来开启消息循环。<!--more-->   \nLooper为主线程（ActivityThread）提供了创建Looper的方法——prepareMainLooper，这个方法的本质也是也是用的Looper.prepare().   \n主线程也可以通过getMainLooper获取主线程的Looper。（这个方法可以在其他地方获取到主线程的Looper）   \nLooper也是可以退出的，Looper提供了quit和quitsafely方法。两个的区别是quit是直接退出，quitsafely是设置一个退出标记，然后把消息队列中的已有消息处理完毕后再安全的退出。Looper退出后，通过Handler发送消息会失败。   \n在子线程中手动创建了Looper，在所有的事情完成只有要调用quit方法来终止消息的循环，否则这个子线程就会一直处于等待状态，退出Looper以后，这个线程就会立即终止，因此在不需要的时候终止Looper。   \nLooper的loop方法是一个死循环，唯一的跳出循环的方法就是MessageQueue的next方法返回null。当Looper的quit方法被调用的时候Looper就会调用MessageQueue的quit方法，当消息队列被标记为退出状态时，他的next方法就会返回null。也就是说，Looper必须退出，否者loop方法就会无限循环下去。loop会调用MessageQueue的next方法，但是next方法本身就是一个阻塞方法，所以loop就会一直阻塞在那里。  \n只有UI线程也就是主线程会默认调用Looper.prepare()和Looper.loop();\n\n---\n\n### Looper.loop()方法：\n```java\n/**\n * Run the message queue in this thread. Be sure to call\n * {@link #quit()} to end the loop.\n */\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    // Make sure the identity of this thread is that of the local process,\n    // and keep track of what that identity token actually is.\n    Binder.clearCallingIdentity();\n    final long ident = Binder.clearCallingIdentity();\n\n    for (;;) {//死循环\n        Message msg = queue.next(); // might block  next方法本身也是一个阻塞方法\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n\n        // This must be in a local variable, in case a UI event sets the logger\n        Printer logging = me.mLogging;\n        if (logging != null) {\n            logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                    msg.callback + \": \" + msg.what);\n        }\n\n        msg.target.dispatchMessage(msg);\n\n        if (logging != null) {\n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n        }\n\n        // Make sure that during the course of dispatching the\n        // identity of the thread wasn't corrupted.\n        final long newIdent = Binder.clearCallingIdentity();\n        if (ident != newIdent) {\n            Log.wtf(TAG, \"Thread identity changed from 0x\"\n                    + Long.toHexString(ident) + \" to 0x\"\n                    + Long.toHexString(newIdent) + \" while dispatching to \"\n                    + msg.target.getClass().getName() + \" \"\n                    + msg.callback + \" what=\" + msg.what);\n        }\n\n        msg.recycleUnchecked();\n    }\n}\n```\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢 邮箱：yee.xin.work@gmail.com","slug":"Android消息机制——Looper的工作原理","published":1,"updated":"2016-11-29T01:52:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcxu00084jp5cgh98j4v","content":"<p>Looper在Android消息机制中扮演消息循环者的角色，具体就是会不停的从MessageQueue中查看是否有新的消息，如果有新的消息就会处理，否则就会阻塞在那里。Handler的工作需要Looper，没有Looper的线程就会报错。通过Looper.prepare()就可以为当前的线程创建一个Looper，然后通过Looper.looper()来开启消息循环。<a id=\"more\"></a><br>Looper为主线程（ActivityThread）提供了创建Looper的方法——prepareMainLooper，这个方法的本质也是也是用的Looper.prepare().<br>主线程也可以通过getMainLooper获取主线程的Looper。（这个方法可以在其他地方获取到主线程的Looper）<br>Looper也是可以退出的，Looper提供了quit和quitsafely方法。两个的区别是quit是直接退出，quitsafely是设置一个退出标记，然后把消息队列中的已有消息处理完毕后再安全的退出。Looper退出后，通过Handler发送消息会失败。<br>在子线程中手动创建了Looper，在所有的事情完成只有要调用quit方法来终止消息的循环，否则这个子线程就会一直处于等待状态，退出Looper以后，这个线程就会立即终止，因此在不需要的时候终止Looper。<br>Looper的loop方法是一个死循环，唯一的跳出循环的方法就是MessageQueue的next方法返回null。当Looper的quit方法被调用的时候Looper就会调用MessageQueue的quit方法，当消息队列被标记为退出状态时，他的next方法就会返回null。也就是说，Looper必须退出，否者loop方法就会无限循环下去。loop会调用MessageQueue的next方法，但是next方法本身就是一个阻塞方法，所以loop就会一直阻塞在那里。<br>只有UI线程也就是主线程会默认调用Looper.prepare()和Looper.loop();</p>\n<hr>\n<h3 id=\"Looper-loop-方法：\"><a href=\"#Looper-loop-方法：\" class=\"headerlink\" title=\"Looper.loop()方法：\"></a>Looper.loop()方法：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Run the message queue in this thread. Be sure to call</div><div class=\"line\"> * &#123;<span class=\"doctag\">@link</span> #quit()&#125; to end the loop.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,</span></div><div class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.</span></div><div class=\"line\">    Binder.clearCallingIdentity();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;<span class=\"comment\">//死循环</span></div><div class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block  next方法本身也是一个阻塞方法</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger</span></div><div class=\"line\">        Printer logging = me.mLogging;</div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +</div><div class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the</span></div><div class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.</span></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;</div><div class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span></div><div class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span></div><div class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span></div><div class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span></div><div class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.recycleUnchecked();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢 邮箱：yee.xin.work@gmail.com</p>\n","excerpt":"<p>Looper在Android消息机制中扮演消息循环者的角色，具体就是会不停的从MessageQueue中查看是否有新的消息，如果有新的消息就会处理，否则就会阻塞在那里。Handler的工作需要Looper，没有Looper的线程就会报错。通过Looper.prepare()就可以为当前的线程创建一个Looper，然后通过Looper.looper()来开启消息循环。","more":"<br>Looper为主线程（ActivityThread）提供了创建Looper的方法——prepareMainLooper，这个方法的本质也是也是用的Looper.prepare().<br>主线程也可以通过getMainLooper获取主线程的Looper。（这个方法可以在其他地方获取到主线程的Looper）<br>Looper也是可以退出的，Looper提供了quit和quitsafely方法。两个的区别是quit是直接退出，quitsafely是设置一个退出标记，然后把消息队列中的已有消息处理完毕后再安全的退出。Looper退出后，通过Handler发送消息会失败。<br>在子线程中手动创建了Looper，在所有的事情完成只有要调用quit方法来终止消息的循环，否则这个子线程就会一直处于等待状态，退出Looper以后，这个线程就会立即终止，因此在不需要的时候终止Looper。<br>Looper的loop方法是一个死循环，唯一的跳出循环的方法就是MessageQueue的next方法返回null。当Looper的quit方法被调用的时候Looper就会调用MessageQueue的quit方法，当消息队列被标记为退出状态时，他的next方法就会返回null。也就是说，Looper必须退出，否者loop方法就会无限循环下去。loop会调用MessageQueue的next方法，但是next方法本身就是一个阻塞方法，所以loop就会一直阻塞在那里。<br>只有UI线程也就是主线程会默认调用Looper.prepare()和Looper.loop();</p>\n<hr>\n<h3 id=\"Looper-loop-方法：\"><a href=\"#Looper-loop-方法：\" class=\"headerlink\" title=\"Looper.loop()方法：\"></a>Looper.loop()方法：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Run the message queue in this thread. Be sure to call</div><div class=\"line\"> * &#123;<span class=\"doctag\">@link</span> #quit()&#125; to end the loop.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,</span></div><div class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.</span></div><div class=\"line\">    Binder.clearCallingIdentity();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;<span class=\"comment\">//死循环</span></div><div class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block  next方法本身也是一个阻塞方法</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger</span></div><div class=\"line\">        Printer logging = me.mLogging;</div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt; Dispatching to \"</span> + msg.target + <span class=\"string\">\" \"</span> +</div><div class=\"line\">                    msg.callback + <span class=\"string\">\": \"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.target.dispatchMessage(msg);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            logging.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt; Finished to \"</span> + msg.target + <span class=\"string\">\" \"</span> + msg.callback);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the</span></div><div class=\"line\">        <span class=\"comment\">// identity of the thread wasn't corrupted.</span></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();</div><div class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;</div><div class=\"line\">            Log.wtf(TAG, <span class=\"string\">\"Thread identity changed from 0x\"</span></div><div class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">\" to 0x\"</span></div><div class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">\" while dispatching to \"</span></div><div class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">\" \"</span></div><div class=\"line\">                    + msg.callback + <span class=\"string\">\" what=\"</span> + msg.what);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.recycleUnchecked();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢 邮箱：yee.xin.work@gmail.com</p>"},{"title":"Android消息机制——ThreadLocal","date":"2016-02-13T03:07:41.000Z","_content":"ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。\n在日常开发中用到这个类的地方为:   \n某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候。 <!--more-->    \n列如： \n \n```java    \n\npublic class MainActivity extends AppCompatActivity {\n\tprivate ThreadLocal<String> m = new ThreadLocal<>();\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tm.set(\"主线程\");\n\t\tm.remove();\n\t\tnew Thread(\"子线程1\") {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\tsuper.run();\n\t\t\tm.set(\"子线程1\");\n\n\t\t\tLog.e(\"子线程1\", m.get());\n\t\t\t}\n\t\t}.start();\n\n\t\tnew Thread(\"子线程2\") {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\tsuper.run();\n\t\t\tm.set(\"子线程2\");\n\t\t\tLog.e(\"子线程2\", m.get());\n\t\t\t}\n\t\t}.start();\n\n\t\tLog.e(\"主线程\", m.get());\n\t}\n}\n```   \n结果：   \n02-15 10:43:01.413 5953-5997/kyle.yee.com.yiaccount E/子线程1: 子线程1   \n02-15 10:43:01.413 5953-5953/kyle.yee.com.yiaccount E/主线程: 主线程   \n02-15 10:43:01.414 5953-5998/kyle.yee.com.yiaccount E/子线程2: 子线程2   \n结论：   \n相同的对象在不同的类中操作的不同的数据副本。相当于线程自己在操作自己线程的数据。其他线程无法访问。\n\n以上内容均为学习记录，若有问题，欢迎纠正，谢谢~","source":"_posts/Android消息机制——ThreadLocal.md","raw":"---\ntitle: Android消息机制——ThreadLocal\ndate: 2016-2-13 11:07:41\ntags: Android\n---\nThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。\n在日常开发中用到这个类的地方为:   \n某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候。 <!--more-->    \n列如： \n \n```java    \n\npublic class MainActivity extends AppCompatActivity {\n\tprivate ThreadLocal<String> m = new ThreadLocal<>();\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tm.set(\"主线程\");\n\t\tm.remove();\n\t\tnew Thread(\"子线程1\") {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\tsuper.run();\n\t\t\tm.set(\"子线程1\");\n\n\t\t\tLog.e(\"子线程1\", m.get());\n\t\t\t}\n\t\t}.start();\n\n\t\tnew Thread(\"子线程2\") {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\tsuper.run();\n\t\t\tm.set(\"子线程2\");\n\t\t\tLog.e(\"子线程2\", m.get());\n\t\t\t}\n\t\t}.start();\n\n\t\tLog.e(\"主线程\", m.get());\n\t}\n}\n```   \n结果：   \n02-15 10:43:01.413 5953-5997/kyle.yee.com.yiaccount E/子线程1: 子线程1   \n02-15 10:43:01.413 5953-5953/kyle.yee.com.yiaccount E/主线程: 主线程   \n02-15 10:43:01.414 5953-5998/kyle.yee.com.yiaccount E/子线程2: 子线程2   \n结论：   \n相同的对象在不同的类中操作的不同的数据副本。相当于线程自己在操作自己线程的数据。其他线程无法访问。\n\n以上内容均为学习记录，若有问题，欢迎纠正，谢谢~","slug":"Android消息机制——ThreadLocal","published":1,"updated":"2016-11-29T02:19:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcxx000a4jp5qhblrjl0","content":"<p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。<br>在日常开发中用到这个类的地方为:<br>某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候。 <a id=\"more\"></a><br>列如： </p>\n<pre><code class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>{\n    <span class=\"keyword\">private</span> ThreadLocal&lt;String&gt; m = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>{\n        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        m.set(<span class=\"string\">\"主线程\"</span>);\n        m.remove();\n        <span class=\"keyword\">new</span> Thread(<span class=\"string\">\"子线程1\"</span>) {\n            <span class=\"meta\">@Override</span>\n            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>{\n            <span class=\"keyword\">super</span>.run();\n            m.set(<span class=\"string\">\"子线程1\"</span>);\n\n            Log.e(<span class=\"string\">\"子线程1\"</span>, m.get());\n            }\n        }.start();\n\n        <span class=\"keyword\">new</span> Thread(<span class=\"string\">\"子线程2\"</span>) {\n            <span class=\"meta\">@Override</span>\n            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>{\n            <span class=\"keyword\">super</span>.run();\n            m.set(<span class=\"string\">\"子线程2\"</span>);\n            Log.e(<span class=\"string\">\"子线程2\"</span>, m.get());\n            }\n        }.start();\n\n        Log.e(<span class=\"string\">\"主线程\"</span>, m.get());\n    }\n}\n</code></pre>\n<p>结果：<br>02-15 10:43:01.413 5953-5997/kyle.yee.com.yiaccount E/子线程1: 子线程1<br>02-15 10:43:01.413 5953-5953/kyle.yee.com.yiaccount E/主线程: 主线程<br>02-15 10:43:01.414 5953-5998/kyle.yee.com.yiaccount E/子线程2: 子线程2<br>结论：<br>相同的对象在不同的类中操作的不同的数据副本。相当于线程自己在操作自己线程的数据。其他线程无法访问。</p>\n<p>以上内容均为学习记录，若有问题，欢迎纠正，谢谢~</p>\n","excerpt":"<p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。<br>在日常开发中用到这个类的地方为:<br>某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候。","more":"<br>列如： </p>\n<pre><code class=\"java\">\n<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>{\n    <span class=\"keyword\">private</span> ThreadLocal&lt;String&gt; m = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();\n\n    <span class=\"meta\">@Override</span>\n    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>{\n        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        m.set(<span class=\"string\">\"主线程\"</span>);\n        m.remove();\n        <span class=\"keyword\">new</span> Thread(<span class=\"string\">\"子线程1\"</span>) {\n            <span class=\"meta\">@Override</span>\n            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>{\n            <span class=\"keyword\">super</span>.run();\n            m.set(<span class=\"string\">\"子线程1\"</span>);\n\n            Log.e(<span class=\"string\">\"子线程1\"</span>, m.get());\n            }\n        }.start();\n\n        <span class=\"keyword\">new</span> Thread(<span class=\"string\">\"子线程2\"</span>) {\n            <span class=\"meta\">@Override</span>\n            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>{\n            <span class=\"keyword\">super</span>.run();\n            m.set(<span class=\"string\">\"子线程2\"</span>);\n            Log.e(<span class=\"string\">\"子线程2\"</span>, m.get());\n            }\n        }.start();\n\n        Log.e(<span class=\"string\">\"主线程\"</span>, m.get());\n    }\n}\n</code></pre>\n<p>结果：<br>02-15 10:43:01.413 5953-5997/kyle.yee.com.yiaccount E/子线程1: 子线程1<br>02-15 10:43:01.413 5953-5953/kyle.yee.com.yiaccount E/主线程: 主线程<br>02-15 10:43:01.414 5953-5998/kyle.yee.com.yiaccount E/子线程2: 子线程2<br>结论：<br>相同的对象在不同的类中操作的不同的数据副本。相当于线程自己在操作自己线程的数据。其他线程无法访问。</p>\n<p>以上内容均为学习记录，若有问题，欢迎纠正，谢谢~</p>"},{"title":"Android消息机制——消息队列工作原理","date":"2016-02-19T01:33:52.000Z","_content":"消息队列在Android中指的是MessageQueue,MessageQueue主要包含两个操作：插入和独处。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next。其中enqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。消息队列内部是通过一个单链表的数据结构来维护消息列表，因为链表在插入和删除上比较有优势。<!--more-->\n\n## enqueueMessage方法（实际上就是单链表的插入操作）：\n```java\nboolean enqueueMessage(Message msg, long when) {\n    if (msg.target == null) {\n        throw new IllegalArgumentException(\"Message must have a target.\");\n    }\n    if (msg.isInUse()) {\n        throw new IllegalStateException(msg + \" This message is already in use.\");\n    }\n\n    synchronized (this) {\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            Log.w(\"MessageQueue\", e.getMessage(), e);\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            // New head, wake up the event queue if blocked.\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // Inserted within the middle of the queue.  Usually we don't have to wake\n            // up the event queue unless there is a barrier at the head of the queue\n            // and the message is the earliest asynchronous message in the queue.\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n```   \n## next方法（next方法是一个无限循环的方法，如果没有消息就会阻塞）：\n```java\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                if (now < msg.when) {\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg);\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // Process the quit message now that all pending messages have been handled.\n            if (mQuitting) {\n                dispose();\n                return null;\n            }\n\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                mBlocked = true;\n                continue;\n            }\n\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t);\n            }\n\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢\n邮箱：yee.xin.work@gmail.com","source":"_posts/Android消息机制——消息队列工作原理.md","raw":"---\ntitle: Android消息机制——消息队列工作原理\ndate: 2016-2-19 09:33:52\ntags: Android\n---\n消息队列在Android中指的是MessageQueue,MessageQueue主要包含两个操作：插入和独处。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next。其中enqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。消息队列内部是通过一个单链表的数据结构来维护消息列表，因为链表在插入和删除上比较有优势。<!--more-->\n\n## enqueueMessage方法（实际上就是单链表的插入操作）：\n```java\nboolean enqueueMessage(Message msg, long when) {\n    if (msg.target == null) {\n        throw new IllegalArgumentException(\"Message must have a target.\");\n    }\n    if (msg.isInUse()) {\n        throw new IllegalStateException(msg + \" This message is already in use.\");\n    }\n\n    synchronized (this) {\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            Log.w(\"MessageQueue\", e.getMessage(), e);\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            // New head, wake up the event queue if blocked.\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // Inserted within the middle of the queue.  Usually we don't have to wake\n            // up the event queue unless there is a barrier at the head of the queue\n            // and the message is the earliest asynchronous message in the queue.\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n```   \n## next方法（next方法是一个无限循环的方法，如果没有消息就会阻塞）：\n```java\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                if (now < msg.when) {\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg);\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // Process the quit message now that all pending messages have been handled.\n            if (mQuitting) {\n                dispose();\n                return null;\n            }\n\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                mBlocked = true;\n                continue;\n            }\n\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t);\n            }\n\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢\n邮箱：yee.xin.work@gmail.com","slug":"Android消息机制——消息队列工作原理","published":1,"updated":"2016-11-29T01:42:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcy0000d4jp57j4rhtv1","content":"<p>消息队列在Android中指的是MessageQueue,MessageQueue主要包含两个操作：插入和独处。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next。其中enqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。消息队列内部是通过一个单链表的数据结构来维护消息列表，因为链表在插入和删除上比较有优势。<a id=\"more\"></a></p>\n<h2 id=\"enqueueMessage方法（实际上就是单链表的插入操作）：\"><a href=\"#enqueueMessage方法（实际上就是单链表的插入操作）：\" class=\"headerlink\" title=\"enqueueMessage方法（实际上就是单链表的插入操作）：\"></a>enqueueMessage方法（实际上就是单链表的插入操作）：</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean enqueueMessage(Message msg, long when) &#123;</div><div class=\"line\">    if (msg.target == null) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(\"Message must have a target.\");</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg.isInUse()) &#123;</div><div class=\"line\">        throw new IllegalStateException(msg + \" This message is already in use.\");</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        if (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = new IllegalStateException(</div><div class=\"line\">                    msg.target + \" sending message to a Handler on a dead thread\");</div><div class=\"line\">            Log.w(\"MessageQueue\", e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        boolean needWake;</div><div class=\"line\">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class=\"line\">            // New head, wake up the event queue if blocked.</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Inserted within the middle of the queue.  Usually we don't have to wake</div><div class=\"line\">            // up the event queue unless there is a barrier at the head of the queue</div><div class=\"line\">            // and the message is the earliest asynchronous message in the queue.</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">            for (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">                if (p == null || when &lt; p.when) &#123;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg.next = p; // invariant: p == prev.next</div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We can assume mPtr != 0 because mQuitting is false.</div><div class=\"line\">        if (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div><div class=\"line\">```   </div><div class=\"line\">## next方法（next方法是一个无限循环的方法，如果没有消息就会阻塞）：</div><div class=\"line\">```java</div><div class=\"line\">Message next() &#123;</div><div class=\"line\">    // Return here if the message loop has already quit and been disposed.</div><div class=\"line\">    // This can happen if the application tries to restart a looper after quit</div><div class=\"line\">    // which is not supported.</div><div class=\"line\">    final long ptr = mPtr;</div><div class=\"line\">    if (ptr == 0) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</div><div class=\"line\">    int nextPollTimeoutMillis = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        if (nextPollTimeoutMillis != 0) &#123;</div><div class=\"line\">            Binder.flushPendingCommands();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class=\"line\"></div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            // Try to retrieve the next message.  Return if found.</div><div class=\"line\">            final long now = SystemClock.uptimeMillis();</div><div class=\"line\">            Message prevMsg = null;</div><div class=\"line\">            Message msg = mMessages;</div><div class=\"line\">            if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class=\"line\">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class=\"line\">                do &#123;</div><div class=\"line\">                    prevMsg = msg;</div><div class=\"line\">                    msg = msg.next;</div><div class=\"line\">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (msg != null) &#123;</div><div class=\"line\">                if (now &lt; msg.when) &#123;</div><div class=\"line\">                    // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class=\"line\">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Got a message.</div><div class=\"line\">                    mBlocked = false;</div><div class=\"line\">                    if (prevMsg != null) &#123;</div><div class=\"line\">                        prevMsg.next = msg.next;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        mMessages = msg.next;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    msg.next = null;</div><div class=\"line\">                    if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg);</div><div class=\"line\">                    return msg;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // No more messages.</div><div class=\"line\">                nextPollTimeoutMillis = -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Process the quit message now that all pending messages have been handled.</div><div class=\"line\">            if (mQuitting) &#123;</div><div class=\"line\">                dispose();</div><div class=\"line\">                return null;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // If first time idle, then get the number of idlers to run.</div><div class=\"line\">            // Idle handles only run if the queue is empty or if the first message</div><div class=\"line\">            // in the queue (possibly a barrier) is due to be handled in the future.</div><div class=\"line\">            if (pendingIdleHandlerCount &lt; 0</div><div class=\"line\">                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</div><div class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (pendingIdleHandlerCount &lt;= 0) &#123;</div><div class=\"line\">                // No idle handlers to run.  Loop and wait some more.</div><div class=\"line\">                mBlocked = true;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (mPendingIdleHandlers == null) &#123;</div><div class=\"line\">                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</div><div class=\"line\">            &#125;</div><div class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Run the idle handlers.</div><div class=\"line\">        // We only ever reach this code block during the first iteration.</div><div class=\"line\">        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class=\"line\">            final IdleHandler idler = mPendingIdleHandlers[i];</div><div class=\"line\">            mPendingIdleHandlers[i] = null; // release the reference to the handler</div><div class=\"line\"></div><div class=\"line\">            boolean keep = false;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                keep = idler.queueIdle();</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!keep) &#123;</div><div class=\"line\">                synchronized (this) &#123;</div><div class=\"line\">                    mIdleHandlers.remove(idler);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Reset the idle handler count to 0 so we do not run them again.</div><div class=\"line\">        pendingIdleHandlerCount = 0;</div><div class=\"line\"></div><div class=\"line\">        // While calling an idle handler, a new message could have been delivered</div><div class=\"line\">        // so go back and look again for a pending message without waiting.</div><div class=\"line\">        nextPollTimeoutMillis = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com</p>\n","excerpt":"<p>消息队列在Android中指的是MessageQueue,MessageQueue主要包含两个操作：插入和独处。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next。其中enqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。消息队列内部是通过一个单链表的数据结构来维护消息列表，因为链表在插入和删除上比较有优势。","more":"</p>\n<h2 id=\"enqueueMessage方法（实际上就是单链表的插入操作）：\"><a href=\"#enqueueMessage方法（实际上就是单链表的插入操作）：\" class=\"headerlink\" title=\"enqueueMessage方法（实际上就是单链表的插入操作）：\"></a>enqueueMessage方法（实际上就是单链表的插入操作）：</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean enqueueMessage(Message msg, long when) &#123;</div><div class=\"line\">    if (msg.target == null) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(\"Message must have a target.\");</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg.isInUse()) &#123;</div><div class=\"line\">        throw new IllegalStateException(msg + \" This message is already in use.\");</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        if (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = new IllegalStateException(</div><div class=\"line\">                    msg.target + \" sending message to a Handler on a dead thread\");</div><div class=\"line\">            Log.w(\"MessageQueue\", e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        boolean needWake;</div><div class=\"line\">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class=\"line\">            // New head, wake up the event queue if blocked.</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Inserted within the middle of the queue.  Usually we don't have to wake</div><div class=\"line\">            // up the event queue unless there is a barrier at the head of the queue</div><div class=\"line\">            // and the message is the earliest asynchronous message in the queue.</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">            for (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">                if (p == null || when &lt; p.when) &#123;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg.next = p; // invariant: p == prev.next</div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We can assume mPtr != 0 because mQuitting is false.</div><div class=\"line\">        if (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div><div class=\"line\">```   </div><div class=\"line\">## next方法（next方法是一个无限循环的方法，如果没有消息就会阻塞）：</div><div class=\"line\">```java</div><div class=\"line\">Message next() &#123;</div><div class=\"line\">    // Return here if the message loop has already quit and been disposed.</div><div class=\"line\">    // This can happen if the application tries to restart a looper after quit</div><div class=\"line\">    // which is not supported.</div><div class=\"line\">    final long ptr = mPtr;</div><div class=\"line\">    if (ptr == 0) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</div><div class=\"line\">    int nextPollTimeoutMillis = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        if (nextPollTimeoutMillis != 0) &#123;</div><div class=\"line\">            Binder.flushPendingCommands();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class=\"line\"></div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            // Try to retrieve the next message.  Return if found.</div><div class=\"line\">            final long now = SystemClock.uptimeMillis();</div><div class=\"line\">            Message prevMsg = null;</div><div class=\"line\">            Message msg = mMessages;</div><div class=\"line\">            if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class=\"line\">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class=\"line\">                do &#123;</div><div class=\"line\">                    prevMsg = msg;</div><div class=\"line\">                    msg = msg.next;</div><div class=\"line\">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (msg != null) &#123;</div><div class=\"line\">                if (now &lt; msg.when) &#123;</div><div class=\"line\">                    // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class=\"line\">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Got a message.</div><div class=\"line\">                    mBlocked = false;</div><div class=\"line\">                    if (prevMsg != null) &#123;</div><div class=\"line\">                        prevMsg.next = msg.next;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        mMessages = msg.next;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    msg.next = null;</div><div class=\"line\">                    if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg);</div><div class=\"line\">                    return msg;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // No more messages.</div><div class=\"line\">                nextPollTimeoutMillis = -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Process the quit message now that all pending messages have been handled.</div><div class=\"line\">            if (mQuitting) &#123;</div><div class=\"line\">                dispose();</div><div class=\"line\">                return null;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // If first time idle, then get the number of idlers to run.</div><div class=\"line\">            // Idle handles only run if the queue is empty or if the first message</div><div class=\"line\">            // in the queue (possibly a barrier) is due to be handled in the future.</div><div class=\"line\">            if (pendingIdleHandlerCount &lt; 0</div><div class=\"line\">                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</div><div class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (pendingIdleHandlerCount &lt;= 0) &#123;</div><div class=\"line\">                // No idle handlers to run.  Loop and wait some more.</div><div class=\"line\">                mBlocked = true;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (mPendingIdleHandlers == null) &#123;</div><div class=\"line\">                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</div><div class=\"line\">            &#125;</div><div class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Run the idle handlers.</div><div class=\"line\">        // We only ever reach this code block during the first iteration.</div><div class=\"line\">        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class=\"line\">            final IdleHandler idler = mPendingIdleHandlers[i];</div><div class=\"line\">            mPendingIdleHandlers[i] = null; // release the reference to the handler</div><div class=\"line\"></div><div class=\"line\">            boolean keep = false;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                keep = idler.queueIdle();</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (!keep) &#123;</div><div class=\"line\">                synchronized (this) &#123;</div><div class=\"line\">                    mIdleHandlers.remove(idler);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Reset the idle handler count to 0 so we do not run them again.</div><div class=\"line\">        pendingIdleHandlerCount = 0;</div><div class=\"line\"></div><div class=\"line\">        // While calling an idle handler, a new message could have been delivered</div><div class=\"line\">        // so go back and look again for a pending message without waiting.</div><div class=\"line\">        nextPollTimeoutMillis = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com</p>"},{"title":"Android消息机制——总结","date":"2016-03-25T14:20:27.000Z","_content":"Android消息处理机制主要就是消息的传递机制，通过创建消息队列，把消息放入消息队列中，通过Looper获取消息，并通过handler处理消息的过程。\n整个过程最重要的就是Looper的工作机制，Looper内部通过调用MessageQueue的next方法来获取消息，得到消息后便通过Handler的dispatchMessage方法\n处理消息，dispatchMessage方法内部判断消息是否为空，如果消息不为空，回调方法handleMessage不为空，就会把消息传递到回调方法中，然后用户再来处理这个消息。\n整个过程MessageQueue起到存储的作用，Looper就是一个操作者，而handler就是一个用户与数据的中间件。\n   \n      \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢\n邮箱：yee.xin.work@gmail.com","source":"_posts/Android消息机制——总结.md","raw":"---\ntitle: Android消息机制——总结\ndate: 2016-3-25 22:20:27\ntags: Android\n---\nAndroid消息处理机制主要就是消息的传递机制，通过创建消息队列，把消息放入消息队列中，通过Looper获取消息，并通过handler处理消息的过程。\n整个过程最重要的就是Looper的工作机制，Looper内部通过调用MessageQueue的next方法来获取消息，得到消息后便通过Handler的dispatchMessage方法\n处理消息，dispatchMessage方法内部判断消息是否为空，如果消息不为空，回调方法handleMessage不为空，就会把消息传递到回调方法中，然后用户再来处理这个消息。\n整个过程MessageQueue起到存储的作用，Looper就是一个操作者，而handler就是一个用户与数据的中间件。\n   \n      \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢\n邮箱：yee.xin.work@gmail.com","slug":"Android消息机制——总结","published":1,"updated":"2016-11-29T02:29:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcy3000f4jp5xdkh19xj","content":"<p>Android消息处理机制主要就是消息的传递机制，通过创建消息队列，把消息放入消息队列中，通过Looper获取消息，并通过handler处理消息的过程。<br>整个过程最重要的就是Looper的工作机制，Looper内部通过调用MessageQueue的next方法来获取消息，得到消息后便通过Handler的dispatchMessage方法<br>处理消息，dispatchMessage方法内部判断消息是否为空，如果消息不为空，回调方法handleMessage不为空，就会把消息传递到回调方法中，然后用户再来处理这个消息。<br>整个过程MessageQueue起到存储的作用，Looper就是一个操作者，而handler就是一个用户与数据的中间件。</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com</p>\n","excerpt":"","more":"<p>Android消息处理机制主要就是消息的传递机制，通过创建消息队列，把消息放入消息队列中，通过Looper获取消息，并通过handler处理消息的过程。<br>整个过程最重要的就是Looper的工作机制，Looper内部通过调用MessageQueue的next方法来获取消息，得到消息后便通过Handler的dispatchMessage方法<br>处理消息，dispatchMessage方法内部判断消息是否为空，如果消息不为空，回调方法handleMessage不为空，就会把消息传递到回调方法中，然后用户再来处理这个消息。<br>整个过程MessageQueue起到存储的作用，Looper就是一个操作者，而handler就是一个用户与数据的中间件。</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com</p>\n"},{"title":"Android的线程和线程池——AsyncTask","date":"2016-04-10T13:12:02.000Z","_content":" 线程在Android中是一个很重要的概念，从用途上来说线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程往往用于执行耗时操作。在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制地生产，并且线程的创建和销毁都会有相应的开销。   \n     AsyncTask 是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程中更新UI。但是AsyncTask并不适合进行特别好使的后台任务，对于特别好使的任务开说，建议使用线程池。<!--more-->   \n     AsyncTask提供4个核心方法：   \n1.onPreExecute(),在主线程中执行，在异步任务执行前，此方法会被调用。   \n2.doInBackground(Params... params),此方法用于执行异步任务。在此方法中可以通过    \npublishProgress方法来更新任务进度，publishProgress方法会调用    onProgressUpdate方法。此外需要把结果返回给onPostExecute方法。\n3.onProgressUpdate（Progress...values）   \n4.onPostExcute(Result result),在主线程中执行。\n\nAsyncTask再具体的使用过程中也有一些条件限制的，主要有如下几点：   \n1.必须在主线程中加载。   \n2.必须在主线程中创建。   \n3.execute方法必须在UI线程调用。   \n4.不要在程序中调用4个方法。   \n5.一个AsyncTask对象只能执行一次。   \n  \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢\n邮箱：yee.xin.work@gmail.com  ","source":"_posts/Android的线程和线程池——AsyncTask.md","raw":"---\ntitle: Android的线程和线程池——AsyncTask\ndate: 2016-4-10 21:12:02\ntags: Android \n---\n 线程在Android中是一个很重要的概念，从用途上来说线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程往往用于执行耗时操作。在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制地生产，并且线程的创建和销毁都会有相应的开销。   \n     AsyncTask 是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程中更新UI。但是AsyncTask并不适合进行特别好使的后台任务，对于特别好使的任务开说，建议使用线程池。<!--more-->   \n     AsyncTask提供4个核心方法：   \n1.onPreExecute(),在主线程中执行，在异步任务执行前，此方法会被调用。   \n2.doInBackground(Params... params),此方法用于执行异步任务。在此方法中可以通过    \npublishProgress方法来更新任务进度，publishProgress方法会调用    onProgressUpdate方法。此外需要把结果返回给onPostExecute方法。\n3.onProgressUpdate（Progress...values）   \n4.onPostExcute(Result result),在主线程中执行。\n\nAsyncTask再具体的使用过程中也有一些条件限制的，主要有如下几点：   \n1.必须在主线程中加载。   \n2.必须在主线程中创建。   \n3.execute方法必须在UI线程调用。   \n4.不要在程序中调用4个方法。   \n5.一个AsyncTask对象只能执行一次。   \n  \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢\n邮箱：yee.xin.work@gmail.com  ","slug":"Android的线程和线程池——AsyncTask","published":1,"updated":"2016-11-29T02:29:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcy5000h4jp58ojd48c6","content":"<p> 线程在Android中是一个很重要的概念，从用途上来说线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程往往用于执行耗时操作。在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制地生产，并且线程的创建和销毁都会有相应的开销。<br>     AsyncTask 是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程中更新UI。但是AsyncTask并不适合进行特别好使的后台任务，对于特别好使的任务开说，建议使用线程池。<a id=\"more\"></a><br>     AsyncTask提供4个核心方法：<br>1.onPreExecute(),在主线程中执行，在异步任务执行前，此方法会被调用。<br>2.doInBackground(Params… params),此方法用于执行异步任务。在此方法中可以通过<br>publishProgress方法来更新任务进度，publishProgress方法会调用    onProgressUpdate方法。此外需要把结果返回给onPostExecute方法。<br>3.onProgressUpdate（Progress…values）<br>4.onPostExcute(Result result),在主线程中执行。</p>\n<p>AsyncTask再具体的使用过程中也有一些条件限制的，主要有如下几点：<br>1.必须在主线程中加载。<br>2.必须在主线程中创建。<br>3.execute方法必须在UI线程调用。<br>4.不要在程序中调用4个方法。<br>5.一个AsyncTask对象只能执行一次。   </p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"<p> 线程在Android中是一个很重要的概念，从用途上来说线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程往往用于执行耗时操作。在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制地生产，并且线程的创建和销毁都会有相应的开销。<br>     AsyncTask 是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程中更新UI。但是AsyncTask并不适合进行特别好使的后台任务，对于特别好使的任务开说，建议使用线程池。","more":"<br>     AsyncTask提供4个核心方法：<br>1.onPreExecute(),在主线程中执行，在异步任务执行前，此方法会被调用。<br>2.doInBackground(Params… params),此方法用于执行异步任务。在此方法中可以通过<br>publishProgress方法来更新任务进度，publishProgress方法会调用    onProgressUpdate方法。此外需要把结果返回给onPostExecute方法。<br>3.onProgressUpdate（Progress…values）<br>4.onPostExcute(Result result),在主线程中执行。</p>\n<p>AsyncTask再具体的使用过程中也有一些条件限制的，主要有如下几点：<br>1.必须在主线程中加载。<br>2.必须在主线程中创建。<br>3.execute方法必须在UI线程调用。<br>4.不要在程序中调用4个方法。<br>5.一个AsyncTask对象只能执行一次。   </p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>"},{"title":"Builder模式","date":"2016-06-29T06:16:34.000Z","_content":"\n Builder模式就是不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象。然后再builder对象上调用类似setter的方法，来设置每个相关的可选参数。   \n最后，客户端调用无参数的build方法来生成不可变的对象。<!--more-->\n\n例子： \n\n```java\npackage com.cn.test;\n\npublic class A {\n\n        private int a;\n        private int b;\n        private String c ;\n        private String d ;\n\n        public static class Builder {\n\n               private int a ;\n               private int b ;\n               private String c ;\n               private String d ;\n\n               public Builder(int a, int b) {\n                      this.a = a;\n                      this.b = b;\n              }\n\n               public Builder setC(String c) {\n                      this.c = c;\n                      return this ;\n              }\n\n               public Builder setD(String d) {\n                      this.d = d;\n                      return this ;\n              }\n\n               public A build() {\n                      return new A(this);//很关键 只有调用this的构造函数才能赋值\n              }\n       }\n\n        public A() {\n       }\n\n        private A(Builder builder) {\n               a = builder. a;\n               b = builder. b;\n               c = builder. c;\n               d = builder. d;\n       }\n}\n```\n\n调用：\nA a = new A.Builder(1, 2).setC( \"c\").setD(\"d\" ).build();\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  ","source":"_posts/Builder模式.md","raw":"---\ntitle: Builder模式\ndate: 2016-6-29 14:16:34\ntags: 设计模式\n---\n\n Builder模式就是不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象。然后再builder对象上调用类似setter的方法，来设置每个相关的可选参数。   \n最后，客户端调用无参数的build方法来生成不可变的对象。<!--more-->\n\n例子： \n\n```java\npackage com.cn.test;\n\npublic class A {\n\n        private int a;\n        private int b;\n        private String c ;\n        private String d ;\n\n        public static class Builder {\n\n               private int a ;\n               private int b ;\n               private String c ;\n               private String d ;\n\n               public Builder(int a, int b) {\n                      this.a = a;\n                      this.b = b;\n              }\n\n               public Builder setC(String c) {\n                      this.c = c;\n                      return this ;\n              }\n\n               public Builder setD(String d) {\n                      this.d = d;\n                      return this ;\n              }\n\n               public A build() {\n                      return new A(this);//很关键 只有调用this的构造函数才能赋值\n              }\n       }\n\n        public A() {\n       }\n\n        private A(Builder builder) {\n               a = builder. a;\n               b = builder. b;\n               c = builder. c;\n               d = builder. d;\n       }\n}\n```\n\n调用：\nA a = new A.Builder(1, 2).setC( \"c\").setD(\"d\" ).build();\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  ","slug":"Builder模式","published":1,"updated":"2016-11-29T06:19:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcy6000j4jp5k4xi648t","content":"<p> Builder模式就是不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象。然后再builder对象上调用类似setter的方法，来设置每个相关的可选参数。<br>最后，客户端调用无参数的build方法来生成不可变的对象。<a id=\"more\"></a></p>\n<p>例子： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.cn.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b;</div><div class=\"line\">        <span class=\"keyword\">private</span> String c ;</div><div class=\"line\">        <span class=\"keyword\">private</span> String d ;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a ;</div><div class=\"line\">               <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b ;</div><div class=\"line\">               <span class=\"keyword\">private</span> String c ;</div><div class=\"line\">               <span class=\"keyword\">private</span> String d ;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">                      <span class=\"keyword\">this</span>.a = a;</div><div class=\"line\">                      <span class=\"keyword\">this</span>.b = b;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setC</span><span class=\"params\">(String c)</span> </span>&#123;</div><div class=\"line\">                      <span class=\"keyword\">this</span>.c = c;</div><div class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> ;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setD</span><span class=\"params\">(String d)</span> </span>&#123;</div><div class=\"line\">                      <span class=\"keyword\">this</span>.d = d;</div><div class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> ;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"function\"><span class=\"keyword\">public</span> A <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A(<span class=\"keyword\">this</span>);<span class=\"comment\">//很关键 只有调用this的构造函数才能赋值</span></div><div class=\"line\">              &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">A</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">               a = builder. a;</div><div class=\"line\">               b = builder. b;</div><div class=\"line\">               c = builder. c;</div><div class=\"line\">               d = builder. d;</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用：<br>A a = new A.Builder(1, 2).setC( “c”).setD(“d” ).build();</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"<p> Builder模式就是不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象。然后再builder对象上调用类似setter的方法，来设置每个相关的可选参数。<br>最后，客户端调用无参数的build方法来生成不可变的对象。","more":"</p>\n<p>例子： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.cn.test;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b;</div><div class=\"line\">        <span class=\"keyword\">private</span> String c ;</div><div class=\"line\">        <span class=\"keyword\">private</span> String d ;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a ;</div><div class=\"line\">               <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b ;</div><div class=\"line\">               <span class=\"keyword\">private</span> String c ;</div><div class=\"line\">               <span class=\"keyword\">private</span> String d ;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</div><div class=\"line\">                      <span class=\"keyword\">this</span>.a = a;</div><div class=\"line\">                      <span class=\"keyword\">this</span>.b = b;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setC</span><span class=\"params\">(String c)</span> </span>&#123;</div><div class=\"line\">                      <span class=\"keyword\">this</span>.c = c;</div><div class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> ;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setD</span><span class=\"params\">(String d)</span> </span>&#123;</div><div class=\"line\">                      <span class=\"keyword\">this</span>.d = d;</div><div class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> ;</div><div class=\"line\">              &#125;</div><div class=\"line\"></div><div class=\"line\">               <span class=\"function\"><span class=\"keyword\">public</span> A <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A(<span class=\"keyword\">this</span>);<span class=\"comment\">//很关键 只有调用this的构造函数才能赋值</span></div><div class=\"line\">              &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">A</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">               a = builder. a;</div><div class=\"line\">               b = builder. b;</div><div class=\"line\">               c = builder. c;</div><div class=\"line\">               d = builder. d;</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用：<br>A a = new A.Builder(1, 2).setC( “c”).setD(“d” ).build();</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>"},{"title":"JAVA反射","date":"2016-09-22T06:21:55.000Z","_content":"类是Java.lang.Class类的实例对象   \n编译时刻加载类，静态加载类，运行时刻加载类是动态加载类。   \nClass,forName(\"类的全称\")   \n不仅表示了类的类类型，还代表了动态加载类。<!--more-->   \n\n类类型：   \nA a = new a();   \na是A的实例对象，   \nClass　c1 = a.class;   \nc1是Class的实例对象，   \na.class又代表的是A这个类   \n所以c1又等价于a.class   \n所以c1就等价于A这个类   \n得到结论就是A这个类是Class的实例对象，   \n所以得到万事万物都是对象，都是Class这个类的对象。   \n\n\nJAVA的反射机制，其实就是通过一个类的.class对象或者全路径获取关于这个类的一些信息。\n获取信息的同时还能做一些操作。   \n通过反射 我们可以生成该类的对象实例并且也可以知道该类有哪些public的方法。   \n知道这些方法过后我们就可以使用。   \n例子：  \n \n```java\npackage com.cn.yee;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\npublic class Study {\n       public static void main(String[] args) throws IllegalAccessException,\n                     IllegalArgumentException, InvocationTargetException,\n                     InstantiationException {\n              Class cla = StudyPerson.class;\n              Object o = cla.newInstance();\n              Method[] method = cla.getMethods();\n              for (Method method2 : method) {\n                     System.out.println(method2.getName());\n                     if (method2.getName().equals(\"getStudy\")) {\n                           method2.invoke(o);\n                     }\n              }\n       }\n}\nclass StudyPerson {\n       public StudyPerson() {\n              // TODO Auto-generated constructor stub\n       }\n       public void getStudy() {\n              System.out.println(\"getStudy~~~~~~~~~~~\");\n       }\n       protected void getStudyProtected() {\n       }\n       private void getStudyPrivate() {\n       }\n}\n```\n\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n","source":"_posts/JAVA反射.md","raw":"---\ntitle: JAVA反射\ndate: 2016-09-22 14:21:55\ntags: JAVA\n---\n类是Java.lang.Class类的实例对象   \n编译时刻加载类，静态加载类，运行时刻加载类是动态加载类。   \nClass,forName(\"类的全称\")   \n不仅表示了类的类类型，还代表了动态加载类。<!--more-->   \n\n类类型：   \nA a = new a();   \na是A的实例对象，   \nClass　c1 = a.class;   \nc1是Class的实例对象，   \na.class又代表的是A这个类   \n所以c1又等价于a.class   \n所以c1就等价于A这个类   \n得到结论就是A这个类是Class的实例对象，   \n所以得到万事万物都是对象，都是Class这个类的对象。   \n\n\nJAVA的反射机制，其实就是通过一个类的.class对象或者全路径获取关于这个类的一些信息。\n获取信息的同时还能做一些操作。   \n通过反射 我们可以生成该类的对象实例并且也可以知道该类有哪些public的方法。   \n知道这些方法过后我们就可以使用。   \n例子：  \n \n```java\npackage com.cn.yee;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\npublic class Study {\n       public static void main(String[] args) throws IllegalAccessException,\n                     IllegalArgumentException, InvocationTargetException,\n                     InstantiationException {\n              Class cla = StudyPerson.class;\n              Object o = cla.newInstance();\n              Method[] method = cla.getMethods();\n              for (Method method2 : method) {\n                     System.out.println(method2.getName());\n                     if (method2.getName().equals(\"getStudy\")) {\n                           method2.invoke(o);\n                     }\n              }\n       }\n}\nclass StudyPerson {\n       public StudyPerson() {\n              // TODO Auto-generated constructor stub\n       }\n       public void getStudy() {\n              System.out.println(\"getStudy~~~~~~~~~~~\");\n       }\n       protected void getStudyProtected() {\n       }\n       private void getStudyPrivate() {\n       }\n}\n```\n\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n","slug":"JAVA反射","published":1,"updated":"2016-11-29T06:23:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcya000l4jp5nste5svm","content":"<p>类是Java.lang.Class类的实例对象<br>编译时刻加载类，静态加载类，运行时刻加载类是动态加载类。<br>Class,forName(“类的全称”)<br>不仅表示了类的类类型，还代表了动态加载类。<a id=\"more\"></a>   </p>\n<p>类类型：<br>A a = new a();<br>a是A的实例对象，<br>Class　c1 = a.class;<br>c1是Class的实例对象，<br>a.class又代表的是A这个类<br>所以c1又等价于a.class<br>所以c1就等价于A这个类<br>得到结论就是A这个类是Class的实例对象，<br>所以得到万事万物都是对象，都是Class这个类的对象。   </p>\n<p>JAVA的反射机制，其实就是通过一个类的.class对象或者全路径获取关于这个类的一些信息。<br>获取信息的同时还能做一些操作。<br>通过反射 我们可以生成该类的对象实例并且也可以知道该类有哪些public的方法。<br>知道这些方法过后我们就可以使用。<br>例子：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.cn.yee;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationTargetException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Study</span> </span>&#123;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IllegalAccessException,</span></div><div class=\"line\">                     IllegalArgumentException, InvocationTargetException,</div><div class=\"line\">                     InstantiationException &#123;</div><div class=\"line\">              Class cla = StudyPerson.class;</div><div class=\"line\">              Object o = cla.newInstance();</div><div class=\"line\">              Method[] method = cla.getMethods();</div><div class=\"line\">              <span class=\"keyword\">for</span> (Method method2 : method) &#123;</div><div class=\"line\">                     System.out.println(method2.getName());</div><div class=\"line\">                     <span class=\"keyword\">if</span> (method2.getName().equals(<span class=\"string\">\"getStudy\"</span>)) &#123;</div><div class=\"line\">                           method2.invoke(o);</div><div class=\"line\">                     &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudyPerson</span> </span>&#123;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">StudyPerson</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getStudy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">              System.out.println(<span class=\"string\">\"getStudy~~~~~~~~~~~\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">getStudyProtected</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">getStudyPrivate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"<p>类是Java.lang.Class类的实例对象<br>编译时刻加载类，静态加载类，运行时刻加载类是动态加载类。<br>Class,forName(“类的全称”)<br>不仅表示了类的类类型，还代表了动态加载类。","more":"</p>\n<p>类类型：<br>A a = new a();<br>a是A的实例对象，<br>Class　c1 = a.class;<br>c1是Class的实例对象，<br>a.class又代表的是A这个类<br>所以c1又等价于a.class<br>所以c1就等价于A这个类<br>得到结论就是A这个类是Class的实例对象，<br>所以得到万事万物都是对象，都是Class这个类的对象。   </p>\n<p>JAVA的反射机制，其实就是通过一个类的.class对象或者全路径获取关于这个类的一些信息。<br>获取信息的同时还能做一些操作。<br>通过反射 我们可以生成该类的对象实例并且也可以知道该类有哪些public的方法。<br>知道这些方法过后我们就可以使用。<br>例子：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.cn.yee;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationTargetException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Study</span> </span>&#123;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IllegalAccessException,</div><div class=\"line\">                     IllegalArgumentException, InvocationTargetException,</div><div class=\"line\">                     InstantiationException </span>&#123;</div><div class=\"line\">              Class cla = StudyPerson.class;</div><div class=\"line\">              Object o = cla.newInstance();</div><div class=\"line\">              Method[] method = cla.getMethods();</div><div class=\"line\">              <span class=\"keyword\">for</span> (Method method2 : method) &#123;</div><div class=\"line\">                     System.out.println(method2.getName());</div><div class=\"line\">                     <span class=\"keyword\">if</span> (method2.getName().equals(<span class=\"string\">\"getStudy\"</span>)) &#123;</div><div class=\"line\">                           method2.invoke(o);</div><div class=\"line\">                     &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudyPerson</span> </span>&#123;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">StudyPerson</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">// TODO Auto-generated constructor stub</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getStudy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">              System.out.println(<span class=\"string\">\"getStudy~~~~~~~~~~~\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">getStudyProtected</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">getStudyPrivate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>"},{"title":"Java 7之基础 - 强引用、弱引用、软引用、虚引用(转载)","date":"2016-09-15T03:49:22.000Z","_content":"\n1、强引用（StrongReference）\n   \n      强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：\n\n```java\nObject o=new Object();   //  强引用  \n```\n当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：   \n\n```java\n o=null;     // 帮助垃圾收集器回收此对象  \n```\n显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。<!--more-->   \n举例：  \n \n```java\n public void test(){     \n     Object o=new Object();  \n    // 省略其他操作  \n     } \n```\n \n在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。   \n但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。   \n强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：   \n\n```java\n private transient Object[] elementData;  \n public void clear() {  \n         modCount++;  \n         // Let gc do its work  \n         for (int i = 0; i < size; i++)  \n             elementData[i] = null;  \n         size = 0;  \n }  \n```\n\n在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。\n\n2、软引用（SoftReference)   \n如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。     \n\n```java\nString str=new String(\"abc\");                                     // 强引用  \nSoftReference<String> softRef=new SoftReference<String>(str);     // 软引用    \n      当内存不足时，等价于：\nIf(JVM.内存不足()) {  \n   str = null;  // 转换为软引用  \n   System.gc(); // 垃圾回收器进行回收  \n}  \n```\n\n虚引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。   \n（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建   \n（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出\n这时候就可以使用软引用   \n\n```java\n Browser prev = new Browser();               // 获取页面进行浏览  \n SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用         \n if(sr.get()!=null){   \n     rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取  \n }else{  \n     prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了  \n     sr = new SoftReference(prev);       // 重新构建  \n }  \n```\n\n这样就很好的解决了实际的问题。   \n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n\n\n3、弱引用（WeakReference）   \n弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n\n```java\nString str=new String(\"abc\");      \nWeakReference<String> abcWeakRef = new WeakReference<String>(str);  \nstr=null;    \n```\n\n当垃圾回收器进行扫描回收时等价于：\n\n```java\nstr = null;  \nSystem.gc();  \n```   \n\n   如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。      \n   下面的代码会让str再次变为一个强引用：\n```java\nString  abc = abcWeakRef.get();  \n```\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。   \n当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。\n\n这个引用不会在对象的垃圾回收判断中产生任何附加的影响。   \n\n```java\n public class ReferenceTest {  \n   \n     private static ReferenceQueue<VeryBig> rq = new ReferenceQueue<VeryBig>();  \n   \n     public static void checkQueue() {  \n         Reference<? extends VeryBig> ref = null;  \n         while ((ref = rq.poll()) != null) {  \n             if (ref != null) {  \n                 System.out.println(\"In queue: \" + ((VeryBigWeakReference) (ref)).id);  \n             }  \n         }  \n     }  \n   \n     public static void main(String args[]) {  \n         int size = 3;  \n         LinkedList<WeakReference<VeryBig>> weakList = new LinkedList<WeakReference<VeryBig>>();  \n         for (int i = 0; i < size; i++) {  \n             weakList.add(new VeryBigWeakReference(new VeryBig(\"Weak \" + i), rq));  \n             System.out.println(\"Just created weak: \" + weakList.getLast());  \n   \n         }  \n   \n         System.gc();   \n         try { // 下面休息几分钟，让上面的垃圾回收线程运行完成  \n             Thread.currentThread().sleep(6000);  \n         } catch (InterruptedException e) {  \n             e.printStackTrace();  \n         }  \n         checkQueue();  \n     }  \n }  \n   \n class VeryBig {  \n     public String id;  \n     // 占用空间,让线程进行回收  \n     byte[] b = new byte[2 * 1024];  \n   \n     public VeryBig(String id) {  \n         this.id = id;  \n     }  \n   \n     protected void finalize() {  \n         System.out.println(\"Finalizing VeryBig \" + id);  \n     }  \n }  \n   \n class VeryBigWeakReference extends WeakReference<VeryBig> {  \n     public String id;  \n   \n     public VeryBigWeakReference(VeryBig big, ReferenceQueue<VeryBig> rq) {  \n         super(big, rq);  \n         this.id = big.id;  \n     }  \n   \n     protected void finalize() {  \n         System.out.println(\"Finalizing VeryBigWeakReference \" + id);  \n     }  \n } \n``` \n最后的输出结果为：\n1. Just created weak: com.javabase.reference.VeryBigWeakReference@1641c0  \n2. Just created weak: com.javabase.reference.VeryBigWeakReference@136ab79  \n3. Just created weak: com.javabase.reference.VeryBigWeakReference@33c1aa  \n4. Finalizing VeryBig Weak 2  \n5. Finalizing VeryBig Weak 1  \n6. Finalizing VeryBig Weak 0  \n7. In queue: Weak 1  \n8. In queue: Weak 2  \n9. In queue: Weak 0  \n\n\n\n4、虚引用（PhantomReference）\n     “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。\n\n\n\n5、总结\n Java4种引用的级别由高到低依次为：\n\n强引用  >  软引用  >  弱引用  >  虚引用\n\n通过图来看一下他们之间在垃圾回收时的区别：\n\n![tupian](http://img.blog.csdn.net/20140223152242562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF6aGltYXpo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：\n\n传送门：Java内存管理  http://blog.csdn.net/mazhimazh/article/category/1907599\n\n参考文献：\n\n1、http://www.cnblogs.com/skywang12345/p/3154474.html\n2、http://blog.csdn.net/lifetragedy?viewmode=contents\n\n  \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n\n\n\n","source":"_posts/Java-7之基础-强引用、弱引用、软引用、虚引用-转载.md","raw":"---\ntitle: Java 7之基础 - 强引用、弱引用、软引用、虚引用(转载)\ndate: 2016-9-15 11:49:22\ntags: JAVA\n---\n\n1、强引用（StrongReference）\n   \n      强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：\n\n```java\nObject o=new Object();   //  强引用  \n```\n当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：   \n\n```java\n o=null;     // 帮助垃圾收集器回收此对象  \n```\n显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。<!--more-->   \n举例：  \n \n```java\n public void test(){     \n     Object o=new Object();  \n    // 省略其他操作  \n     } \n```\n \n在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。   \n但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。   \n强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：   \n\n```java\n private transient Object[] elementData;  \n public void clear() {  \n         modCount++;  \n         // Let gc do its work  \n         for (int i = 0; i < size; i++)  \n             elementData[i] = null;  \n         size = 0;  \n }  \n```\n\n在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。\n\n2、软引用（SoftReference)   \n如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。     \n\n```java\nString str=new String(\"abc\");                                     // 强引用  \nSoftReference<String> softRef=new SoftReference<String>(str);     // 软引用    \n      当内存不足时，等价于：\nIf(JVM.内存不足()) {  \n   str = null;  // 转换为软引用  \n   System.gc(); // 垃圾回收器进行回收  \n}  \n```\n\n虚引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。   \n（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建   \n（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出\n这时候就可以使用软引用   \n\n```java\n Browser prev = new Browser();               // 获取页面进行浏览  \n SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用         \n if(sr.get()!=null){   \n     rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取  \n }else{  \n     prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了  \n     sr = new SoftReference(prev);       // 重新构建  \n }  \n```\n\n这样就很好的解决了实际的问题。   \n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n\n\n3、弱引用（WeakReference）   \n弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n\n```java\nString str=new String(\"abc\");      \nWeakReference<String> abcWeakRef = new WeakReference<String>(str);  \nstr=null;    \n```\n\n当垃圾回收器进行扫描回收时等价于：\n\n```java\nstr = null;  \nSystem.gc();  \n```   \n\n   如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。      \n   下面的代码会让str再次变为一个强引用：\n```java\nString  abc = abcWeakRef.get();  \n```\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。   \n当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。\n\n这个引用不会在对象的垃圾回收判断中产生任何附加的影响。   \n\n```java\n public class ReferenceTest {  \n   \n     private static ReferenceQueue<VeryBig> rq = new ReferenceQueue<VeryBig>();  \n   \n     public static void checkQueue() {  \n         Reference<? extends VeryBig> ref = null;  \n         while ((ref = rq.poll()) != null) {  \n             if (ref != null) {  \n                 System.out.println(\"In queue: \" + ((VeryBigWeakReference) (ref)).id);  \n             }  \n         }  \n     }  \n   \n     public static void main(String args[]) {  \n         int size = 3;  \n         LinkedList<WeakReference<VeryBig>> weakList = new LinkedList<WeakReference<VeryBig>>();  \n         for (int i = 0; i < size; i++) {  \n             weakList.add(new VeryBigWeakReference(new VeryBig(\"Weak \" + i), rq));  \n             System.out.println(\"Just created weak: \" + weakList.getLast());  \n   \n         }  \n   \n         System.gc();   \n         try { // 下面休息几分钟，让上面的垃圾回收线程运行完成  \n             Thread.currentThread().sleep(6000);  \n         } catch (InterruptedException e) {  \n             e.printStackTrace();  \n         }  \n         checkQueue();  \n     }  \n }  \n   \n class VeryBig {  \n     public String id;  \n     // 占用空间,让线程进行回收  \n     byte[] b = new byte[2 * 1024];  \n   \n     public VeryBig(String id) {  \n         this.id = id;  \n     }  \n   \n     protected void finalize() {  \n         System.out.println(\"Finalizing VeryBig \" + id);  \n     }  \n }  \n   \n class VeryBigWeakReference extends WeakReference<VeryBig> {  \n     public String id;  \n   \n     public VeryBigWeakReference(VeryBig big, ReferenceQueue<VeryBig> rq) {  \n         super(big, rq);  \n         this.id = big.id;  \n     }  \n   \n     protected void finalize() {  \n         System.out.println(\"Finalizing VeryBigWeakReference \" + id);  \n     }  \n } \n``` \n最后的输出结果为：\n1. Just created weak: com.javabase.reference.VeryBigWeakReference@1641c0  \n2. Just created weak: com.javabase.reference.VeryBigWeakReference@136ab79  \n3. Just created weak: com.javabase.reference.VeryBigWeakReference@33c1aa  \n4. Finalizing VeryBig Weak 2  \n5. Finalizing VeryBig Weak 1  \n6. Finalizing VeryBig Weak 0  \n7. In queue: Weak 1  \n8. In queue: Weak 2  \n9. In queue: Weak 0  \n\n\n\n4、虚引用（PhantomReference）\n     “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。\n\n\n\n5、总结\n Java4种引用的级别由高到低依次为：\n\n强引用  >  软引用  >  弱引用  >  虚引用\n\n通过图来看一下他们之间在垃圾回收时的区别：\n\n![tupian](http://img.blog.csdn.net/20140223152242562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF6aGltYXpo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：\n\n传送门：Java内存管理  http://blog.csdn.net/mazhimazh/article/category/1907599\n\n参考文献：\n\n1、http://www.cnblogs.com/skywang12345/p/3154474.html\n2、http://blog.csdn.net/lifetragedy?viewmode=contents\n\n  \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n\n\n\n","slug":"Java-7之基础-强引用、弱引用、软引用、虚引用-转载","published":1,"updated":"2016-11-29T04:11:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcyd000o4jp5i9k6qnkr","content":"<p>1、强引用（StrongReference）</p>\n<pre><code>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object o=<span class=\"keyword\">new</span> Object();   <span class=\"comment\">//  强引用</span></div></pre></td></tr></table></figure>\n<p>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">o=<span class=\"keyword\">null</span>;     <span class=\"comment\">// 帮助垃圾收集器回收此对象</span></div></pre></td></tr></table></figure>\n<p>显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。<a id=\"more\"></a><br>举例：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;     </div><div class=\"line\">    Object o=<span class=\"keyword\">new</span> Object();  </div><div class=\"line\">   <span class=\"comment\">// 省略其他操作  </span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。<br>但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。<br>强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object[] elementData;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        modCount++;  </div><div class=\"line\">        <span class=\"comment\">// Let gc do its work  </span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)  </div><div class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        size = <span class=\"number\">0</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。</p>\n<p>2、软引用（SoftReference)<br>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。     </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);                                     <span class=\"comment\">// 强引用  </span></div><div class=\"line\">SoftReference&lt;String&gt; softRef=<span class=\"keyword\">new</span> SoftReference&lt;String&gt;(str);     <span class=\"comment\">// 软引用    </span></div><div class=\"line\">      当内存不足时，等价于：</div><div class=\"line\">If(JVM.内存不足()) &#123;  </div><div class=\"line\">   str = <span class=\"keyword\">null</span>;  <span class=\"comment\">// 转换为软引用  </span></div><div class=\"line\">   System.gc(); <span class=\"comment\">// 垃圾回收器进行回收  </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虚引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。<br>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建<br>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出<br>这时候就可以使用软引用   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Browser prev = <span class=\"keyword\">new</span> Browser();               <span class=\"comment\">// 获取页面进行浏览  </span></div><div class=\"line\">SoftReference sr = <span class=\"keyword\">new</span> SoftReference(prev); <span class=\"comment\">// 浏览完毕后置为软引用         </span></div><div class=\"line\"><span class=\"keyword\">if</span>(sr.get()!=<span class=\"keyword\">null</span>)&#123;   </div><div class=\"line\">    rev = (Browser) sr.get();           <span class=\"comment\">// 还没有被回收器回收，直接获取  </span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">    prev = <span class=\"keyword\">new</span> Browser();               <span class=\"comment\">// 由于内存吃紧，所以对软引用的对象回收了  </span></div><div class=\"line\">    sr = <span class=\"keyword\">new</span> SoftReference(prev);       <span class=\"comment\">// 重新构建  </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就很好的解决了实际的问题。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>3、弱引用（WeakReference）<br>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);      </div><div class=\"line\">WeakReference&lt;String&gt; abcWeakRef = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(str);  </div><div class=\"line\">str=<span class=\"keyword\">null</span>;</div></pre></td></tr></table></figure>\n<p>当垃圾回收器进行扫描回收时等价于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">str = <span class=\"keyword\">null</span>;  </div><div class=\"line\">System.gc();  </div><div class=\"line\">```   </div><div class=\"line\"></div><div class=\"line\">   如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。      </div><div class=\"line\">   下面的代码会让str再次变为一个强引用：</div><div class=\"line\">```java</div><div class=\"line\">String  abc = abcWeakRef.get();</div></pre></td></tr></table></figure>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。</p>\n<p>这个引用不会在对象的垃圾回收判断中产生任何附加的影响。   </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceTest</span> </span>{  \n\n    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;VeryBig&gt; rq = <span class=\"keyword\">new</span> ReferenceQueue&lt;VeryBig&gt;();  \n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">checkQueue</span><span class=\"params\">()</span> </span>{  \n        Reference&lt;? extends VeryBig&gt; ref = <span class=\"keyword\">null</span>;  \n        <span class=\"keyword\">while</span> ((ref = rq.poll()) != <span class=\"keyword\">null</span>) {  \n            <span class=\"keyword\">if</span> (ref != <span class=\"keyword\">null</span>) {  \n                System.out.println(<span class=\"string\">\"In queue: \"</span> + ((VeryBigWeakReference) (ref)).id);  \n            }  \n        }  \n    }  \n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>{  \n        <span class=\"keyword\">int</span> size = <span class=\"number\">3</span>;  \n        LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = <span class=\"keyword\">new</span> LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;();  \n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) {  \n            weakList.add(<span class=\"keyword\">new</span> VeryBigWeakReference(<span class=\"keyword\">new</span> VeryBig(<span class=\"string\">\"Weak \"</span> + i), rq));  \n            System.out.println(<span class=\"string\">\"Just created weak: \"</span> + weakList.getLast());  \n\n        }  \n\n        System.gc();   \n        <span class=\"keyword\">try</span> { <span class=\"comment\">// 下面休息几分钟，让上面的垃圾回收线程运行完成  </span>\n            Thread.currentThread().sleep(<span class=\"number\">6000</span>);  \n        } <span class=\"keyword\">catch</span> (InterruptedException e) {  \n            e.printStackTrace();  \n        }  \n        checkQueue();  \n    }  \n}  \n\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VeryBig</span> </span>{  \n    <span class=\"keyword\">public</span> String id;  \n    <span class=\"comment\">// 占用空间,让线程进行回收  </span>\n    <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span> * <span class=\"number\">1024</span>];  \n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">VeryBig</span><span class=\"params\">(String id)</span> </span>{  \n        <span class=\"keyword\">this</span>.id = id;  \n    }  \n\n    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> </span>{  \n        System.out.println(<span class=\"string\">\"Finalizing VeryBig \"</span> + id);  \n    }  \n}  \n\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VeryBigWeakReference</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">VeryBig</span>&gt; </span>{  \n    <span class=\"keyword\">public</span> String id;  \n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">VeryBigWeakReference</span><span class=\"params\">(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq)</span> </span>{  \n        <span class=\"keyword\">super</span>(big, rq);  \n        <span class=\"keyword\">this</span>.id = big.id;  \n    }  \n\n    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> </span>{  \n        System.out.println(<span class=\"string\">\"Finalizing VeryBigWeakReference \"</span> + id);  \n    }  \n}\n</code></pre>\n<p>最后的输出结果为：</p>\n<ol>\n<li>Just created weak: com.javabase.reference.VeryBigWeakReference@1641c0  </li>\n<li>Just created weak: com.javabase.reference.VeryBigWeakReference@136ab79  </li>\n<li>Just created weak: com.javabase.reference.VeryBigWeakReference@33c1aa  </li>\n<li>Finalizing VeryBig Weak 2  </li>\n<li>Finalizing VeryBig Weak 1  </li>\n<li>Finalizing VeryBig Weak 0  </li>\n<li>In queue: Weak 1  </li>\n<li>In queue: Weak 2  </li>\n<li>In queue: Weak 0  </li>\n</ol>\n<p>4、虚引用（PhantomReference）<br>     “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p>\n<p>5、总结<br> Java4种引用的级别由高到低依次为：</p>\n<p>强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用</p>\n<p>通过图来看一下他们之间在垃圾回收时的区别：</p>\n<p><img src=\"http://img.blog.csdn.net/20140223152242562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF6aGltYXpo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"tupian\"></p>\n<p>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：</p>\n<p>传送门：Java内存管理  <a href=\"http://blog.csdn.net/mazhimazh/article/category/1907599\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/mazhimazh/article/category/1907599</a></p>\n<p>参考文献：</p>\n<p>1、<a href=\"http://www.cnblogs.com/skywang12345/p/3154474.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/skywang12345/p/3154474.html</a><br>2、<a href=\"http://blog.csdn.net/lifetragedy?viewmode=contents\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lifetragedy?viewmode=contents</a></p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"<p>1、强引用（StrongReference）</p>\n<pre><code>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object o=<span class=\"keyword\">new</span> Object();   <span class=\"comment\">//  强引用</span></div></pre></td></tr></table></figure>\n<p>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">o=<span class=\"keyword\">null</span>;     <span class=\"comment\">// 帮助垃圾收集器回收此对象</span></div></pre></td></tr></table></figure>\n<p>显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。","more":"<br>举例：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;     </div><div class=\"line\">    Object o=<span class=\"keyword\">new</span> Object();  </div><div class=\"line\">   <span class=\"comment\">// 省略其他操作  </span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。<br>但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。<br>强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object[] elementData;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        modCount++;  </div><div class=\"line\">        <span class=\"comment\">// Let gc do its work  </span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)  </div><div class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        size = <span class=\"number\">0</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。</p>\n<p>2、软引用（SoftReference)<br>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。     </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);                                     <span class=\"comment\">// 强引用  </span></div><div class=\"line\">SoftReference&lt;String&gt; softRef=<span class=\"keyword\">new</span> SoftReference&lt;String&gt;(str);     <span class=\"comment\">// 软引用    </span></div><div class=\"line\">      当内存不足时，等价于：</div><div class=\"line\">If(JVM.内存不足()) &#123;  </div><div class=\"line\">   str = <span class=\"keyword\">null</span>;  <span class=\"comment\">// 转换为软引用  </span></div><div class=\"line\">   System.gc(); <span class=\"comment\">// 垃圾回收器进行回收  </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虚引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。<br>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建<br>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出<br>这时候就可以使用软引用   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Browser prev = <span class=\"keyword\">new</span> Browser();               <span class=\"comment\">// 获取页面进行浏览  </span></div><div class=\"line\">SoftReference sr = <span class=\"keyword\">new</span> SoftReference(prev); <span class=\"comment\">// 浏览完毕后置为软引用         </span></div><div class=\"line\"><span class=\"keyword\">if</span>(sr.get()!=<span class=\"keyword\">null</span>)&#123;   </div><div class=\"line\">    rev = (Browser) sr.get();           <span class=\"comment\">// 还没有被回收器回收，直接获取  </span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">    prev = <span class=\"keyword\">new</span> Browser();               <span class=\"comment\">// 由于内存吃紧，所以对软引用的对象回收了  </span></div><div class=\"line\">    sr = <span class=\"keyword\">new</span> SoftReference(prev);       <span class=\"comment\">// 重新构建  </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就很好的解决了实际的问题。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>3、弱引用（WeakReference）<br>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">String str=<span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);      </div><div class=\"line\">WeakReference&lt;String&gt; abcWeakRef = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(str);  </div><div class=\"line\">str=<span class=\"keyword\">null</span>;</div></pre></td></tr></table></figure>\n<p>当垃圾回收器进行扫描回收时等价于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">str = <span class=\"keyword\">null</span>;  </div><div class=\"line\">System.gc();  </div><div class=\"line\">```   </div><div class=\"line\"></div><div class=\"line\">   如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。      </div><div class=\"line\">   下面的代码会让str再次变为一个强引用：</div><div class=\"line\">```java</div><div class=\"line\">String  abc = abcWeakRef.get();</div></pre></td></tr></table></figure>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。</p>\n<p>这个引用不会在对象的垃圾回收判断中产生任何附加的影响。   </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceTest</span> </span>{  \n\n    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;VeryBig&gt; rq = <span class=\"keyword\">new</span> ReferenceQueue&lt;VeryBig&gt;();  \n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">checkQueue</span><span class=\"params\">()</span> </span>{  \n        Reference&lt;? extends VeryBig&gt; ref = <span class=\"keyword\">null</span>;  \n        <span class=\"keyword\">while</span> ((ref = rq.poll()) != <span class=\"keyword\">null</span>) {  \n            <span class=\"keyword\">if</span> (ref != <span class=\"keyword\">null</span>) {  \n                System.out.println(<span class=\"string\">\"In queue: \"</span> + ((VeryBigWeakReference) (ref)).id);  \n            }  \n        }  \n    }  \n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>{  \n        <span class=\"keyword\">int</span> size = <span class=\"number\">3</span>;  \n        LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = <span class=\"keyword\">new</span> LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;();  \n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) {  \n            weakList.add(<span class=\"keyword\">new</span> VeryBigWeakReference(<span class=\"keyword\">new</span> VeryBig(<span class=\"string\">\"Weak \"</span> + i), rq));  \n            System.out.println(<span class=\"string\">\"Just created weak: \"</span> + weakList.getLast());  \n\n        }  \n\n        System.gc();   \n        <span class=\"keyword\">try</span> { <span class=\"comment\">// 下面休息几分钟，让上面的垃圾回收线程运行完成  </span>\n            Thread.currentThread().sleep(<span class=\"number\">6000</span>);  \n        } <span class=\"keyword\">catch</span> (InterruptedException e) {  \n            e.printStackTrace();  \n        }  \n        checkQueue();  \n    }  \n}  \n\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VeryBig</span> </span>{  \n    <span class=\"keyword\">public</span> String id;  \n    <span class=\"comment\">// 占用空间,让线程进行回收  </span>\n    <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span> * <span class=\"number\">1024</span>];  \n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">VeryBig</span><span class=\"params\">(String id)</span> </span>{  \n        <span class=\"keyword\">this</span>.id = id;  \n    }  \n\n    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> </span>{  \n        System.out.println(<span class=\"string\">\"Finalizing VeryBig \"</span> + id);  \n    }  \n}  \n\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VeryBigWeakReference</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">VeryBig</span>&gt; </span>{  \n    <span class=\"keyword\">public</span> String id;  \n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">VeryBigWeakReference</span><span class=\"params\">(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq)</span> </span>{  \n        <span class=\"keyword\">super</span>(big, rq);  \n        <span class=\"keyword\">this</span>.id = big.id;  \n    }  \n\n    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> </span>{  \n        System.out.println(<span class=\"string\">\"Finalizing VeryBigWeakReference \"</span> + id);  \n    }  \n}\n</code></pre>\n<p>最后的输出结果为：</p>\n<ol>\n<li>Just created weak: com.javabase.reference.VeryBigWeakReference@1641c0  </li>\n<li>Just created weak: com.javabase.reference.VeryBigWeakReference@136ab79  </li>\n<li>Just created weak: com.javabase.reference.VeryBigWeakReference@33c1aa  </li>\n<li>Finalizing VeryBig Weak 2  </li>\n<li>Finalizing VeryBig Weak 1  </li>\n<li>Finalizing VeryBig Weak 0  </li>\n<li>In queue: Weak 1  </li>\n<li>In queue: Weak 2  </li>\n<li>In queue: Weak 0  </li>\n</ol>\n<p>4、虚引用（PhantomReference）<br>     “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p>\n<p>5、总结<br> Java4种引用的级别由高到低依次为：</p>\n<p>强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用</p>\n<p>通过图来看一下他们之间在垃圾回收时的区别：</p>\n<p><img src=\"http://img.blog.csdn.net/20140223152242562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF6aGltYXpo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"tupian\"></p>\n<p>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：</p>\n<p>传送门：Java内存管理  <a href=\"http://blog.csdn.net/mazhimazh/article/category/1907599\">http://blog.csdn.net/mazhimazh/article/category/1907599</a></p>\n<p>参考文献：</p>\n<p>1、<a href=\"http://www.cnblogs.com/skywang12345/p/3154474.html\">http://www.cnblogs.com/skywang12345/p/3154474.html</a><br>2、<a href=\"http://blog.csdn.net/lifetragedy?viewmode=contents\">http://blog.csdn.net/lifetragedy?viewmode=contents</a></p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>"},{"title":"This ,Static，对象，对象的引用 等关键字的理解","date":"2016-07-26T06:12:30.000Z","_content":"##this 关键字：   \nthis关键字非常有意思，每一个Java类中都会有this关键字。   \nthis关键字的意思也很简单，就是当前类的对象的引用。表示调用方法的那个对象的引用。   \n\n##对象，对象的引用：   \n对象是指一个类通过new关键字生成的。   \n而对象的引用是指，指向这个对象的操作符。   \n###例如：   \nPerson person = new Person();   \n这里通过new Person（）生成了Person这个类的对象，然而生成对象后，我们想去操作这个对象中的方法，这个\n时候，我们就需要定义一个操作符，一个Person类的操作符。这个操作符是指向Person类的对象的。  \n如果这个例子不够清楚 那么看下面这个：\nPerson person;  \nperson = new Person();  \n从这里可以看出  如果person是一个对象的话，那么为什么还需要new Person()去生成这个对象呢?  \n所以结果很明显，person只是指向这个Person（）类的对象的。   \n\n##Static 关键字：\nStatic 静态，字典上解释为：“停止不动，不动的状态下就称为静态” 从物理的角度来讲就是静止状态。那从计算机的角度来讲就是：被static赋值的对象或者方法，不是“面向对象的” 他们具有全局函数的意义。可以直接通过类名来调用，而不需要通过对象来调用。\n\n\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n","source":"_posts/This-Static，对象，对象的引用-等关键字的理解.md","raw":"---\ntitle: 'This ,Static，对象，对象的引用 等关键字的理解'\ndate: 2016-7-26 14:12:30\ntags: Java\n---\n##this 关键字：   \nthis关键字非常有意思，每一个Java类中都会有this关键字。   \nthis关键字的意思也很简单，就是当前类的对象的引用。表示调用方法的那个对象的引用。   \n\n##对象，对象的引用：   \n对象是指一个类通过new关键字生成的。   \n而对象的引用是指，指向这个对象的操作符。   \n###例如：   \nPerson person = new Person();   \n这里通过new Person（）生成了Person这个类的对象，然而生成对象后，我们想去操作这个对象中的方法，这个\n时候，我们就需要定义一个操作符，一个Person类的操作符。这个操作符是指向Person类的对象的。  \n如果这个例子不够清楚 那么看下面这个：\nPerson person;  \nperson = new Person();  \n从这里可以看出  如果person是一个对象的话，那么为什么还需要new Person()去生成这个对象呢?  \n所以结果很明显，person只是指向这个Person（）类的对象的。   \n\n##Static 关键字：\nStatic 静态，字典上解释为：“停止不动，不动的状态下就称为静态” 从物理的角度来讲就是静止状态。那从计算机的角度来讲就是：被static赋值的对象或者方法，不是“面向对象的” 他们具有全局函数的意义。可以直接通过类名来调用，而不需要通过对象来调用。\n\n\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n","slug":"This-Static，对象，对象的引用-等关键字的理解","published":1,"updated":"2016-11-29T06:17:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcyf000q4jp5k67z7nqs","content":"<p>##this 关键字：<br>this关键字非常有意思，每一个Java类中都会有this关键字。<br>this关键字的意思也很简单，就是当前类的对象的引用。表示调用方法的那个对象的引用。   </p>\n<p>##对象，对象的引用：<br>对象是指一个类通过new关键字生成的。<br>而对象的引用是指，指向这个对象的操作符。   </p>\n<p>###例如：<br>Person person = new Person();<br>这里通过new Person（）生成了Person这个类的对象，然而生成对象后，我们想去操作这个对象中的方法，这个<br>时候，我们就需要定义一个操作符，一个Person类的操作符。这个操作符是指向Person类的对象的。<br>如果这个例子不够清楚 那么看下面这个：<br>Person person;<br>person = new Person();<br>从这里可以看出  如果person是一个对象的话，那么为什么还需要new Person()去生成这个对象呢?<br>所以结果很明显，person只是指向这个Person（）类的对象的。   </p>\n<p>##Static 关键字：<br>Static 静态，字典上解释为：“停止不动，不动的状态下就称为静态” 从物理的角度来讲就是静止状态。那从计算机的角度来讲就是：被static赋值的对象或者方法，不是“面向对象的” 他们具有全局函数的意义。可以直接通过类名来调用，而不需要通过对象来调用。</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"","more":"<p>##this 关键字：<br>this关键字非常有意思，每一个Java类中都会有this关键字。<br>this关键字的意思也很简单，就是当前类的对象的引用。表示调用方法的那个对象的引用。   </p>\n<p>##对象，对象的引用：<br>对象是指一个类通过new关键字生成的。<br>而对象的引用是指，指向这个对象的操作符。   </p>\n<p>###例如：<br>Person person = new Person();<br>这里通过new Person（）生成了Person这个类的对象，然而生成对象后，我们想去操作这个对象中的方法，这个<br>时候，我们就需要定义一个操作符，一个Person类的操作符。这个操作符是指向Person类的对象的。<br>如果这个例子不够清楚 那么看下面这个：<br>Person person;<br>person = new Person();<br>从这里可以看出  如果person是一个对象的话，那么为什么还需要new Person()去生成这个对象呢?<br>所以结果很明显，person只是指向这个Person（）类的对象的。   </p>\n<p>##Static 关键字：<br>Static 静态，字典上解释为：“停止不动，不动的状态下就称为静态” 从物理的角度来讲就是静止状态。那从计算机的角度来讲就是：被static赋值的对象或者方法，不是“面向对象的” 他们具有全局函数的意义。可以直接通过类名来调用，而不需要通过对象来调用。</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n"},{"title":"LruCache","date":"2016-09-28T05:26:18.000Z","_content":"LruCache是Android内存缓存的一种机制，全称 Lru 最近最少使用算法。\n这种缓存机制就是将最近最少使用的数据清除以腾出空间：\nAndroid例子：\nAndroid中初始化LruCache需要给他分配一定的控件，一般情况下分配整个APP内存的8分之一。\n代码：\n\n```java \nLruCache<String,Bitmap> lru = new LruCache<String,Bitmap>(memClass){\n    @Override\n    protected int sizeOf(String key, Bitmap value) {\n       return value.getByteCount()/1024;\n    }\n};\n```\n存：   \nlru.put(String,key);   \n取：   \nlru.get(String);\n\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n","source":"_posts/LruCache.md","raw":"---\ntitle: LruCache\ndate: 2016-9-28 13:26:18\ntags: Android\n---\nLruCache是Android内存缓存的一种机制，全称 Lru 最近最少使用算法。\n这种缓存机制就是将最近最少使用的数据清除以腾出空间：\nAndroid例子：\nAndroid中初始化LruCache需要给他分配一定的控件，一般情况下分配整个APP内存的8分之一。\n代码：\n\n```java \nLruCache<String,Bitmap> lru = new LruCache<String,Bitmap>(memClass){\n    @Override\n    protected int sizeOf(String key, Bitmap value) {\n       return value.getByteCount()/1024;\n    }\n};\n```\n存：   \nlru.put(String,key);   \n取：   \nlru.get(String);\n\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n","slug":"LruCache","published":1,"updated":"2016-11-29T06:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcyj000s4jp5tiqiorqv","content":"<p>LruCache是Android内存缓存的一种机制，全称 Lru 最近最少使用算法。<br>这种缓存机制就是将最近最少使用的数据清除以腾出空间：<br>Android例子：<br>Android中初始化LruCache需要给他分配一定的控件，一般情况下分配整个APP内存的8分之一。<br>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">LruCache&lt;String,Bitmap&gt; lru = <span class=\"keyword\">new</span> LruCache&lt;String,Bitmap&gt;(memClass)&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> value.getByteCount()/<span class=\"number\">1024</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>存：<br>lru.put(String,key);<br>取：<br>lru.get(String);</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"","more":"<p>LruCache是Android内存缓存的一种机制，全称 Lru 最近最少使用算法。<br>这种缓存机制就是将最近最少使用的数据清除以腾出空间：<br>Android例子：<br>Android中初始化LruCache需要给他分配一定的控件，一般情况下分配整个APP内存的8分之一。<br>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">LruCache&lt;String,Bitmap&gt; lru = <span class=\"keyword\">new</span> LruCache&lt;String,Bitmap&gt;(memClass)&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> value.getByteCount()/<span class=\"number\">1024</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>存：<br>lru.put(String,key);<br>取：<br>lru.get(String);</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n"},{"title":"StringBuffer与StringBuilder的区别","date":"2016-11-29T06:23:53.000Z","_content":"\nStringBuffer和StringBuilder作用都是一样的拼接字符。   \n区别在于StringBuffer是线程安全的，而StringBuilder是非线程安全的。   \n什么叫线程安全：   \n非线程安全是指多线程操作同一个对象可能会出现问题。而线程安全则是多线程操作同一个对象不会有问题。<!--more-->   \n线程安全是通过线程同步控制来实现的，也就是synchronized关键字。   \nHashMap和HashTable的区别也是一个是线程安全，一个是非线程安全的。   \nHashMap是非线程安全的。   \nHashTable是线程安全的。   \n\nlist和vector的区别   \nlist非线程安全   \nVector线程安全   \n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  ","source":"_posts/String-StringBuffer与StringBuilder的区别.md","raw":"---\ntitle: 'StringBuffer与StringBuilder的区别'\ndate: 2016-11-29 14:23:53\ntags: JAVA\n---\n\nStringBuffer和StringBuilder作用都是一样的拼接字符。   \n区别在于StringBuffer是线程安全的，而StringBuilder是非线程安全的。   \n什么叫线程安全：   \n非线程安全是指多线程操作同一个对象可能会出现问题。而线程安全则是多线程操作同一个对象不会有问题。<!--more-->   \n线程安全是通过线程同步控制来实现的，也就是synchronized关键字。   \nHashMap和HashTable的区别也是一个是线程安全，一个是非线程安全的。   \nHashMap是非线程安全的。   \nHashTable是线程安全的。   \n\nlist和vector的区别   \nlist非线程安全   \nVector线程安全   \n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  ","slug":"String-StringBuffer与StringBuilder的区别","published":1,"updated":"2016-11-29T06:25:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcyl000v4jp55lv70ni1","content":"<p>StringBuffer和StringBuilder作用都是一样的拼接字符。<br>区别在于StringBuffer是线程安全的，而StringBuilder是非线程安全的。<br>什么叫线程安全：<br>非线程安全是指多线程操作同一个对象可能会出现问题。而线程安全则是多线程操作同一个对象不会有问题。<a id=\"more\"></a><br>线程安全是通过线程同步控制来实现的，也就是synchronized关键字。<br>HashMap和HashTable的区别也是一个是线程安全，一个是非线程安全的。<br>HashMap是非线程安全的。<br>HashTable是线程安全的。   </p>\n<p>list和vector的区别<br>list非线程安全<br>Vector线程安全   </p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"<p>StringBuffer和StringBuilder作用都是一样的拼接字符。<br>区别在于StringBuffer是线程安全的，而StringBuilder是非线程安全的。<br>什么叫线程安全：<br>非线程安全是指多线程操作同一个对象可能会出现问题。而线程安全则是多线程操作同一个对象不会有问题。","more":"<br>线程安全是通过线程同步控制来实现的，也就是synchronized关键字。<br>HashMap和HashTable的区别也是一个是线程安全，一个是非线程安全的。<br>HashMap是非线程安全的。<br>HashTable是线程安全的。   </p>\n<p>list和vector的区别<br>list非线程安全<br>Vector线程安全   </p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>"},{"title":"Android 动态权限管理","date":"2016-11-13T05:19:27.000Z","_content":"从Android 6.0（API级别23）开始，用户在应用运行时（而不是在安装应用时）向应用授予权限。 此方法简化了应用安装过程，因为用户在安装或更新应用时不需要授予权限。 它还给用户更多的控制应用程序的功能; 例如，用户可以选择给摄像机应用访问摄像机而不是设备位置。 用户可以随时通过转到应用的设置屏幕撤消权限。<!--more-->\n\n### 随着Android6.0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。\n\n## 1.什么叫运行时权限管理？\n比如说，我们在app中打开相机的预览的功能的时候，我们的手机就会弹出一个提示框，提醒用户是否允许我们的app使用相机（也就是提供相机的权限）。这就相机权限就叫运行时权限，简而言之就是我们当我们需要某一项功能的时候所需要的权限。\n\n## 2.Android6.0之后我们为什么需要管理动态权限？\n就如上面所说的例子，当我们的用户不小心或者就是不想给相机权限时，我们的app就不能正常工作。所以这个时候我们就需要给用户一些友好的提示，或者最少不让app崩溃。这个时候我们就需要管理运行时权限了。\n\n\n## 3.在Android中如何加入运行权限管理？[API地址](https://developer.android.com/reference/android/support/v4/content/PermissionChecker.html)  \n运行时权限管理在代码中主要依靠几个类和几个方法来完成  \n1.PermissionChecker类（最主要的类）  \n主要提供检测权限的方法 \n\n2.PermissionChecker.checkSelfPermission(context,permission）（主要的方法）   \n用于检测当前是否有permission这个权限。                               \n主要返回3个值:(是个int类型的值)   \n* PERMISSION_GRANTED(0 (0x00000000)):有此权限   \n* PERMISSION_DENIED（-1 (0xffffffff)）: 没有此权限  \n* PERMISSION_DENIED_APP_OP （-2 (0xfffffffe)）:  权限被拒绝，因为不允许应用操作   \n\n3.context.shouldShowRequestPermissionRationale(permission)  \n这个方法主要用来获取是否应该显示具有请求权限的理由的UI。具体就是，这个方法会告诉你是否可以通过请求来显示友好的权限申请框。它会返回一个boolean值。   \n＊ true：表示可以申请。\n＊ false：表示不可以申请。（如果不能申请，就可以自己做一些事情）\n\n4.requestPermissions(@NonNull String[] permissions, int requestCode)      \n申请请求一组权限，此方法可以一次申请多个权限，通过OnRequestPermissionsResultCallback方法获得用户操作后的权限状态\n\n5.OnRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)这个方法用于接受申请权限后用户对权限操作的结果，可以看出来结果和权限时以一对的形式出现的。比如说permission[0] 对应grantResults[0],以此类推。\ngrantRsults的值也是3种类型和2中返回的类型是相同的，我们只需要对不同的类型进行判断就行了。\n\n## 4.说再多都不如看代码\n\n```java    \n  /**\n     * Activity\n     * 判断权限\n     * 主要判断权限6.0以上的机型\n     * 需要在调用此方法的类中实现 onRequestPermissionsResult\n     */\n    @TargetApi(Build.VERSION_CODES.M)\n    public static void openMyActivityPermission(Activity context, String permission,int requestCode){\n        int result = PermissionChecker.checkSelfPermission(context,permission);\n        if (result == PermissionChecker.PERMISSION_GRANTED){\n            //有权限\n        }else {\n            //没有权限\n            //判断能否显示系统弹框\n            boolean isShow = context.shouldShowRequestPermissionRationale(permission);\n            if (!isShow){\n                //不能显示系统弹框，这里只能手动提示用户\n            }else {\n                //帮用户弹出系统弹框\n                context.requestPermissions(new String[]{permission},requestCode);\n            }\n        }\n    }\n    \n    //用户选择后回调\n    @Override\n    public void onRequestPermissionsResult(int requestCode,@NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode,permissions, grantResults);\n    }   \n```\n\n### 5.再说运行时权限管理\n这个运行时权限管理是goole6.0的加入的一个东西。但是在碎片化极其严重的android中，不可能只有6.0的手机。所以仅仅靠6.0是不现实的。所以我们还要更多的考虑6.0以下的权限适配问题。由于各个厂家的深度定制（鸡肋～～～），很多厂家都自己实现了运行时权限提醒等一系列温馨的功能（各种奇葩～～），所以这时就需要我们开发者自己想办法解决这些问题。   \n\n比如说6.0以下我们需要相机这个权限，但是用户在安装app的时候没有勾选相机权限，或者当弹出权限询问框的时候用户点击了禁止我们该怎么办。目前我知道的就只有try catch来解决这个问题。\n\n\n对于运行时权限问题就到这里，此文仅当记录自己遇到的坑～～～如有问题请予以纠正。谢谢。\n","source":"_posts/permission-0.md","raw":"---\ntitle: Android 动态权限管理\ndate: 2016-11-13 13:19:27\ntags: Android\n---\n从Android 6.0（API级别23）开始，用户在应用运行时（而不是在安装应用时）向应用授予权限。 此方法简化了应用安装过程，因为用户在安装或更新应用时不需要授予权限。 它还给用户更多的控制应用程序的功能; 例如，用户可以选择给摄像机应用访问摄像机而不是设备位置。 用户可以随时通过转到应用的设置屏幕撤消权限。<!--more-->\n\n### 随着Android6.0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。\n\n## 1.什么叫运行时权限管理？\n比如说，我们在app中打开相机的预览的功能的时候，我们的手机就会弹出一个提示框，提醒用户是否允许我们的app使用相机（也就是提供相机的权限）。这就相机权限就叫运行时权限，简而言之就是我们当我们需要某一项功能的时候所需要的权限。\n\n## 2.Android6.0之后我们为什么需要管理动态权限？\n就如上面所说的例子，当我们的用户不小心或者就是不想给相机权限时，我们的app就不能正常工作。所以这个时候我们就需要给用户一些友好的提示，或者最少不让app崩溃。这个时候我们就需要管理运行时权限了。\n\n\n## 3.在Android中如何加入运行权限管理？[API地址](https://developer.android.com/reference/android/support/v4/content/PermissionChecker.html)  \n运行时权限管理在代码中主要依靠几个类和几个方法来完成  \n1.PermissionChecker类（最主要的类）  \n主要提供检测权限的方法 \n\n2.PermissionChecker.checkSelfPermission(context,permission）（主要的方法）   \n用于检测当前是否有permission这个权限。                               \n主要返回3个值:(是个int类型的值)   \n* PERMISSION_GRANTED(0 (0x00000000)):有此权限   \n* PERMISSION_DENIED（-1 (0xffffffff)）: 没有此权限  \n* PERMISSION_DENIED_APP_OP （-2 (0xfffffffe)）:  权限被拒绝，因为不允许应用操作   \n\n3.context.shouldShowRequestPermissionRationale(permission)  \n这个方法主要用来获取是否应该显示具有请求权限的理由的UI。具体就是，这个方法会告诉你是否可以通过请求来显示友好的权限申请框。它会返回一个boolean值。   \n＊ true：表示可以申请。\n＊ false：表示不可以申请。（如果不能申请，就可以自己做一些事情）\n\n4.requestPermissions(@NonNull String[] permissions, int requestCode)      \n申请请求一组权限，此方法可以一次申请多个权限，通过OnRequestPermissionsResultCallback方法获得用户操作后的权限状态\n\n5.OnRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)这个方法用于接受申请权限后用户对权限操作的结果，可以看出来结果和权限时以一对的形式出现的。比如说permission[0] 对应grantResults[0],以此类推。\ngrantRsults的值也是3种类型和2中返回的类型是相同的，我们只需要对不同的类型进行判断就行了。\n\n## 4.说再多都不如看代码\n\n```java    \n  /**\n     * Activity\n     * 判断权限\n     * 主要判断权限6.0以上的机型\n     * 需要在调用此方法的类中实现 onRequestPermissionsResult\n     */\n    @TargetApi(Build.VERSION_CODES.M)\n    public static void openMyActivityPermission(Activity context, String permission,int requestCode){\n        int result = PermissionChecker.checkSelfPermission(context,permission);\n        if (result == PermissionChecker.PERMISSION_GRANTED){\n            //有权限\n        }else {\n            //没有权限\n            //判断能否显示系统弹框\n            boolean isShow = context.shouldShowRequestPermissionRationale(permission);\n            if (!isShow){\n                //不能显示系统弹框，这里只能手动提示用户\n            }else {\n                //帮用户弹出系统弹框\n                context.requestPermissions(new String[]{permission},requestCode);\n            }\n        }\n    }\n    \n    //用户选择后回调\n    @Override\n    public void onRequestPermissionsResult(int requestCode,@NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode,permissions, grantResults);\n    }   \n```\n\n### 5.再说运行时权限管理\n这个运行时权限管理是goole6.0的加入的一个东西。但是在碎片化极其严重的android中，不可能只有6.0的手机。所以仅仅靠6.0是不现实的。所以我们还要更多的考虑6.0以下的权限适配问题。由于各个厂家的深度定制（鸡肋～～～），很多厂家都自己实现了运行时权限提醒等一系列温馨的功能（各种奇葩～～），所以这时就需要我们开发者自己想办法解决这些问题。   \n\n比如说6.0以下我们需要相机这个权限，但是用户在安装app的时候没有勾选相机权限，或者当弹出权限询问框的时候用户点击了禁止我们该怎么办。目前我知道的就只有try catch来解决这个问题。\n\n\n对于运行时权限问题就到这里，此文仅当记录自己遇到的坑～～～如有问题请予以纠正。谢谢。\n","slug":"permission-0","published":1,"updated":"2016-11-13T08:54:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcyp000x4jp5k7kdgg6i","content":"<p>从Android 6.0（API级别23）开始，用户在应用运行时（而不是在安装应用时）向应用授予权限。 此方法简化了应用安装过程，因为用户在安装或更新应用时不需要授予权限。 它还给用户更多的控制应用程序的功能; 例如，用户可以选择给摄像机应用访问摄像机而不是设备位置。 用户可以随时通过转到应用的设置屏幕撤消权限。<a id=\"more\"></a></p>\n<h3 id=\"随着Android6-0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。\"><a href=\"#随着Android6-0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。\" class=\"headerlink\" title=\"随着Android6.0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。\"></a>随着Android6.0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。</h3><h2 id=\"1-什么叫运行时权限管理？\"><a href=\"#1-什么叫运行时权限管理？\" class=\"headerlink\" title=\"1.什么叫运行时权限管理？\"></a>1.什么叫运行时权限管理？</h2><p>比如说，我们在app中打开相机的预览的功能的时候，我们的手机就会弹出一个提示框，提醒用户是否允许我们的app使用相机（也就是提供相机的权限）。这就相机权限就叫运行时权限，简而言之就是我们当我们需要某一项功能的时候所需要的权限。</p>\n<h2 id=\"2-Android6-0之后我们为什么需要管理动态权限？\"><a href=\"#2-Android6-0之后我们为什么需要管理动态权限？\" class=\"headerlink\" title=\"2.Android6.0之后我们为什么需要管理动态权限？\"></a>2.Android6.0之后我们为什么需要管理动态权限？</h2><p>就如上面所说的例子，当我们的用户不小心或者就是不想给相机权限时，我们的app就不能正常工作。所以这个时候我们就需要给用户一些友好的提示，或者最少不让app崩溃。这个时候我们就需要管理运行时权限了。</p>\n<h2 id=\"3-在Android中如何加入运行权限管理？API地址\"><a href=\"#3-在Android中如何加入运行权限管理？API地址\" class=\"headerlink\" title=\"3.在Android中如何加入运行权限管理？API地址\"></a>3.在Android中如何加入运行权限管理？<a href=\"https://developer.android.com/reference/android/support/v4/content/PermissionChecker.html\" target=\"_blank\" rel=\"external\">API地址</a></h2><p>运行时权限管理在代码中主要依靠几个类和几个方法来完成<br>1.PermissionChecker类（最主要的类）<br>主要提供检测权限的方法 </p>\n<p>2.PermissionChecker.checkSelfPermission(context,permission）（主要的方法）<br>用于检测当前是否有permission这个权限。<br>主要返回3个值:(是个int类型的值)   </p>\n<ul>\n<li>PERMISSION_GRANTED(0 (0x00000000)):有此权限   </li>\n<li>PERMISSION_DENIED（-1 (0xffffffff)）: 没有此权限  </li>\n<li>PERMISSION_DENIED_APP_OP （-2 (0xfffffffe)）:  权限被拒绝，因为不允许应用操作   </li>\n</ul>\n<p>3.context.shouldShowRequestPermissionRationale(permission)<br>这个方法主要用来获取是否应该显示具有请求权限的理由的UI。具体就是，这个方法会告诉你是否可以通过请求来显示友好的权限申请框。它会返回一个boolean值。<br>＊ true：表示可以申请。<br>＊ false：表示不可以申请。（如果不能申请，就可以自己做一些事情）</p>\n<p>4.requestPermissions(@NonNull String[] permissions, int requestCode)<br>申请请求一组权限，此方法可以一次申请多个权限，通过OnRequestPermissionsResultCallback方法获得用户操作后的权限状态</p>\n<p>5.OnRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)这个方法用于接受申请权限后用户对权限操作的结果，可以看出来结果和权限时以一对的形式出现的。比如说permission[0] 对应grantResults[0],以此类推。<br>grantRsults的值也是3种类型和2中返回的类型是相同的，我们只需要对不同的类型进行判断就行了。</p>\n<h2 id=\"4-说再多都不如看代码\"><a href=\"#4-说再多都不如看代码\" class=\"headerlink\" title=\"4.说再多都不如看代码\"></a>4.说再多都不如看代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Activity</div><div class=\"line\">   * 判断权限</div><div class=\"line\">   * 主要判断权限6.0以上的机型</div><div class=\"line\">   * 需要在调用此方法的类中实现 onRequestPermissionsResult</div><div class=\"line\">   */</div><div class=\"line\">  <span class=\"meta\">@TargetApi</span>(Build.VERSION_CODES.M)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">openMyActivityPermission</span><span class=\"params\">(Activity context, String permission,<span class=\"keyword\">int</span> requestCode)</span></span>&#123;</div><div class=\"line\">      <span class=\"keyword\">int</span> result = PermissionChecker.checkSelfPermission(context,permission);</div><div class=\"line\">      <span class=\"keyword\">if</span> (result == PermissionChecker.PERMISSION_GRANTED)&#123;</div><div class=\"line\">          <span class=\"comment\">//有权限</span></div><div class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">//没有权限</span></div><div class=\"line\">          <span class=\"comment\">//判断能否显示系统弹框</span></div><div class=\"line\">          <span class=\"keyword\">boolean</span> isShow = context.shouldShowRequestPermissionRationale(permission);</div><div class=\"line\">          <span class=\"keyword\">if</span> (!isShow)&#123;</div><div class=\"line\">              <span class=\"comment\">//不能显示系统弹框，这里只能手动提示用户</span></div><div class=\"line\">          &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              <span class=\"comment\">//帮用户弹出系统弹框</span></div><div class=\"line\">              context.requestPermissions(<span class=\"keyword\">new</span> String[]&#123;permission&#125;,requestCode);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//用户选择后回调</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode,@NonNull String[] permissions, @NonNull <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode,permissions, grantResults);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-再说运行时权限管理\"><a href=\"#5-再说运行时权限管理\" class=\"headerlink\" title=\"5.再说运行时权限管理\"></a>5.再说运行时权限管理</h3><p>这个运行时权限管理是goole6.0的加入的一个东西。但是在碎片化极其严重的android中，不可能只有6.0的手机。所以仅仅靠6.0是不现实的。所以我们还要更多的考虑6.0以下的权限适配问题。由于各个厂家的深度定制（鸡肋～～～），很多厂家都自己实现了运行时权限提醒等一系列温馨的功能（各种奇葩～～），所以这时就需要我们开发者自己想办法解决这些问题。   </p>\n<p>比如说6.0以下我们需要相机这个权限，但是用户在安装app的时候没有勾选相机权限，或者当弹出权限询问框的时候用户点击了禁止我们该怎么办。目前我知道的就只有try catch来解决这个问题。</p>\n<p>对于运行时权限问题就到这里，此文仅当记录自己遇到的坑～～～如有问题请予以纠正。谢谢。</p>\n","excerpt":"<p>从Android 6.0（API级别23）开始，用户在应用运行时（而不是在安装应用时）向应用授予权限。 此方法简化了应用安装过程，因为用户在安装或更新应用时不需要授予权限。 它还给用户更多的控制应用程序的功能; 例如，用户可以选择给摄像机应用访问摄像机而不是设备位置。 用户可以随时通过转到应用的设置屏幕撤消权限。","more":"</p>\n<h3 id=\"随着Android6-0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。\"><a href=\"#随着Android6-0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。\" class=\"headerlink\" title=\"随着Android6.0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。\"></a>随着Android6.0的普及，我们不得不做的一件事情就是关于运行时权限管理的事情。</h3><h2 id=\"1-什么叫运行时权限管理？\"><a href=\"#1-什么叫运行时权限管理？\" class=\"headerlink\" title=\"1.什么叫运行时权限管理？\"></a>1.什么叫运行时权限管理？</h2><p>比如说，我们在app中打开相机的预览的功能的时候，我们的手机就会弹出一个提示框，提醒用户是否允许我们的app使用相机（也就是提供相机的权限）。这就相机权限就叫运行时权限，简而言之就是我们当我们需要某一项功能的时候所需要的权限。</p>\n<h2 id=\"2-Android6-0之后我们为什么需要管理动态权限？\"><a href=\"#2-Android6-0之后我们为什么需要管理动态权限？\" class=\"headerlink\" title=\"2.Android6.0之后我们为什么需要管理动态权限？\"></a>2.Android6.0之后我们为什么需要管理动态权限？</h2><p>就如上面所说的例子，当我们的用户不小心或者就是不想给相机权限时，我们的app就不能正常工作。所以这个时候我们就需要给用户一些友好的提示，或者最少不让app崩溃。这个时候我们就需要管理运行时权限了。</p>\n<h2 id=\"3-在Android中如何加入运行权限管理？API地址\"><a href=\"#3-在Android中如何加入运行权限管理？API地址\" class=\"headerlink\" title=\"3.在Android中如何加入运行权限管理？API地址\"></a>3.在Android中如何加入运行权限管理？<a href=\"https://developer.android.com/reference/android/support/v4/content/PermissionChecker.html\">API地址</a></h2><p>运行时权限管理在代码中主要依靠几个类和几个方法来完成<br>1.PermissionChecker类（最主要的类）<br>主要提供检测权限的方法 </p>\n<p>2.PermissionChecker.checkSelfPermission(context,permission）（主要的方法）<br>用于检测当前是否有permission这个权限。<br>主要返回3个值:(是个int类型的值)   </p>\n<ul>\n<li>PERMISSION_GRANTED(0 (0x00000000)):有此权限   </li>\n<li>PERMISSION_DENIED（-1 (0xffffffff)）: 没有此权限  </li>\n<li>PERMISSION_DENIED_APP_OP （-2 (0xfffffffe)）:  权限被拒绝，因为不允许应用操作   </li>\n</ul>\n<p>3.context.shouldShowRequestPermissionRationale(permission)<br>这个方法主要用来获取是否应该显示具有请求权限的理由的UI。具体就是，这个方法会告诉你是否可以通过请求来显示友好的权限申请框。它会返回一个boolean值。<br>＊ true：表示可以申请。<br>＊ false：表示不可以申请。（如果不能申请，就可以自己做一些事情）</p>\n<p>4.requestPermissions(@NonNull String[] permissions, int requestCode)<br>申请请求一组权限，此方法可以一次申请多个权限，通过OnRequestPermissionsResultCallback方法获得用户操作后的权限状态</p>\n<p>5.OnRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)这个方法用于接受申请权限后用户对权限操作的结果，可以看出来结果和权限时以一对的形式出现的。比如说permission[0] 对应grantResults[0],以此类推。<br>grantRsults的值也是3种类型和2中返回的类型是相同的，我们只需要对不同的类型进行判断就行了。</p>\n<h2 id=\"4-说再多都不如看代码\"><a href=\"#4-说再多都不如看代码\" class=\"headerlink\" title=\"4.说再多都不如看代码\"></a>4.说再多都不如看代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Activity</div><div class=\"line\">   * 判断权限</div><div class=\"line\">   * 主要判断权限6.0以上的机型</div><div class=\"line\">   * 需要在调用此方法的类中实现 onRequestPermissionsResult</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"meta\">@TargetApi</span>(Build.VERSION_CODES.M)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">openMyActivityPermission</span><span class=\"params\">(Activity context, String permission,<span class=\"keyword\">int</span> requestCode)</span></span>&#123;</div><div class=\"line\">      <span class=\"keyword\">int</span> result = PermissionChecker.checkSelfPermission(context,permission);</div><div class=\"line\">      <span class=\"keyword\">if</span> (result == PermissionChecker.PERMISSION_GRANTED)&#123;</div><div class=\"line\">          <span class=\"comment\">//有权限</span></div><div class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">//没有权限</span></div><div class=\"line\">          <span class=\"comment\">//判断能否显示系统弹框</span></div><div class=\"line\">          <span class=\"keyword\">boolean</span> isShow = context.shouldShowRequestPermissionRationale(permission);</div><div class=\"line\">          <span class=\"keyword\">if</span> (!isShow)&#123;</div><div class=\"line\">              <span class=\"comment\">//不能显示系统弹框，这里只能手动提示用户</span></div><div class=\"line\">          &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              <span class=\"comment\">//帮用户弹出系统弹框</span></div><div class=\"line\">              context.requestPermissions(<span class=\"keyword\">new</span> String[]&#123;permission&#125;,requestCode);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//用户选择后回调</span></div><div class=\"line\">  <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode,@NonNull String[] permissions, @NonNull <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode,permissions, grantResults);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-再说运行时权限管理\"><a href=\"#5-再说运行时权限管理\" class=\"headerlink\" title=\"5.再说运行时权限管理\"></a>5.再说运行时权限管理</h3><p>这个运行时权限管理是goole6.0的加入的一个东西。但是在碎片化极其严重的android中，不可能只有6.0的手机。所以仅仅靠6.0是不现实的。所以我们还要更多的考虑6.0以下的权限适配问题。由于各个厂家的深度定制（鸡肋～～～），很多厂家都自己实现了运行时权限提醒等一系列温馨的功能（各种奇葩～～），所以这时就需要我们开发者自己想办法解决这些问题。   </p>\n<p>比如说6.0以下我们需要相机这个权限，但是用户在安装app的时候没有勾选相机权限，或者当弹出权限询问框的时候用户点击了禁止我们该怎么办。目前我知道的就只有try catch来解决这个问题。</p>\n<p>对于运行时权限问题就到这里，此文仅当记录自己遇到的坑～～～如有问题请予以纠正。谢谢。</p>"},{"title":"retrofit rxjava Gson解析的坑","date":"2016-12-14T08:50:03.000Z","_content":" 最近重构项目，把原有的网络请求改为retrofit+rxjava的。但是遇到了一个不大不小的坑。（ps：后台的锅~~~）   \n 一般情况下我们的json是这样的：   \n\n```java \n {\n    \"data\": {\n        \"message\": \"测试内容\"\n    },\n    \"err_msg\": \"\",\n    \"ret_code\": 0\n}\n```\n写个基础的Basebean通过继承的方式来处理，把返回码、返回信息和数据分开，像下面这样：<!--more-->   \n\n```java\npublic class BaseBean {\n\n    protected String err_msg;\n    protected int ret_code;\n}\n```\n这种方式当然是不可取的，并且代码的耦合性太高。   \n所以这个时候突然想起来retrofit有个GsonConverterFactory类，查阅源码发现重写这个类还是比较简单的就能实现我们想要的自定义的Gson解析。  \n\n首先需要创建一个Converter.Factory的类\n\n```java\n\npublic class CustomGsonConverterFactory extends Converter.Factory {\n\n    private final Gson gson;\n    private static final MediaType MEDIA_TYPE = MediaType.parse(\"application/json; charset=UTF-8\");\n    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    public CustomGsonConverterFactory(Gson gson) {\n        if (gson == null) throw new NullPointerException(\"gson == null\");\n        this.gson = gson;\n    }\n\n    public static CustomGsonConverterFactory create() {\n        return create(new Gson());\n    }\n\n    public static CustomGsonConverterFactory create(Gson gson) {\n        return new CustomGsonConverterFactory(gson);\n    }\n\n    @Override\n    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {\n        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));\n        return new CustomGsonResponseBodyConverter<>(gson, adapter);\n    }\n\n    @Override\n    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {\n        return super.requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);\n    }\n\n    @Override\n    public Converter<?, String> stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) {\n        return super.stringConverter(type, annotations, retrofit);\n    }\n```\nresponseBodyConverter方法是网络请求成功后，数据返回的处理方法。\n\n```java\n@Override\n    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {\n        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));\n        return new CustomGsonResponseBodyConverter<>(gson, adapter);\n    }\n```\n如上方法 我们需要返回一个Converter对象。关键来了我们需要操作的地方就在这个CustomGsonResponseBodyConverter里面.\n\n```java\npublic class CustomGsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {\n        private final Gson gson;\n        private final TypeAdapter<T> adapter;\n\n        CustomGsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {\n            this.gson = gson;\n            this.adapter = adapter;\n        }\n\n        /**\n         * 这里统一对json数据做了处理\n         * 通过gson获取httpstatus对象 判断ret_code码 判断是否有异常\n         * 有异常 抛出异常和异常信息\n         * 没异常 单独获取data的json字符串 再由okhttp3 转换为我们需要的object\n         *\n         * @param value\n         * @return\n         * @throws IOException\n         */\n        @Override\n        public T convert(ResponseBody value) throws IOException {\n            //获取json字符串，此处由于API原因 字符串只能获取一次\n            String response = value.string();\n            //获取httpStatus的数据\n            HttpStatusBean result = gson.fromJson(response, HttpStatusBean.class);\n            if (result.ret_code == CommonParameter.RET_CODE_SUCCESS) {\n                  //此处具体操作原因 看GsonModel\n                GsonBean gsonModel = gson.fromJson(response, GsonBean.class);\n                String pString = GSonUtil.getJson(gsonModel.data);\n                MediaType contentType = value.contentType();\n                Charset charset = contentType != null ? contentType.charset(UTF_8) : UTF_8;\n                InputStream inputStream = new ByteArrayInputStream(pString.getBytes());\n                Reader reader = new InputStreamReader(inputStream, charset);\n                JsonReader jsonReader = gson.newJsonReader(reader);\n                return adapter.read(jsonReader);\n            } else {\n                value.close();\n                throw new ApiException(result.err_msg);\n            }\n        }\n    }\n}\n```\n实现Converter < ResponseBody, T>接口会实现convert中的方法。方法中的value就是返回的数据，用ResponseBody封装起来的。通过\n\n```java\nvalue.string()\n```\n获得服务器返回的json的字符串，这样我们就可以为所欲为了。（只获取某一部分呀之类的）   \n下面这段代码是把json字符串再重新包装返回：\n\n```java\nCharset charset = contentType != null ? contentType.charset(UTF_8) : UTF_8;\n                InputStream inputStream = new ByteArrayInputStream(pString.getBytes());\n                Reader reader = new InputStreamReader(inputStream, charset);\n                JsonReader jsonReader = gson.newJsonReader(reader);\n```\n\n这样我们就实现了json数据的自定义。","source":"_posts/retrofit-rxjava-Gson解析的坑.md","raw":"---\ntitle: retrofit rxjava Gson解析的坑\ndate: 2016-12-14 16:50:03\ntags: Android\n---\n 最近重构项目，把原有的网络请求改为retrofit+rxjava的。但是遇到了一个不大不小的坑。（ps：后台的锅~~~）   \n 一般情况下我们的json是这样的：   \n\n```java \n {\n    \"data\": {\n        \"message\": \"测试内容\"\n    },\n    \"err_msg\": \"\",\n    \"ret_code\": 0\n}\n```\n写个基础的Basebean通过继承的方式来处理，把返回码、返回信息和数据分开，像下面这样：<!--more-->   \n\n```java\npublic class BaseBean {\n\n    protected String err_msg;\n    protected int ret_code;\n}\n```\n这种方式当然是不可取的，并且代码的耦合性太高。   \n所以这个时候突然想起来retrofit有个GsonConverterFactory类，查阅源码发现重写这个类还是比较简单的就能实现我们想要的自定义的Gson解析。  \n\n首先需要创建一个Converter.Factory的类\n\n```java\n\npublic class CustomGsonConverterFactory extends Converter.Factory {\n\n    private final Gson gson;\n    private static final MediaType MEDIA_TYPE = MediaType.parse(\"application/json; charset=UTF-8\");\n    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    public CustomGsonConverterFactory(Gson gson) {\n        if (gson == null) throw new NullPointerException(\"gson == null\");\n        this.gson = gson;\n    }\n\n    public static CustomGsonConverterFactory create() {\n        return create(new Gson());\n    }\n\n    public static CustomGsonConverterFactory create(Gson gson) {\n        return new CustomGsonConverterFactory(gson);\n    }\n\n    @Override\n    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {\n        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));\n        return new CustomGsonResponseBodyConverter<>(gson, adapter);\n    }\n\n    @Override\n    public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {\n        return super.requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);\n    }\n\n    @Override\n    public Converter<?, String> stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) {\n        return super.stringConverter(type, annotations, retrofit);\n    }\n```\nresponseBodyConverter方法是网络请求成功后，数据返回的处理方法。\n\n```java\n@Override\n    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {\n        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));\n        return new CustomGsonResponseBodyConverter<>(gson, adapter);\n    }\n```\n如上方法 我们需要返回一个Converter对象。关键来了我们需要操作的地方就在这个CustomGsonResponseBodyConverter里面.\n\n```java\npublic class CustomGsonResponseBodyConverter<T> implements Converter<ResponseBody, T> {\n        private final Gson gson;\n        private final TypeAdapter<T> adapter;\n\n        CustomGsonResponseBodyConverter(Gson gson, TypeAdapter<T> adapter) {\n            this.gson = gson;\n            this.adapter = adapter;\n        }\n\n        /**\n         * 这里统一对json数据做了处理\n         * 通过gson获取httpstatus对象 判断ret_code码 判断是否有异常\n         * 有异常 抛出异常和异常信息\n         * 没异常 单独获取data的json字符串 再由okhttp3 转换为我们需要的object\n         *\n         * @param value\n         * @return\n         * @throws IOException\n         */\n        @Override\n        public T convert(ResponseBody value) throws IOException {\n            //获取json字符串，此处由于API原因 字符串只能获取一次\n            String response = value.string();\n            //获取httpStatus的数据\n            HttpStatusBean result = gson.fromJson(response, HttpStatusBean.class);\n            if (result.ret_code == CommonParameter.RET_CODE_SUCCESS) {\n                  //此处具体操作原因 看GsonModel\n                GsonBean gsonModel = gson.fromJson(response, GsonBean.class);\n                String pString = GSonUtil.getJson(gsonModel.data);\n                MediaType contentType = value.contentType();\n                Charset charset = contentType != null ? contentType.charset(UTF_8) : UTF_8;\n                InputStream inputStream = new ByteArrayInputStream(pString.getBytes());\n                Reader reader = new InputStreamReader(inputStream, charset);\n                JsonReader jsonReader = gson.newJsonReader(reader);\n                return adapter.read(jsonReader);\n            } else {\n                value.close();\n                throw new ApiException(result.err_msg);\n            }\n        }\n    }\n}\n```\n实现Converter < ResponseBody, T>接口会实现convert中的方法。方法中的value就是返回的数据，用ResponseBody封装起来的。通过\n\n```java\nvalue.string()\n```\n获得服务器返回的json的字符串，这样我们就可以为所欲为了。（只获取某一部分呀之类的）   \n下面这段代码是把json字符串再重新包装返回：\n\n```java\nCharset charset = contentType != null ? contentType.charset(UTF_8) : UTF_8;\n                InputStream inputStream = new ByteArrayInputStream(pString.getBytes());\n                Reader reader = new InputStreamReader(inputStream, charset);\n                JsonReader jsonReader = gson.newJsonReader(reader);\n```\n\n这样我们就实现了json数据的自定义。","slug":"retrofit-rxjava-Gson解析的坑","published":1,"updated":"2016-12-16T01:24:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcyq00104jp5ubhtb6qh","content":"<p> 最近重构项目，把原有的网络请求改为retrofit+rxjava的。但是遇到了一个不大不小的坑。（ps：后台的锅~~~）<br> 一般情况下我们的json是这样的：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &#123;</div><div class=\"line\">    <span class=\"string\">\"data\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"message\"</span>: <span class=\"string\">\"测试内容\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"err_msg\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">    <span class=\"string\">\"ret_code\"</span>: <span class=\"number\">0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>写个基础的Basebean通过继承的方式来处理，把返回码、返回信息和数据分开，像下面这样：<a id=\"more\"></a>   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseBean</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">protected</span> String err_msg;</div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> ret_code;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方式当然是不可取的，并且代码的耦合性太高。<br>所以这个时候突然想起来retrofit有个GsonConverterFactory类，查阅源码发现重写这个类还是比较简单的就能实现我们想要的自定义的Gson解析。  </p>\n<p>首先需要创建一个Converter.Factory的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomGsonConverterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">Converter</span>.<span class=\"title\">Factory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Gson gson;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MediaType MEDIA_TYPE = MediaType.parse(<span class=\"string\">\"application/json; charset=UTF-8\"</span>);</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Charset UTF_8 = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomGsonConverterFactory</span><span class=\"params\">(Gson gson)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (gson == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"gson == null\"</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.gson = gson;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CustomGsonConverterFactory <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> create(<span class=\"keyword\">new</span> Gson());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CustomGsonConverterFactory <span class=\"title\">create</span><span class=\"params\">(Gson gson)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomGsonConverterFactory(gson);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class=\"line\">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomGsonResponseBodyConverter&lt;&gt;(gson, adapter);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.stringConverter(type, annotations, retrofit);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>responseBodyConverter方法是网络请求成功后，数据返回的处理方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class=\"line\">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomGsonResponseBodyConverter&lt;&gt;(gson, adapter);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>如上方法 我们需要返回一个Converter对象。关键来了我们需要操作的地方就在这个CustomGsonResponseBodyConverter里面.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomGsonResponseBodyConverter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">ResponseBody</span>, <span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Gson gson;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TypeAdapter&lt;T&gt; adapter;</div><div class=\"line\"></div><div class=\"line\">        CustomGsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.gson = gson;</div><div class=\"line\">            <span class=\"keyword\">this</span>.adapter = adapter;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/**</span></div><div class=\"line\">         * 这里统一对json数据做了处理</div><div class=\"line\">         * 通过gson获取httpstatus对象 判断ret_code码 判断是否有异常</div><div class=\"line\">         * 有异常 抛出异常和异常信息</div><div class=\"line\">         * 没异常 单独获取data的json字符串 再由okhttp3 转换为我们需要的object</div><div class=\"line\">         *</div><div class=\"line\">         * <span class=\"doctag\">@param</span> value</div><div class=\"line\">         * <span class=\"doctag\">@return</span></div><div class=\"line\">         * <span class=\"doctag\">@throws</span> IOException</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">convert</span><span class=\"params\">(ResponseBody value)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">            <span class=\"comment\">//获取json字符串，此处由于API原因 字符串只能获取一次</span></div><div class=\"line\">            String response = value.string();</div><div class=\"line\">            <span class=\"comment\">//获取httpStatus的数据</span></div><div class=\"line\">            HttpStatusBean result = gson.fromJson(response, HttpStatusBean.class);</div><div class=\"line\">            <span class=\"keyword\">if</span> (result.ret_code == CommonParameter.RET_CODE_SUCCESS) &#123;</div><div class=\"line\">                  <span class=\"comment\">//此处具体操作原因 看GsonModel</span></div><div class=\"line\">                GsonBean gsonModel = gson.fromJson(response, GsonBean.class);</div><div class=\"line\">                String pString = GSonUtil.getJson(gsonModel.data);</div><div class=\"line\">                MediaType contentType = value.contentType();</div><div class=\"line\">                Charset charset = contentType != <span class=\"keyword\">null</span> ? contentType.charset(UTF_8) : UTF_8;</div><div class=\"line\">                InputStream inputStream = <span class=\"keyword\">new</span> ByteArrayInputStream(pString.getBytes());</div><div class=\"line\">                Reader reader = <span class=\"keyword\">new</span> InputStreamReader(inputStream, charset);</div><div class=\"line\">                JsonReader jsonReader = gson.newJsonReader(reader);</div><div class=\"line\">                <span class=\"keyword\">return</span> adapter.read(jsonReader);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                value.close();</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApiException(result.err_msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实现Converter &lt; ResponseBody, T&gt;接口会实现convert中的方法。方法中的value就是返回的数据，用ResponseBody封装起来的。通过</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">value.string()</div></pre></td></tr></table></figure>\n<p>获得服务器返回的json的字符串，这样我们就可以为所欲为了。（只获取某一部分呀之类的）<br>下面这段代码是把json字符串再重新包装返回：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = contentType != <span class=\"keyword\">null</span> ? contentType.charset(UTF_8) : UTF_8;</div><div class=\"line\">                InputStream inputStream = <span class=\"keyword\">new</span> ByteArrayInputStream(pString.getBytes());</div><div class=\"line\">                Reader reader = <span class=\"keyword\">new</span> InputStreamReader(inputStream, charset);</div><div class=\"line\">                JsonReader jsonReader = gson.newJsonReader(reader);</div></pre></td></tr></table></figure>\n<p>这样我们就实现了json数据的自定义。</p>\n","excerpt":"<p> 最近重构项目，把原有的网络请求改为retrofit+rxjava的。但是遇到了一个不大不小的坑。（ps：后台的锅~~~）<br> 一般情况下我们的json是这样的：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> &#123;</div><div class=\"line\">    <span class=\"string\">\"data\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"message\"</span>: <span class=\"string\">\"测试内容\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"err_msg\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">    <span class=\"string\">\"ret_code\"</span>: <span class=\"number\">0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>写个基础的Basebean通过继承的方式来处理，把返回码、返回信息和数据分开，像下面这样：","more":"</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseBean</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">protected</span> String err_msg;</div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> ret_code;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方式当然是不可取的，并且代码的耦合性太高。<br>所以这个时候突然想起来retrofit有个GsonConverterFactory类，查阅源码发现重写这个类还是比较简单的就能实现我们想要的自定义的Gson解析。  </p>\n<p>首先需要创建一个Converter.Factory的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomGsonConverterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">Converter</span>.<span class=\"title\">Factory</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Gson gson;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MediaType MEDIA_TYPE = MediaType.parse(<span class=\"string\">\"application/json; charset=UTF-8\"</span>);</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Charset UTF_8 = Charset.forName(<span class=\"string\">\"UTF-8\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomGsonConverterFactory</span><span class=\"params\">(Gson gson)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (gson == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"gson == null\"</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.gson = gson;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CustomGsonConverterFactory <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> create(<span class=\"keyword\">new</span> Gson());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CustomGsonConverterFactory <span class=\"title\">create</span><span class=\"params\">(Gson gson)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomGsonConverterFactory(gson);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class=\"line\">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomGsonResponseBodyConverter&lt;&gt;(gson, adapter);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.stringConverter(type, annotations, retrofit);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>responseBodyConverter方法是网络请求成功后，数据返回的处理方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class=\"line\">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomGsonResponseBodyConverter&lt;&gt;(gson, adapter);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>如上方法 我们需要返回一个Converter对象。关键来了我们需要操作的地方就在这个CustomGsonResponseBodyConverter里面.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomGsonResponseBodyConverter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">ResponseBody</span>, <span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Gson gson;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TypeAdapter&lt;T&gt; adapter;</div><div class=\"line\"></div><div class=\"line\">        CustomGsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.gson = gson;</div><div class=\"line\">            <span class=\"keyword\">this</span>.adapter = adapter;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/**</div><div class=\"line\">         * 这里统一对json数据做了处理</div><div class=\"line\">         * 通过gson获取httpstatus对象 判断ret_code码 判断是否有异常</div><div class=\"line\">         * 有异常 抛出异常和异常信息</div><div class=\"line\">         * 没异常 单独获取data的json字符串 再由okhttp3 转换为我们需要的object</div><div class=\"line\">         *</div><div class=\"line\">         * <span class=\"doctag\">@param</span> value</div><div class=\"line\">         * <span class=\"doctag\">@return</span></div><div class=\"line\">         * <span class=\"doctag\">@throws</span> IOException</div><div class=\"line\">         */</span></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">convert</span><span class=\"params\">(ResponseBody value)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">            <span class=\"comment\">//获取json字符串，此处由于API原因 字符串只能获取一次</span></div><div class=\"line\">            String response = value.string();</div><div class=\"line\">            <span class=\"comment\">//获取httpStatus的数据</span></div><div class=\"line\">            HttpStatusBean result = gson.fromJson(response, HttpStatusBean.class);</div><div class=\"line\">            <span class=\"keyword\">if</span> (result.ret_code == CommonParameter.RET_CODE_SUCCESS) &#123;</div><div class=\"line\">                  <span class=\"comment\">//此处具体操作原因 看GsonModel</span></div><div class=\"line\">                GsonBean gsonModel = gson.fromJson(response, GsonBean.class);</div><div class=\"line\">                String pString = GSonUtil.getJson(gsonModel.data);</div><div class=\"line\">                MediaType contentType = value.contentType();</div><div class=\"line\">                Charset charset = contentType != <span class=\"keyword\">null</span> ? contentType.charset(UTF_8) : UTF_8;</div><div class=\"line\">                InputStream inputStream = <span class=\"keyword\">new</span> ByteArrayInputStream(pString.getBytes());</div><div class=\"line\">                Reader reader = <span class=\"keyword\">new</span> InputStreamReader(inputStream, charset);</div><div class=\"line\">                JsonReader jsonReader = gson.newJsonReader(reader);</div><div class=\"line\">                <span class=\"keyword\">return</span> adapter.read(jsonReader);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                value.close();</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApiException(result.err_msg);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实现Converter &lt; ResponseBody, T&gt;接口会实现convert中的方法。方法中的value就是返回的数据，用ResponseBody封装起来的。通过</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">value.string()</div></pre></td></tr></table></figure>\n<p>获得服务器返回的json的字符串，这样我们就可以为所欲为了。（只获取某一部分呀之类的）<br>下面这段代码是把json字符串再重新包装返回：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Charset charset = contentType != <span class=\"keyword\">null</span> ? contentType.charset(UTF_8) : UTF_8;</div><div class=\"line\">                InputStream inputStream = <span class=\"keyword\">new</span> ByteArrayInputStream(pString.getBytes());</div><div class=\"line\">                Reader reader = <span class=\"keyword\">new</span> InputStreamReader(inputStream, charset);</div><div class=\"line\">                JsonReader jsonReader = gson.newJsonReader(reader);</div></pre></td></tr></table></figure>\n<p>这样我们就实现了json数据的自定义。</p>"},{"title":"线程和线程池 handlerThread","date":"2016-09-27T12:25:25.000Z","_content":"\n进程:资源分配的最小单位。\n线程：最小调度单位。\n一个线程只能有一个进程，一个进程可以由无数的线程。\n创建线程的3种方式：\n1.直接继承Thread类。\n2.实现Runnable接口。\n3. 通过Callable和Future创建线程。\n\n现在进入正题 线程池：\n首先什么叫线程池。线程池就是在一个多线程的应用中，有一个线程的集合。然后在需要执行新任务时重用这些线程，而不是重新开一个。\n\nhandlerThread就是一个线程实现了handler机制。\n\n创建线程池的四种方式：\n1.newFixedThread(int size) 创建固定线程数量的线程池。超出的线程会在队列中等待。   \n例子：   \n\n```java\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class ExecutorStudy {\n\n    public static void main(String[] args) {\n\n        //创建一个固定长度为5的线程池\n        ExecutorService fixed = Executors.newFixedThreadPool(5);\n\n        for (int i = 0; i < 20; i++) {\n            fixed.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    // TODO Auto-generated method stub\n                    System.out.println(Thread.currentThread());\n                }\n            });\n        }\n\n    }\n\n}\n```\n\n2.newCachedThread() 创建一个缓存线程池，当没有可用线程时就创建，如果任务来了，有可用线程就复用。   \n例子：   \n```java\n       //创建一个缓存线程池\n              ExecutorService cached = Executors.newCachedThreadPool();\n              for (int i = 0; i < 20; i++) {\n                     cached.execute(new Runnable() {\n                           @Override\n                           public void run() {\n                                  // TODO Auto-generated method stub\n                                  System.out.println(Thread.currentThread());\n                           }\n                     });\n              }\n              fixed.shutdown();\n```\n\n\n可以看出线程时一直增长的，但是当前面使用过的线程空闲时又会给安排新的任务。\n\n3.newSingleThread() 创建一个单独的线程池， 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n例子：\n\n```java \n\n       // 创建一个单独的线程池\n ExecutorService excutor = Executors.newSingleThreadExecutor();\n              for (int i = 0; i < 20; i++) {\n                     excutor.execute(new Runnable() {\n                           @Override\n                           public void run() {\n                                  // TODO Auto-generated method stub\n                                  System.out.println(Thread.currentThread());\n                           }\n                     });\n              }\n              excutor.shutdown();\n```\n \n\n4.newScheduledThread()创建一个定长线程池，支持定时及周期性完成任务。   \n例子：   \n\n```java\n// 创建一个延时为3秒的线程池\n              ScheduledExecutorService scheduled = Executors\n                           .newScheduledThreadPool(5);\n              for (int i = 0; i < 10; i++) {\n                     scheduled.schedule(new Runnable() {\n                           @Override\n                           public void run() {\n                                  // TODO Auto-generated method stub\n                                   System.out.println(Thread.currentThread());\n                           }\n                     }, 3, TimeUnit.SECONDS);\n              }\n              scheduled.shutdown();\n```\n\n\n总结：\n          合理使用线程池可以使得程序的资源消耗更低，程序运行的更流畅。\n          \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n","source":"_posts/线程和线程池-handlerThread.md","raw":"---\ntitle: 线程和线程池 handlerThread\ndate: 2016-9-27 20:25:25\ntags: Android \n---\n\n进程:资源分配的最小单位。\n线程：最小调度单位。\n一个线程只能有一个进程，一个进程可以由无数的线程。\n创建线程的3种方式：\n1.直接继承Thread类。\n2.实现Runnable接口。\n3. 通过Callable和Future创建线程。\n\n现在进入正题 线程池：\n首先什么叫线程池。线程池就是在一个多线程的应用中，有一个线程的集合。然后在需要执行新任务时重用这些线程，而不是重新开一个。\n\nhandlerThread就是一个线程实现了handler机制。\n\n创建线程池的四种方式：\n1.newFixedThread(int size) 创建固定线程数量的线程池。超出的线程会在队列中等待。   \n例子：   \n\n```java\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class ExecutorStudy {\n\n    public static void main(String[] args) {\n\n        //创建一个固定长度为5的线程池\n        ExecutorService fixed = Executors.newFixedThreadPool(5);\n\n        for (int i = 0; i < 20; i++) {\n            fixed.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    // TODO Auto-generated method stub\n                    System.out.println(Thread.currentThread());\n                }\n            });\n        }\n\n    }\n\n}\n```\n\n2.newCachedThread() 创建一个缓存线程池，当没有可用线程时就创建，如果任务来了，有可用线程就复用。   \n例子：   \n```java\n       //创建一个缓存线程池\n              ExecutorService cached = Executors.newCachedThreadPool();\n              for (int i = 0; i < 20; i++) {\n                     cached.execute(new Runnable() {\n                           @Override\n                           public void run() {\n                                  // TODO Auto-generated method stub\n                                  System.out.println(Thread.currentThread());\n                           }\n                     });\n              }\n              fixed.shutdown();\n```\n\n\n可以看出线程时一直增长的，但是当前面使用过的线程空闲时又会给安排新的任务。\n\n3.newSingleThread() 创建一个单独的线程池， 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n例子：\n\n```java \n\n       // 创建一个单独的线程池\n ExecutorService excutor = Executors.newSingleThreadExecutor();\n              for (int i = 0; i < 20; i++) {\n                     excutor.execute(new Runnable() {\n                           @Override\n                           public void run() {\n                                  // TODO Auto-generated method stub\n                                  System.out.println(Thread.currentThread());\n                           }\n                     });\n              }\n              excutor.shutdown();\n```\n \n\n4.newScheduledThread()创建一个定长线程池，支持定时及周期性完成任务。   \n例子：   \n\n```java\n// 创建一个延时为3秒的线程池\n              ScheduledExecutorService scheduled = Executors\n                           .newScheduledThreadPool(5);\n              for (int i = 0; i < 10; i++) {\n                     scheduled.schedule(new Runnable() {\n                           @Override\n                           public void run() {\n                                  // TODO Auto-generated method stub\n                                   System.out.println(Thread.currentThread());\n                           }\n                     }, 3, TimeUnit.SECONDS);\n              }\n              scheduled.shutdown();\n```\n\n\n总结：\n          合理使用线程池可以使得程序的资源消耗更低，程序运行的更流畅。\n          \n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n","slug":"线程和线程池-handlerThread","published":1,"updated":"2016-11-29T06:14:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcz000124jp5hfsqvqnb","content":"<p>进程:资源分配的最小单位。<br>线程：最小调度单位。<br>一个线程只能有一个进程，一个进程可以由无数的线程。<br>创建线程的3种方式：<br>1.直接继承Thread类。<br>2.实现Runnable接口。</p>\n<ol>\n<li>通过Callable和Future创建线程。</li>\n</ol>\n<p>现在进入正题 线程池：<br>首先什么叫线程池。线程池就是在一个多线程的应用中，有一个线程的集合。然后在需要执行新任务时重用这些线程，而不是重新开一个。</p>\n<p>handlerThread就是一个线程实现了handler机制。</p>\n<p>创建线程池的四种方式：<br>1.newFixedThread(int size) 创建固定线程数量的线程池。超出的线程会在队列中等待。<br>例子：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Callable;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executor;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.FutureTask;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeoutException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorStudy</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//创建一个固定长度为5的线程池</span></div><div class=\"line\">        ExecutorService fixed = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</div><div class=\"line\">            fixed.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">                    System.out.println(Thread.currentThread());</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.newCachedThread() 创建一个缓存线程池，当没有可用线程时就创建，如果任务来了，有可用线程就复用。<br>例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个缓存线程池</span></div><div class=\"line\">       ExecutorService cached = Executors.newCachedThreadPool();</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</div><div class=\"line\">              cached.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                           <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">                           System.out.println(Thread.currentThread());</div><div class=\"line\">                    &#125;</div><div class=\"line\">              &#125;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       fixed.shutdown();</div></pre></td></tr></table></figure></p>\n<p>可以看出线程时一直增长的，但是当前面使用过的线程空闲时又会给安排新的任务。</p>\n<p>3.newSingleThread() 创建一个单独的线程池， 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 创建一个单独的线程池</span></div><div class=\"line\">ExecutorService excutor = Executors.newSingleThreadExecutor();</div><div class=\"line\">             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</div><div class=\"line\">                    excutor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                          <span class=\"meta\">@Override</span></div><div class=\"line\">                          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                                 <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">                                 System.out.println(Thread.currentThread());</div><div class=\"line\">                          &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">             &#125;</div><div class=\"line\">             excutor.shutdown();</div></pre></td></tr></table></figure>\n<p>4.newScheduledThread()创建一个定长线程池，支持定时及周期性完成任务。<br>例子：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个延时为3秒的线程池</span></div><div class=\"line\">              ScheduledExecutorService scheduled = Executors</div><div class=\"line\">                           .newScheduledThreadPool(<span class=\"number\">5</span>);</div><div class=\"line\">              <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">                     scheduled.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                           <span class=\"meta\">@Override</span></div><div class=\"line\">                           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                                  <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">                                   System.out.println(Thread.currentThread());</div><div class=\"line\">                           &#125;</div><div class=\"line\">                     &#125;, <span class=\"number\">3</span>, TimeUnit.SECONDS);</div><div class=\"line\">              &#125;</div><div class=\"line\">              scheduled.shutdown();</div></pre></td></tr></table></figure>\n<p>总结：<br>          合理使用线程池可以使得程序的资源消耗更低，程序运行的更流畅。</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"","more":"<p>进程:资源分配的最小单位。<br>线程：最小调度单位。<br>一个线程只能有一个进程，一个进程可以由无数的线程。<br>创建线程的3种方式：<br>1.直接继承Thread类。<br>2.实现Runnable接口。</p>\n<ol>\n<li>通过Callable和Future创建线程。</li>\n</ol>\n<p>现在进入正题 线程池：<br>首先什么叫线程池。线程池就是在一个多线程的应用中，有一个线程的集合。然后在需要执行新任务时重用这些线程，而不是重新开一个。</p>\n<p>handlerThread就是一个线程实现了handler机制。</p>\n<p>创建线程池的四种方式：<br>1.newFixedThread(int size) 创建固定线程数量的线程池。超出的线程会在队列中等待。<br>例子：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Callable;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executor;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.FutureTask;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeoutException;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorStudy</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//创建一个固定长度为5的线程池</span></div><div class=\"line\">        ExecutorService fixed = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</div><div class=\"line\">            fixed.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">                    System.out.println(Thread.currentThread());</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.newCachedThread() 创建一个缓存线程池，当没有可用线程时就创建，如果任务来了，有可用线程就复用。<br>例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个缓存线程池</span></div><div class=\"line\">       ExecutorService cached = Executors.newCachedThreadPool();</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</div><div class=\"line\">              cached.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                           <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">                           System.out.println(Thread.currentThread());</div><div class=\"line\">                    &#125;</div><div class=\"line\">              &#125;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       fixed.shutdown();</div></pre></td></tr></table></figure></p>\n<p>可以看出线程时一直增长的，但是当前面使用过的线程空闲时又会给安排新的任务。</p>\n<p>3.newSingleThread() 创建一个单独的线程池， 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// 创建一个单独的线程池</span></div><div class=\"line\">ExecutorService excutor = Executors.newSingleThreadExecutor();</div><div class=\"line\">             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</div><div class=\"line\">                    excutor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                          <span class=\"meta\">@Override</span></div><div class=\"line\">                          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                                 <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">                                 System.out.println(Thread.currentThread());</div><div class=\"line\">                          &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">             &#125;</div><div class=\"line\">             excutor.shutdown();</div></pre></td></tr></table></figure>\n<p>4.newScheduledThread()创建一个定长线程池，支持定时及周期性完成任务。<br>例子：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个延时为3秒的线程池</span></div><div class=\"line\">              ScheduledExecutorService scheduled = Executors</div><div class=\"line\">                           .newScheduledThreadPool(<span class=\"number\">5</span>);</div><div class=\"line\">              <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">                     scheduled.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                           <span class=\"meta\">@Override</span></div><div class=\"line\">                           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                                  <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">                                   System.out.println(Thread.currentThread());</div><div class=\"line\">                           &#125;</div><div class=\"line\">                     &#125;, <span class=\"number\">3</span>, TimeUnit.SECONDS);</div><div class=\"line\">              &#125;</div><div class=\"line\">              scheduled.shutdown();</div></pre></td></tr></table></figure>\n<p>总结：<br>          合理使用线程池可以使得程序的资源消耗更低，程序运行的更流畅。</p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n"},{"title":"代码规范的一些总结","date":"2017-01-04T01:38:14.000Z","_content":"# “任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”\n\n##  什么叫规范？\n规范，有名词、动词等词性。意指明文规定或约定俗成的标准。   \n对于某一工程作业或者行为进行定性的信息规定。主要是因为无法精准定量而形成的标准，所以，被称为规范。   \n规范是指群体所确立的行为标准。它们可以由组织正式规定，也可以是非正式形成。\n\n##  什么叫代码规范（编码规范）？\n为规范软件开发人员的代码编写提供参考依据和统一标准。\n\n## 为什么需要代码规范（编码规范）？\n▪ 软件：80%的时间都是处于维护。   \n▪ 几乎没有那个软件的维护是由原编写者进行的。   \n▪ 编码规范可以改善软件的可读性，使工程师理解新的代码更快速，更彻底。      \n\n## 举个栗子\n#### 一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。    \n#### 问题来了：为什么我要浪费时间遵守这些愚蠢的规范?   \n#### 答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉(或完全未见过)的程序，因为你一见它们就会觉得面熟。\n#### 这就是代码规范带来的好处，最好的好处是 你看每一行代码都会有一个美丽的心情。\n\n\n\n","source":"_posts/代码规范的一些总结.md","raw":"---\ntitle: 代码规范的一些总结\ndate: 2017-01-04 09:38:14\ntags: 代码规范\n---\n# “任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”\n\n##  什么叫规范？\n规范，有名词、动词等词性。意指明文规定或约定俗成的标准。   \n对于某一工程作业或者行为进行定性的信息规定。主要是因为无法精准定量而形成的标准，所以，被称为规范。   \n规范是指群体所确立的行为标准。它们可以由组织正式规定，也可以是非正式形成。\n\n##  什么叫代码规范（编码规范）？\n为规范软件开发人员的代码编写提供参考依据和统一标准。\n\n## 为什么需要代码规范（编码规范）？\n▪ 软件：80%的时间都是处于维护。   \n▪ 几乎没有那个软件的维护是由原编写者进行的。   \n▪ 编码规范可以改善软件的可读性，使工程师理解新的代码更快速，更彻底。      \n\n## 举个栗子\n#### 一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。    \n#### 问题来了：为什么我要浪费时间遵守这些愚蠢的规范?   \n#### 答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉(或完全未见过)的程序，因为你一见它们就会觉得面熟。\n#### 这就是代码规范带来的好处，最好的好处是 你看每一行代码都会有一个美丽的心情。\n\n\n\n","slug":"代码规范的一些总结","published":1,"updated":"2017-01-04T02:28:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcz100154jp5ohkwjgic","content":"<h1 id=\"“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”\"><a href=\"#“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”\" class=\"headerlink\" title=\"“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”\"></a>“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”</h1><h2 id=\"什么叫规范？\"><a href=\"#什么叫规范？\" class=\"headerlink\" title=\"什么叫规范？\"></a>什么叫规范？</h2><p>规范，有名词、动词等词性。意指明文规定或约定俗成的标准。<br>对于某一工程作业或者行为进行定性的信息规定。主要是因为无法精准定量而形成的标准，所以，被称为规范。<br>规范是指群体所确立的行为标准。它们可以由组织正式规定，也可以是非正式形成。</p>\n<h2 id=\"什么叫代码规范（编码规范）？\"><a href=\"#什么叫代码规范（编码规范）？\" class=\"headerlink\" title=\"什么叫代码规范（编码规范）？\"></a>什么叫代码规范（编码规范）？</h2><p>为规范软件开发人员的代码编写提供参考依据和统一标准。</p>\n<h2 id=\"为什么需要代码规范（编码规范）？\"><a href=\"#为什么需要代码规范（编码规范）？\" class=\"headerlink\" title=\"为什么需要代码规范（编码规范）？\"></a>为什么需要代码规范（编码规范）？</h2><p>▪ 软件：80%的时间都是处于维护。<br>▪ 几乎没有那个软件的维护是由原编写者进行的。<br>▪ 编码规范可以改善软件的可读性，使工程师理解新的代码更快速，更彻底。      </p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><h4 id=\"一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。\"><a href=\"#一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。\" class=\"headerlink\" title=\"一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。\"></a>一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。</h4><h4 id=\"问题来了：为什么我要浪费时间遵守这些愚蠢的规范\"><a href=\"#问题来了：为什么我要浪费时间遵守这些愚蠢的规范\" class=\"headerlink\" title=\"问题来了：为什么我要浪费时间遵守这些愚蠢的规范?\"></a>问题来了：为什么我要浪费时间遵守这些愚蠢的规范?</h4><h4 id=\"答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉-或完全未见过-的程序，因为你一见它们就会觉得面熟。\"><a href=\"#答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉-或完全未见过-的程序，因为你一见它们就会觉得面熟。\" class=\"headerlink\" title=\"答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉(或完全未见过)的程序，因为你一见它们就会觉得面熟。\"></a>答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉(或完全未见过)的程序，因为你一见它们就会觉得面熟。</h4><h4 id=\"这就是代码规范带来的好处，最好的好处是-你看每一行代码都会有一个美丽的心情。\"><a href=\"#这就是代码规范带来的好处，最好的好处是-你看每一行代码都会有一个美丽的心情。\" class=\"headerlink\" title=\"这就是代码规范带来的好处，最好的好处是 你看每一行代码都会有一个美丽的心情。\"></a>这就是代码规范带来的好处，最好的好处是 你看每一行代码都会有一个美丽的心情。</h4>","excerpt":"","more":"<h1 id=\"“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”\"><a href=\"#“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”\" class=\"headerlink\" title=\"“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”\"></a>“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”</h1><h2 id=\"什么叫规范？\"><a href=\"#什么叫规范？\" class=\"headerlink\" title=\"什么叫规范？\"></a>什么叫规范？</h2><p>规范，有名词、动词等词性。意指明文规定或约定俗成的标准。<br>对于某一工程作业或者行为进行定性的信息规定。主要是因为无法精准定量而形成的标准，所以，被称为规范。<br>规范是指群体所确立的行为标准。它们可以由组织正式规定，也可以是非正式形成。</p>\n<h2 id=\"什么叫代码规范（编码规范）？\"><a href=\"#什么叫代码规范（编码规范）？\" class=\"headerlink\" title=\"什么叫代码规范（编码规范）？\"></a>什么叫代码规范（编码规范）？</h2><p>为规范软件开发人员的代码编写提供参考依据和统一标准。</p>\n<h2 id=\"为什么需要代码规范（编码规范）？\"><a href=\"#为什么需要代码规范（编码规范）？\" class=\"headerlink\" title=\"为什么需要代码规范（编码规范）？\"></a>为什么需要代码规范（编码规范）？</h2><p>▪ 软件：80%的时间都是处于维护。<br>▪ 几乎没有那个软件的维护是由原编写者进行的。<br>▪ 编码规范可以改善软件的可读性，使工程师理解新的代码更快速，更彻底。      </p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><h4 id=\"一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。\"><a href=\"#一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。\" class=\"headerlink\" title=\"一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。\"></a>一个优秀的程序员，不愿意浪费时间遵守规范。技术很好，可以写出清晰的、易于理解的代码。</h4><h4 id=\"问题来了：为什么我要浪费时间遵守这些愚蠢的规范\"><a href=\"#问题来了：为什么我要浪费时间遵守这些愚蠢的规范\" class=\"headerlink\" title=\"问题来了：为什么我要浪费时间遵守这些愚蠢的规范?\"></a>问题来了：为什么我要浪费时间遵守这些愚蠢的规范?</h4><h4 id=\"答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉-或完全未见过-的程序，因为你一见它们就会觉得面熟。\"><a href=\"#答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉-或完全未见过-的程序，因为你一见它们就会觉得面熟。\" class=\"headerlink\" title=\"答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉(或完全未见过)的程序，因为你一见它们就会觉得面熟。\"></a>答案是：统一是有价值的。你看到的任何的一行代码—不论是由你写的，还是由你身边的同事，还是由一个跟你相差11个时区的距离人写的—它们都有统一的结构，相同的命名规范—这带来的效果是巨大的。你只需要花这么少的功夫就能看懂一个你不熟悉(或完全未见过)的程序，因为你一见它们就会觉得面熟。</h4><h4 id=\"这就是代码规范带来的好处，最好的好处是-你看每一行代码都会有一个美丽的心情。\"><a href=\"#这就是代码规范带来的好处，最好的好处是-你看每一行代码都会有一个美丽的心情。\" class=\"headerlink\" title=\"这就是代码规范带来的好处，最好的好处是 你看每一行代码都会有一个美丽的心情。\"></a>这就是代码规范带来的好处，最好的好处是 你看每一行代码都会有一个美丽的心情。</h4>"},{"title":"如何提高代码的可读性（转载）","date":"2016-12-14T07:42:26.000Z","_content":"本文转自[码出未来的博客](https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/)\n\n“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。” ，这句话出自《重构》这本书，我个人很赞同这句话，原因如下：\n\n- 代码不仅仅是人类和计算机沟通的语言，它也是建立在程序员之间的桥梁，两个程序员在沟通的时候，任何富有表达力的言语都不如直接阅读对方一段代码。\n- 代码也是公司的一笔特殊的财富，因为它不可能永远被一个程序员维护，如果代码的可读性很差的话，很可能导致这笔财富无法传承下来，前功尽弃。\n- 具有良好可读性的代码能让功能的扩展和BUG的修复更顺利，这一点应该很容易理解，增加新功能、修改某个BUG都需要你首先理解代码。\n\n\n所以，提高代码可读性是很有必要的，本文将介绍个人在实践中认为能够提高代码可读性的方法，希望对大家有所帮助。   \n## 1 重视代码规范\n重视代码规范是提高代码可读性最基本和最简单的方式，每一门语言，每一个公司或组织都会有自己的代码规范，制定这些规范的目的就是为了让大家能够更容易阅读和理解代码。例如当我们看到某一个变量名称前面带有 m 前缀时，我们就知道它是一个成员变量（member）；当我们看到某个方法以 on 开头时，我们就知道它是一个回调方法；当我们看到某个变量是由大写字母和下划线组成时，我们就知道它是一个静态常量。诸如此类的规范有很多，只要我们遵循规范，我们代码的可读性起码会有一个最低的保障。\n\n## 2 多写注释\n注释本应作为代码不可分割一部分，因为它是对代码最直观最详细的说明，你可以把设计思路、用法和注意事项都写在注释里面，这样无论是对你自己还是对别人都是有好处的，它让你能在很久没有接触代码的时候快速回忆起当初的想法，能让阅读源码的人更快理解你的思路，让使用的人更清楚用法。\n\n例如我们有一个设置年龄的方法叫 setAge(int age)，从方法名称上我们就可以知道它的作用，但是其内部还做了一些其他处理，这些处理是方法命无法体现的，所以加上一段注释说明就很有必要了：   \n\n```java\n/**\n * 设置用户的年龄，当 age < 0 的时候会设置 age = 0，当 age > 100 的时候会设置 age = 100。\n * 另外你可以通过 {@link #getAge()} 方法获取用于的年龄。\n *\n * @param age 用户年龄[0, 100]\n * @see #getAge()\n */\npublic void setAge(int age) {\n    if (age < 0) {\n        age = 0;\n    } else if (age > 100) {\n        age = 100;\n    }\n    this.age = age;\n}\n```\n\n## 3 重写注释   \n当我们重写某个方法并且修改了方法的逻辑导致它的行为与原有的注释描述不一致的时候，我们应该对注释也进行重写，以确保注释内容和代码逻辑一致。例如上面的提到的 setAge(int age) 方法，我们对它进行重写，改成接收任意数值的年龄，此时原有的注释内容就需要修改，因为它已经不适用于现在的逻辑：   \n\n```java\n/**\n * 设置用户的年龄，另外你可以通过 {@link #getAge()} 方法获取用于的年龄。\n *\n * @param age 任意数值的用户年龄\n * @see #getAge()\n */\npublic void setAge(int age) {\n    if (age < 0) {\n        age = 0;\n    } else if (age > 100) {\n        age = 100;\n    }\n    this.age = age;\n}\n```   \n## 4 使用注解\n注解可以用于替换一些简短的注释描述，并且提高变量、方法和类的可读性，最典型的例子就是 @Override 注解，它告诉我们被注解的方法是对父类或者接口方法的重写或实现，相比于注释“这是一个重写方法”，注解 @Override 要更简单快捷得多。例如下面的代码我们实现了 OnClickListener 接口的 onClick(View view) 方法：   \n\n```java\npublic class MyListener implements View.OnClickListener {\n    \n    // 重写 onClick 方法。\n    @Override\n    public void onClick(View view) {\n    \n    }\n}\n```\n大多数人只会使用一些现有的注解，而很少自己创建注解，其实我们可以自己创建一些有用的注解来提高代码的可读性，下面我们以 EventBus 为例，说明自定义注解是如何提高代码可读性的。   \n\nEventBus 是一个应用在 Android 上的事件总线，我们可以使用它在任意地方发布事件，并且在任意地方注册并接收事件。EventBus 有三个弊端，一是我们经常搞不清楚某一个事件是来自哪里的，因为任何地方都可以发送同一个事件；二是我们同样也经常搞不清楚某个事件会在哪些地方被接收，因为任何地方都可以注册并接收事件；三是早期的 EventBus 事件接收方法要求你必须以 onEventXXXX 的方式命名，这样的命名其实和普通方法并没有太大的区别，我们需要一种方式让它更加凸显，以防它被误以为是普通方法而被删除。这时候我们可以利用注解让事件接收方法一眼就被认出来，并且还能看出有哪些地方会发出该事件，哪些地方会接收到我们发出的事件：   \n\n```java\n/**\n * EventBus 事件注解，用于标识某个方法是 EventBus 方法，并且注明事件\n * 的接收方或发送方。\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Event {\n    Class[] from() default {};\n    Class[] to() default {};\n}\n```\n现在我们假设 A 和 B 都可以发送一个名叫 MyEvent 的事件到 C 和 D，我们可以这样写：\n\n```java\npublic class A {\n    \n    @Event(to = {C.class, D.class})\n    public void sendEvent() {\n        EventBus.getDefault().post(new MyEvent());\n    }\n    \n}\n\npublic class B {\n    \n    @Event(to = {C.class, D.class})\n    public void sendEvent() {\n        EventBus.getDefault().post(new MyEvent());\n    }\n    \n}\n\npublic class C {\n    \n    @Event(from = {A.class, B.class})\n    public void onEventMainThread(MyEvent event) {\n        // do something\n    }\n    \n}\n\npublic class D {\n    \n    @Event(from = {A.class, B.class})\n    public void onEventMainThread(MyEvent event) {\n        // do something\n    }\n    \n}\n```\n\n从上面的代码，我们通过 @Event 注解一眼就认出来 EventBus 方法，并且还能知道 A 将事件发送到了 C 和 D，而 C 接收到的事件可能来自 A 或 B。\n\n## 5 多用 @Nullable，慎用 @NonNull   \n【@Nullable】是一个用于标注某个变量、参数或方法返回值可能为空指针的注解，当我们看到该注解的时候就要小心了，它意味着如果我们不做判空处理的话，很可能出现空指针异常，并且在 Android Studio 上会以黄色背景警告我们。那么什么时候该使用该注解呢？我的原则只要某个变量、参数或方法返回值有一丝可能性为空，就使用该注解，这起码可以避免空指针异常的出现。   \n![图1](https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/nullable.png)   \n\n@NonNull】是一个用于标注某个变量、参数和方法返回值不可能为空指针的注解，当我们看到该注解的时候，就可以认为被标记的变量、参数或方法返回值不可能为空，无需做判空处理，同事 Android Studio 也会在你进行判空处理的时候提醒你没有必要。对于这个注解，我个人的原则是除非100%肯定不会空指针，否则绝对不用。\n![图2](https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/nonnull.png)   \n\n## 6 使用 @MainThread 和 @WorkerThread   \n【@MainThread】是一个用于标注某个类或方法必须在主线程中使用的注解，当我们看到该注解的时候，就要注意当前的操作是否处于主线程，否则很有可能出错。例如我们有个方法用于更新 TextView 的内容，因为涉及到 UI 的更新操作，必须在主线程进行，所以我们可以这么写：\n\n```java\n@MainThread\npublic void updateTitle(String title) {\n    mTvTitle.setText(title);\n}\n```\n\n【@WorkerThread】是一个用于标注某个类或方法必须在子线程中使用的注解，常见的情况就是不适合在主线程中进行的耗时操作，当我们看到该注解的时候，应该创建一个子线程去使用被注解的类或方法。例如我们有个方法用于将 Bitmap 保存到 SD 卡中，涉及到 I/O 的操作理应在子线程中进行，所以我们可以这么写：\n\n```java\n@WorkerThread\npublic void saveImage(Bitmap image, String path) throw IOException {\n    FileOutputStream outputStream = new FileOutputStream(path);\n    image.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);\n}\n```\n\n## 7 使用 return 减少 if 嵌套\n当我们的方法中有一系列业务逻辑是按顺序执行，并且每一个业务逻辑的执行前提是前一个业务逻辑执行成功时，我们可以考虑使用 return 关键字在业务逻辑执行失败时终止整个方法，而不是嵌套多层的 if。例如，我们有一个返回只为 boolean 类型的方法，它只有在方法内的所有业务逻辑都按顺序执行成功之后才返回 true：\n\n```java\npublic boolean func() {\n    boolean isSuccess;\n    isSuccess = doSomething1();\n    if (isSuccess) {\n        isSuccess = doSomething2();\n        if (isSuccess) {\n            isSuccess = doSomething3();\n            if (isSuccess) {\n                isSuccess = doSomething4();\n                if (isSuccess) {\n                    isSuccess = doSomething5();\n                }\n            }\n        }\n    }\n    return isSuccess;\n}\n```\n对于这种多重 if 嵌套的代码，我们可以在某个业务逻辑执行失败的时候 return false 来终止整个方法，这样做的好处是让一看就知道里面的逻辑是从上到下按顺序执行的，更容易理解，具体写法如下：\n\n```java\npublic boolean func() {\n    boolean isSuccess;\n    isSuccess = doSomething1();\n    if (!isSuccess) {\n        return false;\n    }\n    isSuccess = doSomething2();\n    if (!isSuccess) {\n        return false;\n    }\n    isSuccess = doSomething3();\n    if (!isSuccess) {\n        return false;\n    }\n    isSuccess = doSomething4();\n    if (!isSuccess) {\n        return false;\n    }\n    isSuccess = doSomething5();\n    if (!isSuccess) {\n        return false;\n    }\n    return isSuccess;\n}\n```\n## 8 使用 Map 代替分支语句\n当我们需要使用条件语句语句根据不同的条件筛选出对应的结果，并且条件很多导致语句很长时，可以考虑使用 Map 代替冗长的条件判断，例如有一个方法需要根据用户输入的索引值返回对应的字母（我们不考虑算法），我们以下三种写法：\n\n### 1 使用 if 语句\n\n```java\npublic char getLetter(int index) {\n    if (index == 1) {\n        return \"A\";\n    } else if (index == 2) {\n        return \"B\";\n    } else if (index == 3) {\n        return \"C\";\n    } else if (index == 4) {\n        return \"D\";\n    }\n    ...\n}\b\n```\n使用 if 语句进行大量的条件筛选是最糟糕的设计，一方面代码编写麻烦，另一方面代码长度也是最长的。\n\n### 2 使用 switch 语句\n\n```java\npublic char getLetter(int index) {\n    switch (index) {\n        case 1: return \"A\";\n        case 2: return \"B\";\n        case 3: return \"C\";\n        case 4: return \"D\";\n        ...\n    }\n}\b\n```\n使用 switch 语句是最常见的方式，通过不同的 case 筛选出对应的结果，并且逻辑清晰，代码量也相对较少。\n\n### 3 使用 Map\n\n```java\nprivate static final Map<Integer, String> LETTERS = new HashMap<>();\nstatic {\n    LETTERS.put(1, \"A\");\n    LETTERS.put(2, \"B\");\n    LETTERS.put(3, \"C\");\n    LETTERS.put(4, \"D\");\n    ...\n}\npublic char getLetter(int index) {\n    return LETTERS.get(index);\n}\b\n```\n使用 Map 代替 switch 本质上没有太大的区别，但是有些时候它可以让我们省去一个方法，例如我们完全可以省去 getLetter(int) 方法而直接通过 Map 获取想要的值。\n\n\n## 9 方法调用的语法糖\n方法调用的语法糖要求一个或多个方法的调用能够形成具有良好可读性的语句，我们通过几个简单的例子看下什么样的方法调用能够形成可以阅读的语句：\n\n### 1 Android ValueAnimator 实例创建\n\n```java\nValueAnimator animator = ValueAnimator.ofInt(0, 100);\n```\n\n我们将 ValueAnimator.ofInt 拆解开来会发现它其实就是“value animator of int”，也就是“整型类型的属性动画”。\n\n### 2 Android AnimatorSet 动画播放顺序\n\n```java\nAnimatorSet animatorSet = new AnimatorSet();\nanimatorSet.play(anim1).width(anim2).before(anim3);\n```\nAnimatorSet 是一个能够将多个动画组合在一起并且指定动画播放顺序的工具类，上面的方法调用方式很清晰的告诉我们“在播放 anim3 之前先同时播放 anim1 和 anim2”。\n\n### 3 Mockito 打桩方法\n\n```java\nwhen(person.getAge()).thenReturn(20);\n```\nMockito 是一个用于单元测试的框架，这里我们不探究它的用法，我们要看的是它的方法调用形式。上面的代码同样可以拆解成“when person.getAge() then return 20”，意思就是“当调用person.getAge()方法的时候，返回20”。  \n\n## 10 使用 Builder 代替构造方法\n当某个类的构造方法有很多个参数或者有很多个重载版本时，我们应该考虑为这个类写一个 Builder，通过这个 Builder 创建配置并创建该类的实例。\n\n假设我们有个类用来代表一个矩形，它的名字叫做 Rectangle，它的代码如下所示：\n\n```java\npublic class Rectangle {\n    private int mId;\n    private int mWidth;\n    private int mHeight;\n    private int mStroke;// 边框宽度\n    \n    public Rectangle(int id) { ... }\n    \n    public Rectangle(int id, int width, int height) { ... }\n    \n    public Rectangle(int id, int width, int height, int stroke) { ... }\n}\n```\n于是我们就可能看见这样的代码 new Rectangle(1, 1, 1, 1)，这样的代码可读性是很差的，因为我们无法一眼就看出这个矩形设置了哪些信息，还需要去查阅下相关的 API 文档。此外，当我们需要创建一个只需指定 id 和 stroke 的矩形的时候，我们就必须再写一个新的构造方法，当一个对象的属性较多的时候，构造方法的重载版本就可能变得非常的多，维护成本也随之提高。如果我们为 Rectangle 创建一个 Builder，通过 Builder 创建矩形实例的过程就会变得灵活而清晰很多：\n\n```java\npublic class Rectangle {\n    private int mId;\n    private int mWidth;\n    private int mHeight;\n    private int mStroke;// 边框宽度\n    \n    private Rectangle(Builder builder) {\n        mId = builder.id;\n        mWidth = builder.width;\n        mHeight = builder.height;\n        mStroke = builder.stroke;\n    }\n    \n    public static class Builder {\n    \n        private int id;\n        private int width;\n        private int height;\n        private int stroke;// 边框宽度\n        \n        public Builder(int id) {\n            this.id = id;\n        }\n        \n        public Rectangle build() {\n            return new Rectangle(this);\n        }\n        \n        public Builder width(int width) {\n            this.width = width;\n            return this;\n        }\n        \n        public Builder height(int height) {\n            this.height = height;\n            return this;\n        }\n        \n        public Builder stroke(int stroke) {\n            this.stroke = stroke;\n            return this;\n        }\n            \n    }\n}\n```\n\n现在，我们创建 Rectangle 实例的过程就会变成下面的样子，它不仅让我们一眼就看出矩形设置了哪些属性，而且我们还可以自由组合这些属性，达到重载构造方法想要的结果：\n\n```java\n\nRectangle.Builder builder1 = new Rectangle.Builder(1);\nRectangle rect1 = builder1.width(1).height(1).stroke(1).build();\nRectangle.Builder builder2 = new Rectangle.Builder(2);\nRectangle rect2 = builder2.width(1).height(1).build();\nRectangle.Builder builder3 = new Rectangle.Builder(3);\nRectangle rect3 = builder3.stroke(1).build();\n```\n\n## 11 使用 tools 优化布局预览\n【tools】是 Android 里进行布局排版时的一个工具，它用于在布局预览的时候设置临时属性。我们经常需要一边编写布局代码一边查看预览以确保布局正确，现在假设我们有一个 TextView 用来显示标题，但是标题的内容是在运行的时候动态设置的，为了开发的时候方便预览，提高复杂布局代码的可读性，我们可能会这么写：\n\n```java\n\n<TextView\n    android:text=\"测试标题\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\" />\n``` \n\n你一定想着等后面确定布局没问题的时候再删掉测试文案，但是事实上你很有可能忘记删除，这时候我们就可以利用 tools 这样写：\n\n```java\n<TextView\n    tools:text=\"测试标题\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\" />\n```\n\n通过 tools 设置的文案只会在预览的时候生效，不会影响到实际运行的情况，这样我们可以毫无顾忌地随便填写测试文案了。tools 支持的属性还有很多，例如：\n\n```xml\ntools:background\ntools:visibility\ntools:checked\ntools:src\n```\n\n关于更多 tools 的用法，大家可以到网上查找。\n\n## 12 使用 isInEditMode() 优化布局预览\nisInEditMode() 方法是用于判断 View 当前是否处于 IDE 布局编辑（预览）状态，只有在编辑状态下才会返回 true，当我们编写只有在运行时才能看到绘制效果的自定义 View 的时候，可以使用 isInEditMode() 方法让 View 在布局预览的时候就看到运行时的大概样子。例如我们通过 View 实现一个圆形不断放大缩小的动画时，正常情况我们只有在程序运行的时候才能看到动画效果，在布局预览的时候是空白一片的，我们可以通过 isInEditMode() 方法在编辑的时候先绘制一个圆形，让开发者大概知道这个动画 View 会是什么样子，虽然它是静止的，但是也好过一片空白：\n\n```java\npublic class AnimationView extends View {\n    \n    @Override\n    public void onDraw(Canvas canvas) {\n        if (isInEditMode()) {\n            // 编辑状态下绘制一个圆形，让开发者大概知道圆形的大小。\n            canvas.drawCircle(centerX, centerY, radius, paint);\n        } else {\n            // 运行时刷新画面。\n        }\n    }  \n}\n```\n我们在布局预览的时候就会看到一个圆形被绘制出来，并且在程序正在运行的时候不会绘制该圆形：   \n![图3](https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/preview_in_edit_mode.png)\n\n>提示：实际开发中，isInEditMode() 方法可以用在 View 的任何地方用于设置预览数据。\n\n## 13 使用内部类对代码进行分类\n内部类有些时候可以起到类似包的代码分类功能，通过内部类对某个类内部的代码进行功能划分，可以让与该类相关的代码更具有可读性。\n\n例如我们有个日志打印工具类，里面有两种类型的方法，一种是打印用户可见的日志，另一种则是打印只有开发者可见的日志，我们可以这样写：\n\n```java\npublic class Logger {\n    \n    // 用户可见的日志。\n    public class User {\n        public static void d(String tag, String msg) {\n            // 打印日志\n        }\n    }\n    \n    // 开发者可见的日志。\n    public class Developer {\n        public static void d(String tag, String msg) {\n            // 打印日志\n        }\n    }\n    \n}\n```\n我们在调用日志打印方法时通过内部类的名称一眼就可以看出当前打印的日志是用户可见还是开发者可见的：\n\n```java\n\nLogger.User.d(TAG, \"打印用户可见的日志\");\nLogger.Developer.d(TAG, \"打印开发者可见的日志\");\n类似的，我们也可以使用内部类对常量进行分类，例如我们有一个多媒体数据库叫 MediaStore，其内部分为图像数据表和视频数据表，每个表都有自己的字段，我们需要定义常量来对应这些字段，所以可以这样写：\n```\n\n```java\npublic class MediaStore {\n    \n    // 图像数据表\n    public class ImageTable {\n        public static final String NAME = \"image_name\";\n        public static final String PATH = \"image_path\";\n    }\n    \n    // 视频数据表\n    public class VideoTable {\n        public static final String NAME = \"video_name\";\n        public static final String PATH = \"video_path\"; \n    }\n    \n}\n```\n我们在需要使用这些常量的时候就可以通过内部类区分不同类型的常量了：\n\n```java\nMediaStore.ImageTable.NAME// 图像名称字段\nMediaStore.VideoTable.NAME// 视频名称字段\n```\n\n\n\n\n\n\n\n\n\n","source":"_posts/如何提高代码的可读性.md","raw":"---\ntitle: 如何提高代码的可读性（转载）\ndate: 2016-12-14 15:42:26\ntags: 代码规范\n---\n本文转自[码出未来的博客](https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/)\n\n“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。” ，这句话出自《重构》这本书，我个人很赞同这句话，原因如下：\n\n- 代码不仅仅是人类和计算机沟通的语言，它也是建立在程序员之间的桥梁，两个程序员在沟通的时候，任何富有表达力的言语都不如直接阅读对方一段代码。\n- 代码也是公司的一笔特殊的财富，因为它不可能永远被一个程序员维护，如果代码的可读性很差的话，很可能导致这笔财富无法传承下来，前功尽弃。\n- 具有良好可读性的代码能让功能的扩展和BUG的修复更顺利，这一点应该很容易理解，增加新功能、修改某个BUG都需要你首先理解代码。\n\n\n所以，提高代码可读性是很有必要的，本文将介绍个人在实践中认为能够提高代码可读性的方法，希望对大家有所帮助。   \n## 1 重视代码规范\n重视代码规范是提高代码可读性最基本和最简单的方式，每一门语言，每一个公司或组织都会有自己的代码规范，制定这些规范的目的就是为了让大家能够更容易阅读和理解代码。例如当我们看到某一个变量名称前面带有 m 前缀时，我们就知道它是一个成员变量（member）；当我们看到某个方法以 on 开头时，我们就知道它是一个回调方法；当我们看到某个变量是由大写字母和下划线组成时，我们就知道它是一个静态常量。诸如此类的规范有很多，只要我们遵循规范，我们代码的可读性起码会有一个最低的保障。\n\n## 2 多写注释\n注释本应作为代码不可分割一部分，因为它是对代码最直观最详细的说明，你可以把设计思路、用法和注意事项都写在注释里面，这样无论是对你自己还是对别人都是有好处的，它让你能在很久没有接触代码的时候快速回忆起当初的想法，能让阅读源码的人更快理解你的思路，让使用的人更清楚用法。\n\n例如我们有一个设置年龄的方法叫 setAge(int age)，从方法名称上我们就可以知道它的作用，但是其内部还做了一些其他处理，这些处理是方法命无法体现的，所以加上一段注释说明就很有必要了：   \n\n```java\n/**\n * 设置用户的年龄，当 age < 0 的时候会设置 age = 0，当 age > 100 的时候会设置 age = 100。\n * 另外你可以通过 {@link #getAge()} 方法获取用于的年龄。\n *\n * @param age 用户年龄[0, 100]\n * @see #getAge()\n */\npublic void setAge(int age) {\n    if (age < 0) {\n        age = 0;\n    } else if (age > 100) {\n        age = 100;\n    }\n    this.age = age;\n}\n```\n\n## 3 重写注释   \n当我们重写某个方法并且修改了方法的逻辑导致它的行为与原有的注释描述不一致的时候，我们应该对注释也进行重写，以确保注释内容和代码逻辑一致。例如上面的提到的 setAge(int age) 方法，我们对它进行重写，改成接收任意数值的年龄，此时原有的注释内容就需要修改，因为它已经不适用于现在的逻辑：   \n\n```java\n/**\n * 设置用户的年龄，另外你可以通过 {@link #getAge()} 方法获取用于的年龄。\n *\n * @param age 任意数值的用户年龄\n * @see #getAge()\n */\npublic void setAge(int age) {\n    if (age < 0) {\n        age = 0;\n    } else if (age > 100) {\n        age = 100;\n    }\n    this.age = age;\n}\n```   \n## 4 使用注解\n注解可以用于替换一些简短的注释描述，并且提高变量、方法和类的可读性，最典型的例子就是 @Override 注解，它告诉我们被注解的方法是对父类或者接口方法的重写或实现，相比于注释“这是一个重写方法”，注解 @Override 要更简单快捷得多。例如下面的代码我们实现了 OnClickListener 接口的 onClick(View view) 方法：   \n\n```java\npublic class MyListener implements View.OnClickListener {\n    \n    // 重写 onClick 方法。\n    @Override\n    public void onClick(View view) {\n    \n    }\n}\n```\n大多数人只会使用一些现有的注解，而很少自己创建注解，其实我们可以自己创建一些有用的注解来提高代码的可读性，下面我们以 EventBus 为例，说明自定义注解是如何提高代码可读性的。   \n\nEventBus 是一个应用在 Android 上的事件总线，我们可以使用它在任意地方发布事件，并且在任意地方注册并接收事件。EventBus 有三个弊端，一是我们经常搞不清楚某一个事件是来自哪里的，因为任何地方都可以发送同一个事件；二是我们同样也经常搞不清楚某个事件会在哪些地方被接收，因为任何地方都可以注册并接收事件；三是早期的 EventBus 事件接收方法要求你必须以 onEventXXXX 的方式命名，这样的命名其实和普通方法并没有太大的区别，我们需要一种方式让它更加凸显，以防它被误以为是普通方法而被删除。这时候我们可以利用注解让事件接收方法一眼就被认出来，并且还能看出有哪些地方会发出该事件，哪些地方会接收到我们发出的事件：   \n\n```java\n/**\n * EventBus 事件注解，用于标识某个方法是 EventBus 方法，并且注明事件\n * 的接收方或发送方。\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Event {\n    Class[] from() default {};\n    Class[] to() default {};\n}\n```\n现在我们假设 A 和 B 都可以发送一个名叫 MyEvent 的事件到 C 和 D，我们可以这样写：\n\n```java\npublic class A {\n    \n    @Event(to = {C.class, D.class})\n    public void sendEvent() {\n        EventBus.getDefault().post(new MyEvent());\n    }\n    \n}\n\npublic class B {\n    \n    @Event(to = {C.class, D.class})\n    public void sendEvent() {\n        EventBus.getDefault().post(new MyEvent());\n    }\n    \n}\n\npublic class C {\n    \n    @Event(from = {A.class, B.class})\n    public void onEventMainThread(MyEvent event) {\n        // do something\n    }\n    \n}\n\npublic class D {\n    \n    @Event(from = {A.class, B.class})\n    public void onEventMainThread(MyEvent event) {\n        // do something\n    }\n    \n}\n```\n\n从上面的代码，我们通过 @Event 注解一眼就认出来 EventBus 方法，并且还能知道 A 将事件发送到了 C 和 D，而 C 接收到的事件可能来自 A 或 B。\n\n## 5 多用 @Nullable，慎用 @NonNull   \n【@Nullable】是一个用于标注某个变量、参数或方法返回值可能为空指针的注解，当我们看到该注解的时候就要小心了，它意味着如果我们不做判空处理的话，很可能出现空指针异常，并且在 Android Studio 上会以黄色背景警告我们。那么什么时候该使用该注解呢？我的原则只要某个变量、参数或方法返回值有一丝可能性为空，就使用该注解，这起码可以避免空指针异常的出现。   \n![图1](https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/nullable.png)   \n\n@NonNull】是一个用于标注某个变量、参数和方法返回值不可能为空指针的注解，当我们看到该注解的时候，就可以认为被标记的变量、参数或方法返回值不可能为空，无需做判空处理，同事 Android Studio 也会在你进行判空处理的时候提醒你没有必要。对于这个注解，我个人的原则是除非100%肯定不会空指针，否则绝对不用。\n![图2](https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/nonnull.png)   \n\n## 6 使用 @MainThread 和 @WorkerThread   \n【@MainThread】是一个用于标注某个类或方法必须在主线程中使用的注解，当我们看到该注解的时候，就要注意当前的操作是否处于主线程，否则很有可能出错。例如我们有个方法用于更新 TextView 的内容，因为涉及到 UI 的更新操作，必须在主线程进行，所以我们可以这么写：\n\n```java\n@MainThread\npublic void updateTitle(String title) {\n    mTvTitle.setText(title);\n}\n```\n\n【@WorkerThread】是一个用于标注某个类或方法必须在子线程中使用的注解，常见的情况就是不适合在主线程中进行的耗时操作，当我们看到该注解的时候，应该创建一个子线程去使用被注解的类或方法。例如我们有个方法用于将 Bitmap 保存到 SD 卡中，涉及到 I/O 的操作理应在子线程中进行，所以我们可以这么写：\n\n```java\n@WorkerThread\npublic void saveImage(Bitmap image, String path) throw IOException {\n    FileOutputStream outputStream = new FileOutputStream(path);\n    image.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);\n}\n```\n\n## 7 使用 return 减少 if 嵌套\n当我们的方法中有一系列业务逻辑是按顺序执行，并且每一个业务逻辑的执行前提是前一个业务逻辑执行成功时，我们可以考虑使用 return 关键字在业务逻辑执行失败时终止整个方法，而不是嵌套多层的 if。例如，我们有一个返回只为 boolean 类型的方法，它只有在方法内的所有业务逻辑都按顺序执行成功之后才返回 true：\n\n```java\npublic boolean func() {\n    boolean isSuccess;\n    isSuccess = doSomething1();\n    if (isSuccess) {\n        isSuccess = doSomething2();\n        if (isSuccess) {\n            isSuccess = doSomething3();\n            if (isSuccess) {\n                isSuccess = doSomething4();\n                if (isSuccess) {\n                    isSuccess = doSomething5();\n                }\n            }\n        }\n    }\n    return isSuccess;\n}\n```\n对于这种多重 if 嵌套的代码，我们可以在某个业务逻辑执行失败的时候 return false 来终止整个方法，这样做的好处是让一看就知道里面的逻辑是从上到下按顺序执行的，更容易理解，具体写法如下：\n\n```java\npublic boolean func() {\n    boolean isSuccess;\n    isSuccess = doSomething1();\n    if (!isSuccess) {\n        return false;\n    }\n    isSuccess = doSomething2();\n    if (!isSuccess) {\n        return false;\n    }\n    isSuccess = doSomething3();\n    if (!isSuccess) {\n        return false;\n    }\n    isSuccess = doSomething4();\n    if (!isSuccess) {\n        return false;\n    }\n    isSuccess = doSomething5();\n    if (!isSuccess) {\n        return false;\n    }\n    return isSuccess;\n}\n```\n## 8 使用 Map 代替分支语句\n当我们需要使用条件语句语句根据不同的条件筛选出对应的结果，并且条件很多导致语句很长时，可以考虑使用 Map 代替冗长的条件判断，例如有一个方法需要根据用户输入的索引值返回对应的字母（我们不考虑算法），我们以下三种写法：\n\n### 1 使用 if 语句\n\n```java\npublic char getLetter(int index) {\n    if (index == 1) {\n        return \"A\";\n    } else if (index == 2) {\n        return \"B\";\n    } else if (index == 3) {\n        return \"C\";\n    } else if (index == 4) {\n        return \"D\";\n    }\n    ...\n}\b\n```\n使用 if 语句进行大量的条件筛选是最糟糕的设计，一方面代码编写麻烦，另一方面代码长度也是最长的。\n\n### 2 使用 switch 语句\n\n```java\npublic char getLetter(int index) {\n    switch (index) {\n        case 1: return \"A\";\n        case 2: return \"B\";\n        case 3: return \"C\";\n        case 4: return \"D\";\n        ...\n    }\n}\b\n```\n使用 switch 语句是最常见的方式，通过不同的 case 筛选出对应的结果，并且逻辑清晰，代码量也相对较少。\n\n### 3 使用 Map\n\n```java\nprivate static final Map<Integer, String> LETTERS = new HashMap<>();\nstatic {\n    LETTERS.put(1, \"A\");\n    LETTERS.put(2, \"B\");\n    LETTERS.put(3, \"C\");\n    LETTERS.put(4, \"D\");\n    ...\n}\npublic char getLetter(int index) {\n    return LETTERS.get(index);\n}\b\n```\n使用 Map 代替 switch 本质上没有太大的区别，但是有些时候它可以让我们省去一个方法，例如我们完全可以省去 getLetter(int) 方法而直接通过 Map 获取想要的值。\n\n\n## 9 方法调用的语法糖\n方法调用的语法糖要求一个或多个方法的调用能够形成具有良好可读性的语句，我们通过几个简单的例子看下什么样的方法调用能够形成可以阅读的语句：\n\n### 1 Android ValueAnimator 实例创建\n\n```java\nValueAnimator animator = ValueAnimator.ofInt(0, 100);\n```\n\n我们将 ValueAnimator.ofInt 拆解开来会发现它其实就是“value animator of int”，也就是“整型类型的属性动画”。\n\n### 2 Android AnimatorSet 动画播放顺序\n\n```java\nAnimatorSet animatorSet = new AnimatorSet();\nanimatorSet.play(anim1).width(anim2).before(anim3);\n```\nAnimatorSet 是一个能够将多个动画组合在一起并且指定动画播放顺序的工具类，上面的方法调用方式很清晰的告诉我们“在播放 anim3 之前先同时播放 anim1 和 anim2”。\n\n### 3 Mockito 打桩方法\n\n```java\nwhen(person.getAge()).thenReturn(20);\n```\nMockito 是一个用于单元测试的框架，这里我们不探究它的用法，我们要看的是它的方法调用形式。上面的代码同样可以拆解成“when person.getAge() then return 20”，意思就是“当调用person.getAge()方法的时候，返回20”。  \n\n## 10 使用 Builder 代替构造方法\n当某个类的构造方法有很多个参数或者有很多个重载版本时，我们应该考虑为这个类写一个 Builder，通过这个 Builder 创建配置并创建该类的实例。\n\n假设我们有个类用来代表一个矩形，它的名字叫做 Rectangle，它的代码如下所示：\n\n```java\npublic class Rectangle {\n    private int mId;\n    private int mWidth;\n    private int mHeight;\n    private int mStroke;// 边框宽度\n    \n    public Rectangle(int id) { ... }\n    \n    public Rectangle(int id, int width, int height) { ... }\n    \n    public Rectangle(int id, int width, int height, int stroke) { ... }\n}\n```\n于是我们就可能看见这样的代码 new Rectangle(1, 1, 1, 1)，这样的代码可读性是很差的，因为我们无法一眼就看出这个矩形设置了哪些信息，还需要去查阅下相关的 API 文档。此外，当我们需要创建一个只需指定 id 和 stroke 的矩形的时候，我们就必须再写一个新的构造方法，当一个对象的属性较多的时候，构造方法的重载版本就可能变得非常的多，维护成本也随之提高。如果我们为 Rectangle 创建一个 Builder，通过 Builder 创建矩形实例的过程就会变得灵活而清晰很多：\n\n```java\npublic class Rectangle {\n    private int mId;\n    private int mWidth;\n    private int mHeight;\n    private int mStroke;// 边框宽度\n    \n    private Rectangle(Builder builder) {\n        mId = builder.id;\n        mWidth = builder.width;\n        mHeight = builder.height;\n        mStroke = builder.stroke;\n    }\n    \n    public static class Builder {\n    \n        private int id;\n        private int width;\n        private int height;\n        private int stroke;// 边框宽度\n        \n        public Builder(int id) {\n            this.id = id;\n        }\n        \n        public Rectangle build() {\n            return new Rectangle(this);\n        }\n        \n        public Builder width(int width) {\n            this.width = width;\n            return this;\n        }\n        \n        public Builder height(int height) {\n            this.height = height;\n            return this;\n        }\n        \n        public Builder stroke(int stroke) {\n            this.stroke = stroke;\n            return this;\n        }\n            \n    }\n}\n```\n\n现在，我们创建 Rectangle 实例的过程就会变成下面的样子，它不仅让我们一眼就看出矩形设置了哪些属性，而且我们还可以自由组合这些属性，达到重载构造方法想要的结果：\n\n```java\n\nRectangle.Builder builder1 = new Rectangle.Builder(1);\nRectangle rect1 = builder1.width(1).height(1).stroke(1).build();\nRectangle.Builder builder2 = new Rectangle.Builder(2);\nRectangle rect2 = builder2.width(1).height(1).build();\nRectangle.Builder builder3 = new Rectangle.Builder(3);\nRectangle rect3 = builder3.stroke(1).build();\n```\n\n## 11 使用 tools 优化布局预览\n【tools】是 Android 里进行布局排版时的一个工具，它用于在布局预览的时候设置临时属性。我们经常需要一边编写布局代码一边查看预览以确保布局正确，现在假设我们有一个 TextView 用来显示标题，但是标题的内容是在运行的时候动态设置的，为了开发的时候方便预览，提高复杂布局代码的可读性，我们可能会这么写：\n\n```java\n\n<TextView\n    android:text=\"测试标题\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\" />\n``` \n\n你一定想着等后面确定布局没问题的时候再删掉测试文案，但是事实上你很有可能忘记删除，这时候我们就可以利用 tools 这样写：\n\n```java\n<TextView\n    tools:text=\"测试标题\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\" />\n```\n\n通过 tools 设置的文案只会在预览的时候生效，不会影响到实际运行的情况，这样我们可以毫无顾忌地随便填写测试文案了。tools 支持的属性还有很多，例如：\n\n```xml\ntools:background\ntools:visibility\ntools:checked\ntools:src\n```\n\n关于更多 tools 的用法，大家可以到网上查找。\n\n## 12 使用 isInEditMode() 优化布局预览\nisInEditMode() 方法是用于判断 View 当前是否处于 IDE 布局编辑（预览）状态，只有在编辑状态下才会返回 true，当我们编写只有在运行时才能看到绘制效果的自定义 View 的时候，可以使用 isInEditMode() 方法让 View 在布局预览的时候就看到运行时的大概样子。例如我们通过 View 实现一个圆形不断放大缩小的动画时，正常情况我们只有在程序运行的时候才能看到动画效果，在布局预览的时候是空白一片的，我们可以通过 isInEditMode() 方法在编辑的时候先绘制一个圆形，让开发者大概知道这个动画 View 会是什么样子，虽然它是静止的，但是也好过一片空白：\n\n```java\npublic class AnimationView extends View {\n    \n    @Override\n    public void onDraw(Canvas canvas) {\n        if (isInEditMode()) {\n            // 编辑状态下绘制一个圆形，让开发者大概知道圆形的大小。\n            canvas.drawCircle(centerX, centerY, radius, paint);\n        } else {\n            // 运行时刷新画面。\n        }\n    }  \n}\n```\n我们在布局预览的时候就会看到一个圆形被绘制出来，并且在程序正在运行的时候不会绘制该圆形：   \n![图3](https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/preview_in_edit_mode.png)\n\n>提示：实际开发中，isInEditMode() 方法可以用在 View 的任何地方用于设置预览数据。\n\n## 13 使用内部类对代码进行分类\n内部类有些时候可以起到类似包的代码分类功能，通过内部类对某个类内部的代码进行功能划分，可以让与该类相关的代码更具有可读性。\n\n例如我们有个日志打印工具类，里面有两种类型的方法，一种是打印用户可见的日志，另一种则是打印只有开发者可见的日志，我们可以这样写：\n\n```java\npublic class Logger {\n    \n    // 用户可见的日志。\n    public class User {\n        public static void d(String tag, String msg) {\n            // 打印日志\n        }\n    }\n    \n    // 开发者可见的日志。\n    public class Developer {\n        public static void d(String tag, String msg) {\n            // 打印日志\n        }\n    }\n    \n}\n```\n我们在调用日志打印方法时通过内部类的名称一眼就可以看出当前打印的日志是用户可见还是开发者可见的：\n\n```java\n\nLogger.User.d(TAG, \"打印用户可见的日志\");\nLogger.Developer.d(TAG, \"打印开发者可见的日志\");\n类似的，我们也可以使用内部类对常量进行分类，例如我们有一个多媒体数据库叫 MediaStore，其内部分为图像数据表和视频数据表，每个表都有自己的字段，我们需要定义常量来对应这些字段，所以可以这样写：\n```\n\n```java\npublic class MediaStore {\n    \n    // 图像数据表\n    public class ImageTable {\n        public static final String NAME = \"image_name\";\n        public static final String PATH = \"image_path\";\n    }\n    \n    // 视频数据表\n    public class VideoTable {\n        public static final String NAME = \"video_name\";\n        public static final String PATH = \"video_path\"; \n    }\n    \n}\n```\n我们在需要使用这些常量的时候就可以通过内部类区分不同类型的常量了：\n\n```java\nMediaStore.ImageTable.NAME// 图像名称字段\nMediaStore.VideoTable.NAME// 视频名称字段\n```\n\n\n\n\n\n\n\n\n\n","slug":"如何提高代码的可读性","published":1,"updated":"2016-12-14T08:20:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcz200174jp5y0bzd78b","content":"<p>本文转自<a href=\"https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/\" target=\"_blank\" rel=\"external\">码出未来的博客</a></p>\n<p>“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。” ，这句话出自《重构》这本书，我个人很赞同这句话，原因如下：</p>\n<ul>\n<li>代码不仅仅是人类和计算机沟通的语言，它也是建立在程序员之间的桥梁，两个程序员在沟通的时候，任何富有表达力的言语都不如直接阅读对方一段代码。</li>\n<li>代码也是公司的一笔特殊的财富，因为它不可能永远被一个程序员维护，如果代码的可读性很差的话，很可能导致这笔财富无法传承下来，前功尽弃。</li>\n<li>具有良好可读性的代码能让功能的扩展和BUG的修复更顺利，这一点应该很容易理解，增加新功能、修改某个BUG都需要你首先理解代码。</li>\n</ul>\n<p>所以，提高代码可读性是很有必要的，本文将介绍个人在实践中认为能够提高代码可读性的方法，希望对大家有所帮助。   </p>\n<h2 id=\"1-重视代码规范\"><a href=\"#1-重视代码规范\" class=\"headerlink\" title=\"1 重视代码规范\"></a>1 重视代码规范</h2><p>重视代码规范是提高代码可读性最基本和最简单的方式，每一门语言，每一个公司或组织都会有自己的代码规范，制定这些规范的目的就是为了让大家能够更容易阅读和理解代码。例如当我们看到某一个变量名称前面带有 m 前缀时，我们就知道它是一个成员变量（member）；当我们看到某个方法以 on 开头时，我们就知道它是一个回调方法；当我们看到某个变量是由大写字母和下划线组成时，我们就知道它是一个静态常量。诸如此类的规范有很多，只要我们遵循规范，我们代码的可读性起码会有一个最低的保障。</p>\n<h2 id=\"2-多写注释\"><a href=\"#2-多写注释\" class=\"headerlink\" title=\"2 多写注释\"></a>2 多写注释</h2><p>注释本应作为代码不可分割一部分，因为它是对代码最直观最详细的说明，你可以把设计思路、用法和注意事项都写在注释里面，这样无论是对你自己还是对别人都是有好处的，它让你能在很久没有接触代码的时候快速回忆起当初的想法，能让阅读源码的人更快理解你的思路，让使用的人更清楚用法。</p>\n<p>例如我们有一个设置年龄的方法叫 setAge(int age)，从方法名称上我们就可以知道它的作用，但是其内部还做了一些其他处理，这些处理是方法命无法体现的，所以加上一段注释说明就很有必要了：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 设置用户的年龄，当 age &lt; 0 的时候会设置 age = 0，当 age &gt; 100 的时候会设置 age = 100。</div><div class=\"line\"> * 另外你可以通过 &#123;<span class=\"doctag\">@link</span> #getAge()&#125; 方法获取用于的年龄。</div><div class=\"line\"> *</div><div class=\"line\"> * <span class=\"doctag\">@param</span> age 用户年龄[0, 100]</div><div class=\"line\"> * <span class=\"doctag\">@see</span> #getAge()</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        age = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &gt; <span class=\"number\">100</span>) &#123;</div><div class=\"line\">        age = <span class=\"number\">100</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-重写注释\"><a href=\"#3-重写注释\" class=\"headerlink\" title=\"3 重写注释\"></a>3 重写注释</h2><p>当我们重写某个方法并且修改了方法的逻辑导致它的行为与原有的注释描述不一致的时候，我们应该对注释也进行重写，以确保注释内容和代码逻辑一致。例如上面的提到的 setAge(int age) 方法，我们对它进行重写，改成接收任意数值的年龄，此时原有的注释内容就需要修改，因为它已经不适用于现在的逻辑：   </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 设置用户的年龄，另外你可以通过 &#123;@link #getAge()&#125; 方法获取用于的年龄。</div><div class=\"line\"> *</div><div class=\"line\"> * @param age 任意数值的用户年龄</div><div class=\"line\"> * @see #getAge()</div><div class=\"line\"> */</div><div class=\"line\">public void setAge(int age) &#123;</div><div class=\"line\">    if (age &lt; 0) &#123;</div><div class=\"line\">        age = 0;</div><div class=\"line\">    &#125; else if (age &gt; 100) &#123;</div><div class=\"line\">        age = 100;</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\">```   </div><div class=\"line\">## 4 使用注解</div><div class=\"line\">注解可以用于替换一些简短的注释描述，并且提高变量、方法和类的可读性，最典型的例子就是 @Override 注解，它告诉我们被注解的方法是对父类或者接口方法的重写或实现，相比于注释“这是一个重写方法”，注解 @Override 要更简单快捷得多。例如下面的代码我们实现了 OnClickListener 接口的 onClick(View view) 方法：   </div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">public class MyListener implements View.OnClickListener &#123;</div><div class=\"line\">    </div><div class=\"line\">    // 重写 onClick 方法。</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onClick(View view) &#123;</div><div class=\"line\">    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大多数人只会使用一些现有的注解，而很少自己创建注解，其实我们可以自己创建一些有用的注解来提高代码的可读性，下面我们以 EventBus 为例，说明自定义注解是如何提高代码可读性的。   </p>\n<p>EventBus 是一个应用在 Android 上的事件总线，我们可以使用它在任意地方发布事件，并且在任意地方注册并接收事件。EventBus 有三个弊端，一是我们经常搞不清楚某一个事件是来自哪里的，因为任何地方都可以发送同一个事件；二是我们同样也经常搞不清楚某个事件会在哪些地方被接收，因为任何地方都可以注册并接收事件；三是早期的 EventBus 事件接收方法要求你必须以 onEventXXXX 的方式命名，这样的命名其实和普通方法并没有太大的区别，我们需要一种方式让它更加凸显，以防它被误以为是普通方法而被删除。这时候我们可以利用注解让事件接收方法一眼就被认出来，并且还能看出有哪些地方会发出该事件，哪些地方会接收到我们发出的事件：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * EventBus 事件注解，用于标识某个方法是 EventBus 方法，并且注明事件</div><div class=\"line\"> * 的接收方或发送方。</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Event &#123;</div><div class=\"line\">    Class[] from() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\">    Class[] to() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在我们假设 A 和 B 都可以发送一个名叫 MyEvent 的事件到 C 和 D，我们可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Event</span>(to = &#123;C.class, D.class&#125;)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEvent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        EventBus.getDefault().post(<span class=\"keyword\">new</span> MyEvent());</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Event</span>(to = &#123;C.class, D.class&#125;)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEvent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        EventBus.getDefault().post(<span class=\"keyword\">new</span> MyEvent());</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Event</span>(from = &#123;A.class, B.class&#125;)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEventMainThread</span><span class=\"params\">(MyEvent event)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Event</span>(from = &#123;A.class, B.class&#125;)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEventMainThread</span><span class=\"params\">(MyEvent event)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的代码，我们通过 @Event 注解一眼就认出来 EventBus 方法，并且还能知道 A 将事件发送到了 C 和 D，而 C 接收到的事件可能来自 A 或 B。</p>\n<h2 id=\"5-多用-Nullable，慎用-NonNull\"><a href=\"#5-多用-Nullable，慎用-NonNull\" class=\"headerlink\" title=\"5 多用 @Nullable，慎用 @NonNull\"></a>5 多用 @Nullable，慎用 @NonNull</h2><p>【@Nullable】是一个用于标注某个变量、参数或方法返回值可能为空指针的注解，当我们看到该注解的时候就要小心了，它意味着如果我们不做判空处理的话，很可能出现空指针异常，并且在 Android Studio 上会以黄色背景警告我们。那么什么时候该使用该注解呢？我的原则只要某个变量、参数或方法返回值有一丝可能性为空，就使用该注解，这起码可以避免空指针异常的出现。<br><img src=\"https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/nullable.png\" alt=\"图1\">   </p>\n<p>@NonNull】是一个用于标注某个变量、参数和方法返回值不可能为空指针的注解，当我们看到该注解的时候，就可以认为被标记的变量、参数或方法返回值不可能为空，无需做判空处理，同事 Android Studio 也会在你进行判空处理的时候提醒你没有必要。对于这个注解，我个人的原则是除非100%肯定不会空指针，否则绝对不用。<br><img src=\"https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/nonnull.png\" alt=\"图2\">   </p>\n<h2 id=\"6-使用-MainThread-和-WorkerThread\"><a href=\"#6-使用-MainThread-和-WorkerThread\" class=\"headerlink\" title=\"6 使用 @MainThread 和 @WorkerThread\"></a>6 使用 @MainThread 和 @WorkerThread</h2><p>【@MainThread】是一个用于标注某个类或方法必须在主线程中使用的注解，当我们看到该注解的时候，就要注意当前的操作是否处于主线程，否则很有可能出错。例如我们有个方法用于更新 TextView 的内容，因为涉及到 UI 的更新操作，必须在主线程进行，所以我们可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MainThread</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateTitle</span><span class=\"params\">(String title)</span> </span>&#123;</div><div class=\"line\">    mTvTitle.setText(title);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>【@WorkerThread】是一个用于标注某个类或方法必须在子线程中使用的注解，常见的情况就是不适合在主线程中进行的耗时操作，当我们看到该注解的时候，应该创建一个子线程去使用被注解的类或方法。例如我们有个方法用于将 Bitmap 保存到 SD 卡中，涉及到 I/O 的操作理应在子线程中进行，所以我们可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@WorkerThread</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveImage</span><span class=\"params\">(Bitmap image, String path)</span> throw IOException </span>&#123;</div><div class=\"line\">    FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(path);</div><div class=\"line\">    image.compress(Bitmap.CompressFormat.JPEG, <span class=\"number\">100</span>, outputStream);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"7-使用-return-减少-if-嵌套\"><a href=\"#7-使用-return-减少-if-嵌套\" class=\"headerlink\" title=\"7 使用 return 减少 if 嵌套\"></a>7 使用 return 减少 if 嵌套</h2><p>当我们的方法中有一系列业务逻辑是按顺序执行，并且每一个业务逻辑的执行前提是前一个业务逻辑执行成功时，我们可以考虑使用 return 关键字在业务逻辑执行失败时终止整个方法，而不是嵌套多层的 if。例如，我们有一个返回只为 boolean 类型的方法，它只有在方法内的所有业务逻辑都按顺序执行成功之后才返回 true：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> isSuccess;</div><div class=\"line\">    isSuccess = doSomething1();</div><div class=\"line\">    <span class=\"keyword\">if</span> (isSuccess) &#123;</div><div class=\"line\">        isSuccess = doSomething2();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isSuccess) &#123;</div><div class=\"line\">            isSuccess = doSomething3();</div><div class=\"line\">            <span class=\"keyword\">if</span> (isSuccess) &#123;</div><div class=\"line\">                isSuccess = doSomething4();</div><div class=\"line\">                <span class=\"keyword\">if</span> (isSuccess) &#123;</div><div class=\"line\">                    isSuccess = doSomething5();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> isSuccess;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于这种多重 if 嵌套的代码，我们可以在某个业务逻辑执行失败的时候 return false 来终止整个方法，这样做的好处是让一看就知道里面的逻辑是从上到下按顺序执行的，更容易理解，具体写法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> isSuccess;</div><div class=\"line\">    isSuccess = doSomething1();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isSuccess = doSomething2();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isSuccess = doSomething3();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isSuccess = doSomething4();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isSuccess = doSomething5();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> isSuccess;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"8-使用-Map-代替分支语句\"><a href=\"#8-使用-Map-代替分支语句\" class=\"headerlink\" title=\"8 使用 Map 代替分支语句\"></a>8 使用 Map 代替分支语句</h2><p>当我们需要使用条件语句语句根据不同的条件筛选出对应的结果，并且条件很多导致语句很长时，可以考虑使用 Map 代替冗长的条件判断，例如有一个方法需要根据用户输入的索引值返回对应的字母（我们不考虑算法），我们以下三种写法：</p>\n<h3 id=\"1-使用-if-语句\"><a href=\"#1-使用-if-语句\" class=\"headerlink\" title=\"1 使用 if 语句\"></a>1 使用 if 语句</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">getLetter</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (index == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index == <span class=\"number\">3</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index == <span class=\"number\">4</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"D\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;\b</div></pre></td></tr></table></figure>\n<p>使用 if 语句进行大量的条件筛选是最糟糕的设计，一方面代码编写麻烦，另一方面代码长度也是最长的。</p>\n<h3 id=\"2-使用-switch-语句\"><a href=\"#2-使用-switch-语句\" class=\"headerlink\" title=\"2 使用 switch 语句\"></a>2 使用 switch 语句</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">getLetter</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (index) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"D\"</span>;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;\b</div></pre></td></tr></table></figure>\n<p>使用 switch 语句是最常见的方式，通过不同的 case 筛选出对应的结果，并且逻辑清晰，代码量也相对较少。</p>\n<h3 id=\"3-使用-Map\"><a href=\"#3-使用-Map\" class=\"headerlink\" title=\"3 使用 Map\"></a>3 使用 Map</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Integer, String&gt; LETTERS = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"><span class=\"keyword\">static</span> &#123;</div><div class=\"line\">    LETTERS.put(<span class=\"number\">1</span>, <span class=\"string\">\"A\"</span>);</div><div class=\"line\">    LETTERS.put(<span class=\"number\">2</span>, <span class=\"string\">\"B\"</span>);</div><div class=\"line\">    LETTERS.put(<span class=\"number\">3</span>, <span class=\"string\">\"C\"</span>);</div><div class=\"line\">    LETTERS.put(<span class=\"number\">4</span>, <span class=\"string\">\"D\"</span>);</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">getLetter</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> LETTERS.get(index);</div><div class=\"line\">&#125;\b</div></pre></td></tr></table></figure>\n<p>使用 Map 代替 switch 本质上没有太大的区别，但是有些时候它可以让我们省去一个方法，例如我们完全可以省去 getLetter(int) 方法而直接通过 Map 获取想要的值。</p>\n<h2 id=\"9-方法调用的语法糖\"><a href=\"#9-方法调用的语法糖\" class=\"headerlink\" title=\"9 方法调用的语法糖\"></a>9 方法调用的语法糖</h2><p>方法调用的语法糖要求一个或多个方法的调用能够形成具有良好可读性的语句，我们通过几个简单的例子看下什么样的方法调用能够形成可以阅读的语句：</p>\n<h3 id=\"1-Android-ValueAnimator-实例创建\"><a href=\"#1-Android-ValueAnimator-实例创建\" class=\"headerlink\" title=\"1 Android ValueAnimator 实例创建\"></a>1 Android ValueAnimator 实例创建</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ValueAnimator animator = ValueAnimator.ofInt(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<p>我们将 ValueAnimator.ofInt 拆解开来会发现它其实就是“value animator of int”，也就是“整型类型的属性动画”。</p>\n<h3 id=\"2-Android-AnimatorSet-动画播放顺序\"><a href=\"#2-Android-AnimatorSet-动画播放顺序\" class=\"headerlink\" title=\"2 Android AnimatorSet 动画播放顺序\"></a>2 Android AnimatorSet 动画播放顺序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AnimatorSet animatorSet = <span class=\"keyword\">new</span> AnimatorSet();</div><div class=\"line\">animatorSet.play(anim1).width(anim2).before(anim3);</div></pre></td></tr></table></figure>\n<p>AnimatorSet 是一个能够将多个动画组合在一起并且指定动画播放顺序的工具类，上面的方法调用方式很清晰的告诉我们“在播放 anim3 之前先同时播放 anim1 和 anim2”。</p>\n<h3 id=\"3-Mockito-打桩方法\"><a href=\"#3-Mockito-打桩方法\" class=\"headerlink\" title=\"3 Mockito 打桩方法\"></a>3 Mockito 打桩方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">when(person.getAge()).thenReturn(<span class=\"number\">20</span>);</div></pre></td></tr></table></figure>\n<p>Mockito 是一个用于单元测试的框架，这里我们不探究它的用法，我们要看的是它的方法调用形式。上面的代码同样可以拆解成“when person.getAge() then return 20”，意思就是“当调用person.getAge()方法的时候，返回20”。  </p>\n<h2 id=\"10-使用-Builder-代替构造方法\"><a href=\"#10-使用-Builder-代替构造方法\" class=\"headerlink\" title=\"10 使用 Builder 代替构造方法\"></a>10 使用 Builder 代替构造方法</h2><p>当某个类的构造方法有很多个参数或者有很多个重载版本时，我们应该考虑为这个类写一个 Builder，通过这个 Builder 创建配置并创建该类的实例。</p>\n<p>假设我们有个类用来代表一个矩形，它的名字叫做 Rectangle，它的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mId;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWidth;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mHeight;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mStroke;<span class=\"comment\">// 边框宽度</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123; ... &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123; ... &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, <span class=\"keyword\">int</span> stroke)</span> </span>&#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>于是我们就可能看见这样的代码 new Rectangle(1, 1, 1, 1)，这样的代码可读性是很差的，因为我们无法一眼就看出这个矩形设置了哪些信息，还需要去查阅下相关的 API 文档。此外，当我们需要创建一个只需指定 id 和 stroke 的矩形的时候，我们就必须再写一个新的构造方法，当一个对象的属性较多的时候，构造方法的重载版本就可能变得非常的多，维护成本也随之提高。如果我们为 Rectangle 创建一个 Builder，通过 Builder 创建矩形实例的过程就会变得灵活而清晰很多：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mId;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWidth;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mHeight;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mStroke;<span class=\"comment\">// 边框宽度</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Rectangle</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">        mId = builder.id;</div><div class=\"line\">        mWidth = builder.width;</div><div class=\"line\">        mHeight = builder.height;</div><div class=\"line\">        mStroke = builder.stroke;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> width;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> height;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> stroke;<span class=\"comment\">// 边框宽度</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Rectangle <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Rectangle(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">width</span><span class=\"params\">(<span class=\"keyword\">int</span> width)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.width = width;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">height</span><span class=\"params\">(<span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.height = height;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">stroke</span><span class=\"params\">(<span class=\"keyword\">int</span> stroke)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.stroke = stroke;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">            </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，我们创建 Rectangle 实例的过程就会变成下面的样子，它不仅让我们一眼就看出矩形设置了哪些属性，而且我们还可以自由组合这些属性，达到重载构造方法想要的结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Rectangle.Builder builder1 = <span class=\"keyword\">new</span> Rectangle.Builder(<span class=\"number\">1</span>);</div><div class=\"line\">Rectangle rect1 = builder1.width(<span class=\"number\">1</span>).height(<span class=\"number\">1</span>).stroke(<span class=\"number\">1</span>).build();</div><div class=\"line\">Rectangle.Builder builder2 = <span class=\"keyword\">new</span> Rectangle.Builder(<span class=\"number\">2</span>);</div><div class=\"line\">Rectangle rect2 = builder2.width(<span class=\"number\">1</span>).height(<span class=\"number\">1</span>).build();</div><div class=\"line\">Rectangle.Builder builder3 = <span class=\"keyword\">new</span> Rectangle.Builder(<span class=\"number\">3</span>);</div><div class=\"line\">Rectangle rect3 = builder3.stroke(<span class=\"number\">1</span>).build();</div></pre></td></tr></table></figure>\n<h2 id=\"11-使用-tools-优化布局预览\"><a href=\"#11-使用-tools-优化布局预览\" class=\"headerlink\" title=\"11 使用 tools 优化布局预览\"></a>11 使用 tools 优化布局预览</h2><p>【tools】是 Android 里进行布局排版时的一个工具，它用于在布局预览的时候设置临时属性。我们经常需要一边编写布局代码一边查看预览以确保布局正确，现在假设我们有一个 TextView 用来显示标题，但是标题的内容是在运行的时候动态设置的，为了开发的时候方便预览，提高复杂布局代码的可读性，我们可能会这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&lt;TextView</div><div class=\"line\">    android:text=<span class=\"string\">\"测试标题\"</span></div><div class=\"line\">    android:layout_width=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">    android:layout_height=<span class=\"string\">\"wrap_content\"</span> /&gt;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">你一定想着等后面确定布局没问题的时候再删掉测试文案，但是事实上你很有可能忘记删除，这时候我们就可以利用 tools 这样写：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">&lt;TextView</div><div class=\"line\">    tools:text=<span class=\"string\">\"测试标题\"</span></div><div class=\"line\">    android:layout_width=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">    android:layout_height=<span class=\"string\">\"wrap_content\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>通过 tools 设置的文案只会在预览的时候生效，不会影响到实际运行的情况，这样我们可以毫无顾忌地随便填写测试文案了。tools 支持的属性还有很多，例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">tools:background</div><div class=\"line\">tools:visibility</div><div class=\"line\">tools:checked</div><div class=\"line\">tools:src</div></pre></td></tr></table></figure>\n<p>关于更多 tools 的用法，大家可以到网上查找。</p>\n<h2 id=\"12-使用-isInEditMode-优化布局预览\"><a href=\"#12-使用-isInEditMode-优化布局预览\" class=\"headerlink\" title=\"12 使用 isInEditMode() 优化布局预览\"></a>12 使用 isInEditMode() 优化布局预览</h2><p>isInEditMode() 方法是用于判断 View 当前是否处于 IDE 布局编辑（预览）状态，只有在编辑状态下才会返回 true，当我们编写只有在运行时才能看到绘制效果的自定义 View 的时候，可以使用 isInEditMode() 方法让 View 在布局预览的时候就看到运行时的大概样子。例如我们通过 View 实现一个圆形不断放大缩小的动画时，正常情况我们只有在程序运行的时候才能看到动画效果，在布局预览的时候是空白一片的，我们可以通过 isInEditMode() 方法在编辑的时候先绘制一个圆形，让开发者大概知道这个动画 View 会是什么样子，虽然它是静止的，但是也好过一片空白：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnimationView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (isInEditMode()) &#123;</div><div class=\"line\">            <span class=\"comment\">// 编辑状态下绘制一个圆形，让开发者大概知道圆形的大小。</span></div><div class=\"line\">            canvas.drawCircle(centerX, centerY, radius, paint);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 运行时刷新画面。</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在布局预览的时候就会看到一个圆形被绘制出来，并且在程序正在运行的时候不会绘制该圆形：<br><img src=\"https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/preview_in_edit_mode.png\" alt=\"图3\"></p>\n<blockquote>\n<p>提示：实际开发中，isInEditMode() 方法可以用在 View 的任何地方用于设置预览数据。</p>\n</blockquote>\n<h2 id=\"13-使用内部类对代码进行分类\"><a href=\"#13-使用内部类对代码进行分类\" class=\"headerlink\" title=\"13 使用内部类对代码进行分类\"></a>13 使用内部类对代码进行分类</h2><p>内部类有些时候可以起到类似包的代码分类功能，通过内部类对某个类内部的代码进行功能划分，可以让与该类相关的代码更具有可读性。</p>\n<p>例如我们有个日志打印工具类，里面有两种类型的方法，一种是打印用户可见的日志，另一种则是打印只有开发者可见的日志，我们可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 用户可见的日志。</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">d</span><span class=\"params\">(String tag, String msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 打印日志</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 开发者可见的日志。</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Developer</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">d</span><span class=\"params\">(String tag, String msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 打印日志</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在调用日志打印方法时通过内部类的名称一眼就可以看出当前打印的日志是用户可见还是开发者可见的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Logger.User.d(TAG, <span class=\"string\">\"打印用户可见的日志\"</span>);</div><div class=\"line\">Logger.Developer.d(TAG, <span class=\"string\">\"打印开发者可见的日志\"</span>);</div><div class=\"line\">类似的，我们也可以使用内部类对常量进行分类，例如我们有一个多媒体数据库叫 MediaStore，其内部分为图像数据表和视频数据表，每个表都有自己的字段，我们需要定义常量来对应这些字段，所以可以这样写：</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MediaStore</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 图像数据表</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageTable</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"image_name\"</span>;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PATH = <span class=\"string\">\"image_path\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 视频数据表</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VideoTable</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"video_name\"</span>;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PATH = <span class=\"string\">\"video_path\"</span>; </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在需要使用这些常量的时候就可以通过内部类区分不同类型的常量了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">MediaStore.ImageTable.NAME<span class=\"comment\">// 图像名称字段</span></div><div class=\"line\">MediaStore.VideoTable.NAME<span class=\"comment\">// 视频名称字段</span></div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>本文转自<a href=\"https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/\">码出未来的博客</a></p>\n<p>“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。” ，这句话出自《重构》这本书，我个人很赞同这句话，原因如下：</p>\n<ul>\n<li>代码不仅仅是人类和计算机沟通的语言，它也是建立在程序员之间的桥梁，两个程序员在沟通的时候，任何富有表达力的言语都不如直接阅读对方一段代码。</li>\n<li>代码也是公司的一笔特殊的财富，因为它不可能永远被一个程序员维护，如果代码的可读性很差的话，很可能导致这笔财富无法传承下来，前功尽弃。</li>\n<li>具有良好可读性的代码能让功能的扩展和BUG的修复更顺利，这一点应该很容易理解，增加新功能、修改某个BUG都需要你首先理解代码。</li>\n</ul>\n<p>所以，提高代码可读性是很有必要的，本文将介绍个人在实践中认为能够提高代码可读性的方法，希望对大家有所帮助。   </p>\n<h2 id=\"1-重视代码规范\"><a href=\"#1-重视代码规范\" class=\"headerlink\" title=\"1 重视代码规范\"></a>1 重视代码规范</h2><p>重视代码规范是提高代码可读性最基本和最简单的方式，每一门语言，每一个公司或组织都会有自己的代码规范，制定这些规范的目的就是为了让大家能够更容易阅读和理解代码。例如当我们看到某一个变量名称前面带有 m 前缀时，我们就知道它是一个成员变量（member）；当我们看到某个方法以 on 开头时，我们就知道它是一个回调方法；当我们看到某个变量是由大写字母和下划线组成时，我们就知道它是一个静态常量。诸如此类的规范有很多，只要我们遵循规范，我们代码的可读性起码会有一个最低的保障。</p>\n<h2 id=\"2-多写注释\"><a href=\"#2-多写注释\" class=\"headerlink\" title=\"2 多写注释\"></a>2 多写注释</h2><p>注释本应作为代码不可分割一部分，因为它是对代码最直观最详细的说明，你可以把设计思路、用法和注意事项都写在注释里面，这样无论是对你自己还是对别人都是有好处的，它让你能在很久没有接触代码的时候快速回忆起当初的想法，能让阅读源码的人更快理解你的思路，让使用的人更清楚用法。</p>\n<p>例如我们有一个设置年龄的方法叫 setAge(int age)，从方法名称上我们就可以知道它的作用，但是其内部还做了一些其他处理，这些处理是方法命无法体现的，所以加上一段注释说明就很有必要了：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 设置用户的年龄，当 age &lt; 0 的时候会设置 age = 0，当 age &gt; 100 的时候会设置 age = 100。</div><div class=\"line\"> * 另外你可以通过 &#123;<span class=\"doctag\">@link</span> #getAge()&#125; 方法获取用于的年龄。</div><div class=\"line\"> *</div><div class=\"line\"> * <span class=\"doctag\">@param</span> age 用户年龄[0, 100]</div><div class=\"line\"> * <span class=\"doctag\">@see</span> #getAge()</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        age = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (age &gt; <span class=\"number\">100</span>) &#123;</div><div class=\"line\">        age = <span class=\"number\">100</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-重写注释\"><a href=\"#3-重写注释\" class=\"headerlink\" title=\"3 重写注释\"></a>3 重写注释</h2><p>当我们重写某个方法并且修改了方法的逻辑导致它的行为与原有的注释描述不一致的时候，我们应该对注释也进行重写，以确保注释内容和代码逻辑一致。例如上面的提到的 setAge(int age) 方法，我们对它进行重写，改成接收任意数值的年龄，此时原有的注释内容就需要修改，因为它已经不适用于现在的逻辑：   </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 设置用户的年龄，另外你可以通过 &#123;@link #getAge()&#125; 方法获取用于的年龄。</div><div class=\"line\"> *</div><div class=\"line\"> * @param age 任意数值的用户年龄</div><div class=\"line\"> * @see #getAge()</div><div class=\"line\"> */</div><div class=\"line\">public void setAge(int age) &#123;</div><div class=\"line\">    if (age &lt; 0) &#123;</div><div class=\"line\">        age = 0;</div><div class=\"line\">    &#125; else if (age &gt; 100) &#123;</div><div class=\"line\">        age = 100;</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\">```   </div><div class=\"line\">## 4 使用注解</div><div class=\"line\">注解可以用于替换一些简短的注释描述，并且提高变量、方法和类的可读性，最典型的例子就是 @Override 注解，它告诉我们被注解的方法是对父类或者接口方法的重写或实现，相比于注释“这是一个重写方法”，注解 @Override 要更简单快捷得多。例如下面的代码我们实现了 OnClickListener 接口的 onClick(View view) 方法：   </div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">public class MyListener implements View.OnClickListener &#123;</div><div class=\"line\">    </div><div class=\"line\">    // 重写 onClick 方法。</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onClick(View view) &#123;</div><div class=\"line\">    </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大多数人只会使用一些现有的注解，而很少自己创建注解，其实我们可以自己创建一些有用的注解来提高代码的可读性，下面我们以 EventBus 为例，说明自定义注解是如何提高代码可读性的。   </p>\n<p>EventBus 是一个应用在 Android 上的事件总线，我们可以使用它在任意地方发布事件，并且在任意地方注册并接收事件。EventBus 有三个弊端，一是我们经常搞不清楚某一个事件是来自哪里的，因为任何地方都可以发送同一个事件；二是我们同样也经常搞不清楚某个事件会在哪些地方被接收，因为任何地方都可以注册并接收事件；三是早期的 EventBus 事件接收方法要求你必须以 onEventXXXX 的方式命名，这样的命名其实和普通方法并没有太大的区别，我们需要一种方式让它更加凸显，以防它被误以为是普通方法而被删除。这时候我们可以利用注解让事件接收方法一眼就被认出来，并且还能看出有哪些地方会发出该事件，哪些地方会接收到我们发出的事件：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * EventBus 事件注解，用于标识某个方法是 EventBus 方法，并且注明事件</div><div class=\"line\"> * 的接收方或发送方。</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</div><div class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.SOURCE)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Event &#123;</div><div class=\"line\">    Class[] from() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\">    Class[] to() <span class=\"keyword\">default</span> &#123;&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在我们假设 A 和 B 都可以发送一个名叫 MyEvent 的事件到 C 和 D，我们可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Event</span>(to = &#123;C.class, D.class&#125;)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEvent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        EventBus.getDefault().post(<span class=\"keyword\">new</span> MyEvent());</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Event</span>(to = &#123;C.class, D.class&#125;)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEvent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        EventBus.getDefault().post(<span class=\"keyword\">new</span> MyEvent());</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Event</span>(from = &#123;A.class, B.class&#125;)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEventMainThread</span><span class=\"params\">(MyEvent event)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Event</span>(from = &#123;A.class, B.class&#125;)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEventMainThread</span><span class=\"params\">(MyEvent event)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的代码，我们通过 @Event 注解一眼就认出来 EventBus 方法，并且还能知道 A 将事件发送到了 C 和 D，而 C 接收到的事件可能来自 A 或 B。</p>\n<h2 id=\"5-多用-Nullable，慎用-NonNull\"><a href=\"#5-多用-Nullable，慎用-NonNull\" class=\"headerlink\" title=\"5 多用 @Nullable，慎用 @NonNull\"></a>5 多用 @Nullable，慎用 @NonNull</h2><p>【@Nullable】是一个用于标注某个变量、参数或方法返回值可能为空指针的注解，当我们看到该注解的时候就要小心了，它意味着如果我们不做判空处理的话，很可能出现空指针异常，并且在 Android Studio 上会以黄色背景警告我们。那么什么时候该使用该注解呢？我的原则只要某个变量、参数或方法返回值有一丝可能性为空，就使用该注解，这起码可以避免空指针异常的出现。<br><img src=\"https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/nullable.png\" alt=\"图1\">   </p>\n<p>@NonNull】是一个用于标注某个变量、参数和方法返回值不可能为空指针的注解，当我们看到该注解的时候，就可以认为被标记的变量、参数或方法返回值不可能为空，无需做判空处理，同事 Android Studio 也会在你进行判空处理的时候提醒你没有必要。对于这个注解，我个人的原则是除非100%肯定不会空指针，否则绝对不用。<br><img src=\"https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/nonnull.png\" alt=\"图2\">   </p>\n<h2 id=\"6-使用-MainThread-和-WorkerThread\"><a href=\"#6-使用-MainThread-和-WorkerThread\" class=\"headerlink\" title=\"6 使用 @MainThread 和 @WorkerThread\"></a>6 使用 @MainThread 和 @WorkerThread</h2><p>【@MainThread】是一个用于标注某个类或方法必须在主线程中使用的注解，当我们看到该注解的时候，就要注意当前的操作是否处于主线程，否则很有可能出错。例如我们有个方法用于更新 TextView 的内容，因为涉及到 UI 的更新操作，必须在主线程进行，所以我们可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MainThread</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateTitle</span><span class=\"params\">(String title)</span> </span>&#123;</div><div class=\"line\">    mTvTitle.setText(title);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>【@WorkerThread】是一个用于标注某个类或方法必须在子线程中使用的注解，常见的情况就是不适合在主线程中进行的耗时操作，当我们看到该注解的时候，应该创建一个子线程去使用被注解的类或方法。例如我们有个方法用于将 Bitmap 保存到 SD 卡中，涉及到 I/O 的操作理应在子线程中进行，所以我们可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@WorkerThread</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">saveImage</span><span class=\"params\">(Bitmap image, String path)</span> throw IOException </span>&#123;</div><div class=\"line\">    FileOutputStream outputStream = <span class=\"keyword\">new</span> FileOutputStream(path);</div><div class=\"line\">    image.compress(Bitmap.CompressFormat.JPEG, <span class=\"number\">100</span>, outputStream);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"7-使用-return-减少-if-嵌套\"><a href=\"#7-使用-return-减少-if-嵌套\" class=\"headerlink\" title=\"7 使用 return 减少 if 嵌套\"></a>7 使用 return 减少 if 嵌套</h2><p>当我们的方法中有一系列业务逻辑是按顺序执行，并且每一个业务逻辑的执行前提是前一个业务逻辑执行成功时，我们可以考虑使用 return 关键字在业务逻辑执行失败时终止整个方法，而不是嵌套多层的 if。例如，我们有一个返回只为 boolean 类型的方法，它只有在方法内的所有业务逻辑都按顺序执行成功之后才返回 true：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> isSuccess;</div><div class=\"line\">    isSuccess = doSomething1();</div><div class=\"line\">    <span class=\"keyword\">if</span> (isSuccess) &#123;</div><div class=\"line\">        isSuccess = doSomething2();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isSuccess) &#123;</div><div class=\"line\">            isSuccess = doSomething3();</div><div class=\"line\">            <span class=\"keyword\">if</span> (isSuccess) &#123;</div><div class=\"line\">                isSuccess = doSomething4();</div><div class=\"line\">                <span class=\"keyword\">if</span> (isSuccess) &#123;</div><div class=\"line\">                    isSuccess = doSomething5();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> isSuccess;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于这种多重 if 嵌套的代码，我们可以在某个业务逻辑执行失败的时候 return false 来终止整个方法，这样做的好处是让一看就知道里面的逻辑是从上到下按顺序执行的，更容易理解，具体写法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> isSuccess;</div><div class=\"line\">    isSuccess = doSomething1();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isSuccess = doSomething2();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isSuccess = doSomething3();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isSuccess = doSomething4();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isSuccess = doSomething5();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isSuccess) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> isSuccess;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"8-使用-Map-代替分支语句\"><a href=\"#8-使用-Map-代替分支语句\" class=\"headerlink\" title=\"8 使用 Map 代替分支语句\"></a>8 使用 Map 代替分支语句</h2><p>当我们需要使用条件语句语句根据不同的条件筛选出对应的结果，并且条件很多导致语句很长时，可以考虑使用 Map 代替冗长的条件判断，例如有一个方法需要根据用户输入的索引值返回对应的字母（我们不考虑算法），我们以下三种写法：</p>\n<h3 id=\"1-使用-if-语句\"><a href=\"#1-使用-if-语句\" class=\"headerlink\" title=\"1 使用 if 语句\"></a>1 使用 if 语句</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">getLetter</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (index == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index == <span class=\"number\">3</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index == <span class=\"number\">4</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"D\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;\b</div></pre></td></tr></table></figure>\n<p>使用 if 语句进行大量的条件筛选是最糟糕的设计，一方面代码编写麻烦，另一方面代码长度也是最长的。</p>\n<h3 id=\"2-使用-switch-语句\"><a href=\"#2-使用-switch-语句\" class=\"headerlink\" title=\"2 使用 switch 语句\"></a>2 使用 switch 语句</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">getLetter</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (index) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"A\"</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"B\"</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"C\"</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"D\"</span>;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;\b</div></pre></td></tr></table></figure>\n<p>使用 switch 语句是最常见的方式，通过不同的 case 筛选出对应的结果，并且逻辑清晰，代码量也相对较少。</p>\n<h3 id=\"3-使用-Map\"><a href=\"#3-使用-Map\" class=\"headerlink\" title=\"3 使用 Map\"></a>3 使用 Map</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Integer, String&gt; LETTERS = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"><span class=\"keyword\">static</span> &#123;</div><div class=\"line\">    LETTERS.put(<span class=\"number\">1</span>, <span class=\"string\">\"A\"</span>);</div><div class=\"line\">    LETTERS.put(<span class=\"number\">2</span>, <span class=\"string\">\"B\"</span>);</div><div class=\"line\">    LETTERS.put(<span class=\"number\">3</span>, <span class=\"string\">\"C\"</span>);</div><div class=\"line\">    LETTERS.put(<span class=\"number\">4</span>, <span class=\"string\">\"D\"</span>);</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">getLetter</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> LETTERS.get(index);</div><div class=\"line\">&#125;\b</div></pre></td></tr></table></figure>\n<p>使用 Map 代替 switch 本质上没有太大的区别，但是有些时候它可以让我们省去一个方法，例如我们完全可以省去 getLetter(int) 方法而直接通过 Map 获取想要的值。</p>\n<h2 id=\"9-方法调用的语法糖\"><a href=\"#9-方法调用的语法糖\" class=\"headerlink\" title=\"9 方法调用的语法糖\"></a>9 方法调用的语法糖</h2><p>方法调用的语法糖要求一个或多个方法的调用能够形成具有良好可读性的语句，我们通过几个简单的例子看下什么样的方法调用能够形成可以阅读的语句：</p>\n<h3 id=\"1-Android-ValueAnimator-实例创建\"><a href=\"#1-Android-ValueAnimator-实例创建\" class=\"headerlink\" title=\"1 Android ValueAnimator 实例创建\"></a>1 Android ValueAnimator 实例创建</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ValueAnimator animator = ValueAnimator.ofInt(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<p>我们将 ValueAnimator.ofInt 拆解开来会发现它其实就是“value animator of int”，也就是“整型类型的属性动画”。</p>\n<h3 id=\"2-Android-AnimatorSet-动画播放顺序\"><a href=\"#2-Android-AnimatorSet-动画播放顺序\" class=\"headerlink\" title=\"2 Android AnimatorSet 动画播放顺序\"></a>2 Android AnimatorSet 动画播放顺序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AnimatorSet animatorSet = <span class=\"keyword\">new</span> AnimatorSet();</div><div class=\"line\">animatorSet.play(anim1).width(anim2).before(anim3);</div></pre></td></tr></table></figure>\n<p>AnimatorSet 是一个能够将多个动画组合在一起并且指定动画播放顺序的工具类，上面的方法调用方式很清晰的告诉我们“在播放 anim3 之前先同时播放 anim1 和 anim2”。</p>\n<h3 id=\"3-Mockito-打桩方法\"><a href=\"#3-Mockito-打桩方法\" class=\"headerlink\" title=\"3 Mockito 打桩方法\"></a>3 Mockito 打桩方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">when(person.getAge()).thenReturn(<span class=\"number\">20</span>);</div></pre></td></tr></table></figure>\n<p>Mockito 是一个用于单元测试的框架，这里我们不探究它的用法，我们要看的是它的方法调用形式。上面的代码同样可以拆解成“when person.getAge() then return 20”，意思就是“当调用person.getAge()方法的时候，返回20”。  </p>\n<h2 id=\"10-使用-Builder-代替构造方法\"><a href=\"#10-使用-Builder-代替构造方法\" class=\"headerlink\" title=\"10 使用 Builder 代替构造方法\"></a>10 使用 Builder 代替构造方法</h2><p>当某个类的构造方法有很多个参数或者有很多个重载版本时，我们应该考虑为这个类写一个 Builder，通过这个 Builder 创建配置并创建该类的实例。</p>\n<p>假设我们有个类用来代表一个矩形，它的名字叫做 Rectangle，它的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mId;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWidth;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mHeight;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mStroke;<span class=\"comment\">// 边框宽度</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123; ... &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123; ... &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Rectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, <span class=\"keyword\">int</span> stroke)</span> </span>&#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>于是我们就可能看见这样的代码 new Rectangle(1, 1, 1, 1)，这样的代码可读性是很差的，因为我们无法一眼就看出这个矩形设置了哪些信息，还需要去查阅下相关的 API 文档。此外，当我们需要创建一个只需指定 id 和 stroke 的矩形的时候，我们就必须再写一个新的构造方法，当一个对象的属性较多的时候，构造方法的重载版本就可能变得非常的多，维护成本也随之提高。如果我们为 Rectangle 创建一个 Builder，通过 Builder 创建矩形实例的过程就会变得灵活而清晰很多：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mId;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWidth;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mHeight;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mStroke;<span class=\"comment\">// 边框宽度</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Rectangle</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">        mId = builder.id;</div><div class=\"line\">        mWidth = builder.width;</div><div class=\"line\">        mHeight = builder.height;</div><div class=\"line\">        mStroke = builder.stroke;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> width;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> height;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> stroke;<span class=\"comment\">// 边框宽度</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Rectangle <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Rectangle(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">width</span><span class=\"params\">(<span class=\"keyword\">int</span> width)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.width = width;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">height</span><span class=\"params\">(<span class=\"keyword\">int</span> height)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.height = height;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">stroke</span><span class=\"params\">(<span class=\"keyword\">int</span> stroke)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.stroke = stroke;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">            </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，我们创建 Rectangle 实例的过程就会变成下面的样子，它不仅让我们一眼就看出矩形设置了哪些属性，而且我们还可以自由组合这些属性，达到重载构造方法想要的结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Rectangle.Builder builder1 = <span class=\"keyword\">new</span> Rectangle.Builder(<span class=\"number\">1</span>);</div><div class=\"line\">Rectangle rect1 = builder1.width(<span class=\"number\">1</span>).height(<span class=\"number\">1</span>).stroke(<span class=\"number\">1</span>).build();</div><div class=\"line\">Rectangle.Builder builder2 = <span class=\"keyword\">new</span> Rectangle.Builder(<span class=\"number\">2</span>);</div><div class=\"line\">Rectangle rect2 = builder2.width(<span class=\"number\">1</span>).height(<span class=\"number\">1</span>).build();</div><div class=\"line\">Rectangle.Builder builder3 = <span class=\"keyword\">new</span> Rectangle.Builder(<span class=\"number\">3</span>);</div><div class=\"line\">Rectangle rect3 = builder3.stroke(<span class=\"number\">1</span>).build();</div></pre></td></tr></table></figure>\n<h2 id=\"11-使用-tools-优化布局预览\"><a href=\"#11-使用-tools-优化布局预览\" class=\"headerlink\" title=\"11 使用 tools 优化布局预览\"></a>11 使用 tools 优化布局预览</h2><p>【tools】是 Android 里进行布局排版时的一个工具，它用于在布局预览的时候设置临时属性。我们经常需要一边编写布局代码一边查看预览以确保布局正确，现在假设我们有一个 TextView 用来显示标题，但是标题的内容是在运行的时候动态设置的，为了开发的时候方便预览，提高复杂布局代码的可读性，我们可能会这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&lt;TextView</div><div class=\"line\">    android:text=<span class=\"string\">\"测试标题\"</span></div><div class=\"line\">    android:layout_width=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">    android:layout_height=<span class=\"string\">\"wrap_content\"</span> /&gt;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">你一定想着等后面确定布局没问题的时候再删掉测试文案，但是事实上你很有可能忘记删除，这时候我们就可以利用 tools 这样写：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">&lt;TextView</div><div class=\"line\">    tools:text=<span class=\"string\">\"测试标题\"</span></div><div class=\"line\">    android:layout_width=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">    android:layout_height=<span class=\"string\">\"wrap_content\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>通过 tools 设置的文案只会在预览的时候生效，不会影响到实际运行的情况，这样我们可以毫无顾忌地随便填写测试文案了。tools 支持的属性还有很多，例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">tools:background</div><div class=\"line\">tools:visibility</div><div class=\"line\">tools:checked</div><div class=\"line\">tools:src</div></pre></td></tr></table></figure>\n<p>关于更多 tools 的用法，大家可以到网上查找。</p>\n<h2 id=\"12-使用-isInEditMode-优化布局预览\"><a href=\"#12-使用-isInEditMode-优化布局预览\" class=\"headerlink\" title=\"12 使用 isInEditMode() 优化布局预览\"></a>12 使用 isInEditMode() 优化布局预览</h2><p>isInEditMode() 方法是用于判断 View 当前是否处于 IDE 布局编辑（预览）状态，只有在编辑状态下才会返回 true，当我们编写只有在运行时才能看到绘制效果的自定义 View 的时候，可以使用 isInEditMode() 方法让 View 在布局预览的时候就看到运行时的大概样子。例如我们通过 View 实现一个圆形不断放大缩小的动画时，正常情况我们只有在程序运行的时候才能看到动画效果，在布局预览的时候是空白一片的，我们可以通过 isInEditMode() 方法在编辑的时候先绘制一个圆形，让开发者大概知道这个动画 View 会是什么样子，虽然它是静止的，但是也好过一片空白：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnimationView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (isInEditMode()) &#123;</div><div class=\"line\">            <span class=\"comment\">// 编辑状态下绘制一个圆形，让开发者大概知道圆形的大小。</span></div><div class=\"line\">            canvas.drawCircle(centerX, centerY, radius, paint);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 运行时刷新画面。</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在布局预览的时候就会看到一个圆形被绘制出来，并且在程序正在运行的时候不会绘制该圆形：<br><img src=\"https://hjdzone.github.io/blog/2016/11/04/how-to-improve-code-readability/preview_in_edit_mode.png\" alt=\"图3\"></p>\n<blockquote>\n<p>提示：实际开发中，isInEditMode() 方法可以用在 View 的任何地方用于设置预览数据。</p>\n</blockquote>\n<h2 id=\"13-使用内部类对代码进行分类\"><a href=\"#13-使用内部类对代码进行分类\" class=\"headerlink\" title=\"13 使用内部类对代码进行分类\"></a>13 使用内部类对代码进行分类</h2><p>内部类有些时候可以起到类似包的代码分类功能，通过内部类对某个类内部的代码进行功能划分，可以让与该类相关的代码更具有可读性。</p>\n<p>例如我们有个日志打印工具类，里面有两种类型的方法，一种是打印用户可见的日志，另一种则是打印只有开发者可见的日志，我们可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 用户可见的日志。</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">d</span><span class=\"params\">(String tag, String msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 打印日志</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 开发者可见的日志。</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Developer</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">d</span><span class=\"params\">(String tag, String msg)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 打印日志</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在调用日志打印方法时通过内部类的名称一眼就可以看出当前打印的日志是用户可见还是开发者可见的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Logger.User.d(TAG, <span class=\"string\">\"打印用户可见的日志\"</span>);</div><div class=\"line\">Logger.Developer.d(TAG, <span class=\"string\">\"打印开发者可见的日志\"</span>);</div><div class=\"line\">类似的，我们也可以使用内部类对常量进行分类，例如我们有一个多媒体数据库叫 MediaStore，其内部分为图像数据表和视频数据表，每个表都有自己的字段，我们需要定义常量来对应这些字段，所以可以这样写：</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MediaStore</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 图像数据表</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageTable</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"image_name\"</span>;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PATH = <span class=\"string\">\"image_path\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 视频数据表</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VideoTable</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"video_name\"</span>;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PATH = <span class=\"string\">\"video_path\"</span>; </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们在需要使用这些常量的时候就可以通过内部类区分不同类型的常量了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">MediaStore.ImageTable.NAME<span class=\"comment\">// 图像名称字段</span></div><div class=\"line\">MediaStore.VideoTable.NAME<span class=\"comment\">// 视频名称字段</span></div></pre></td></tr></table></figure>\n"},{"title":"静态的内部类和普通的内部类的区别（面试遇到的坑）","date":"2016-12-02T08:34:54.000Z","_content":"静态内部类一般是声明为static的类，它又被叫做嵌套类。   \n静态内部类对象和其外围的类对象之间没有联系。然而普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。   \n静态内部类意味着：\n\n- 要创建静态内部类的对象，并不需要外围的类的对象；\n\n- 不能从静态内部类的对象中访问非静态的外围对象；\n\n静态内部类和普通的类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static 数据和static 字段，也不能包含静态内部类。 \n ","source":"_posts/静态的内部类和普通的内部类的区别（面试遇到的坑）.md","raw":"---\ntitle: 静态的内部类和普通的内部类的区别（面试遇到的坑）\ndate: 2016-12-02 16:34:54\ntags: JAVA\n---\n静态内部类一般是声明为static的类，它又被叫做嵌套类。   \n静态内部类对象和其外围的类对象之间没有联系。然而普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。   \n静态内部类意味着：\n\n- 要创建静态内部类的对象，并不需要外围的类的对象；\n\n- 不能从静态内部类的对象中访问非静态的外围对象；\n\n静态内部类和普通的类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static 数据和static 字段，也不能包含静态内部类。 \n ","slug":"静态的内部类和普通的内部类的区别（面试遇到的坑）","published":1,"updated":"2016-12-02T08:42:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcz4001a4jp5mgihrb5u","content":"<p>静态内部类一般是声明为static的类，它又被叫做嵌套类。<br>静态内部类对象和其外围的类对象之间没有联系。然而普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。<br>静态内部类意味着：</p>\n<ul>\n<li><p>要创建静态内部类的对象，并不需要外围的类的对象；</p>\n</li>\n<li><p>不能从静态内部类的对象中访问非静态的外围对象；</p>\n</li>\n</ul>\n<p>静态内部类和普通的类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static 数据和static 字段，也不能包含静态内部类。 </p>\n","excerpt":"","more":"<p>静态内部类一般是声明为static的类，它又被叫做嵌套类。<br>静态内部类对象和其外围的类对象之间没有联系。然而普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。<br>静态内部类意味着：</p>\n<ul>\n<li><p>要创建静态内部类的对象，并不需要外围的类的对象；</p>\n</li>\n<li><p>不能从静态内部类的对象中访问非静态的外围对象；</p>\n</li>\n</ul>\n<p>静态内部类和普通的类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static 数据和static 字段，也不能包含静态内部类。 </p>\n"},{"title":"自己的内部链式存储机制","date":"2016-09-08T06:19:25.000Z","_content":"\n```java\npackage javastaty;\npublic class LinedStack<T> {\n\n       private static class Node<U> {\n              U item; //链式存储的数据对象\n              Node<U> next;//实体类对象 保存了自己和上面的item\n              Node() {//初始化\n                     item = null;\n                     next = null;\n              }\n              Node(U item, Node<U> next) {//存储\n                     this.item = item;\n                     this.next = next;\n              }\n              boolean end() {//末端哨兵机制\n                     return item == null && next ==null;\n              }                          \n       }\n       \n/*************************************************************************************************/\n       \n       private Node<T> top = new Node<T>();\n       \n       public void push(T item){\n              top = new Node<T>(item,top);\n       }\n       \n       public T pop(){\n              T result = top.item;\n              if(!top.end())\n                     top = top.next;\n              return result;\n       }\n       \n       public static void main(String[] args){\n              LinedStack<String> lss = new LinedStack<String>();\n              \n              for(String s : \"wo xiang zhi dao zhege shi zen me hui shi\".split(\" \"))\n                     lss.push(s);\n              \n              String s ;\n              \n              while((s = lss.pop()) != null)\n                     System.out.println(s);\n       }\n}\n```\n\n整体思路   \n以上面的例子来说明：   \n当我循环执行lss.push的时候，链表就开始了。   \n链表从      \nprivate Node<T> top = new Node<T>();   \n这句话开始。这句话生成了一个空的链表。\n举个栗子:   \n就好像我们去食堂吃饭，食堂刚开始的时候是没有人排队的。但是这个队列是一直存在的，只要有人来了队列就会看的见了。   \n每一个Node对象有两个属性，一个是item 一个Node。   \nitem就好比是我们包包里的钱，node就好比是我们后面的那个人。  \n我们后面那个人包包里肯定会有钱，但是他后面有没有人就说不清楚了。   \n所以大概就是这个样子。   \npush就是把我自己排进这个队列里，并拉住前面的人的手。 至于前面的人拉住谁的手我就不用去过问了。   \n\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n\n","source":"_posts/自己的内部链式存储机制.md","raw":"---\ntitle: 自己的内部链式存储机制\ndate: 2016-09-08 14:19:25\ntags: JAVA\n---\n\n```java\npackage javastaty;\npublic class LinedStack<T> {\n\n       private static class Node<U> {\n              U item; //链式存储的数据对象\n              Node<U> next;//实体类对象 保存了自己和上面的item\n              Node() {//初始化\n                     item = null;\n                     next = null;\n              }\n              Node(U item, Node<U> next) {//存储\n                     this.item = item;\n                     this.next = next;\n              }\n              boolean end() {//末端哨兵机制\n                     return item == null && next ==null;\n              }                          \n       }\n       \n/*************************************************************************************************/\n       \n       private Node<T> top = new Node<T>();\n       \n       public void push(T item){\n              top = new Node<T>(item,top);\n       }\n       \n       public T pop(){\n              T result = top.item;\n              if(!top.end())\n                     top = top.next;\n              return result;\n       }\n       \n       public static void main(String[] args){\n              LinedStack<String> lss = new LinedStack<String>();\n              \n              for(String s : \"wo xiang zhi dao zhege shi zen me hui shi\".split(\" \"))\n                     lss.push(s);\n              \n              String s ;\n              \n              while((s = lss.pop()) != null)\n                     System.out.println(s);\n       }\n}\n```\n\n整体思路   \n以上面的例子来说明：   \n当我循环执行lss.push的时候，链表就开始了。   \n链表从      \nprivate Node<T> top = new Node<T>();   \n这句话开始。这句话生成了一个空的链表。\n举个栗子:   \n就好像我们去食堂吃饭，食堂刚开始的时候是没有人排队的。但是这个队列是一直存在的，只要有人来了队列就会看的见了。   \n每一个Node对象有两个属性，一个是item 一个Node。   \nitem就好比是我们包包里的钱，node就好比是我们后面的那个人。  \n我们后面那个人包包里肯定会有钱，但是他后面有没有人就说不清楚了。   \n所以大概就是这个样子。   \npush就是把我自己排进这个队列里，并拉住前面的人的手。 至于前面的人拉住谁的手我就不用去过问了。   \n\n\n以上内容为学习记录，若有疑问，请及时与我联系，谢谢   \n邮箱：yee.xin.work@gmail.com  \n\n","slug":"自己的内部链式存储机制","published":1,"updated":"2016-11-29T06:21:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciznsfcz5001c4jp54tpytvw9","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> javastaty;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinedStack</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">U</span>&gt; </span>&#123;</div><div class=\"line\">              U item; <span class=\"comment\">//链式存储的数据对象</span></div><div class=\"line\">              Node&lt;U&gt; next;<span class=\"comment\">//实体类对象 保存了自己和上面的item</span></div><div class=\"line\">              Node() &#123;<span class=\"comment\">//初始化</span></div><div class=\"line\">                     item = <span class=\"keyword\">null</span>;</div><div class=\"line\">                     next = <span class=\"keyword\">null</span>;</div><div class=\"line\">              &#125;</div><div class=\"line\">              Node(U item, Node&lt;U&gt; next) &#123;<span class=\"comment\">//存储</span></div><div class=\"line\">                     <span class=\"keyword\">this</span>.item = item;</div><div class=\"line\">                     <span class=\"keyword\">this</span>.next = next;</div><div class=\"line\">              &#125;</div><div class=\"line\">              <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//末端哨兵机制</span></div><div class=\"line\">                     <span class=\"keyword\">return</span> item == <span class=\"keyword\">null</span> &amp;&amp; next ==<span class=\"keyword\">null</span>;</div><div class=\"line\">              &#125;                          </div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\"><span class=\"comment\">/*************************************************************************************************/</span></div><div class=\"line\">       </div><div class=\"line\">       <span class=\"keyword\">private</span> Node&lt;T&gt; top = <span class=\"keyword\">new</span> Node&lt;T&gt;();</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(T item)</span></span>&#123;</div><div class=\"line\">              top = <span class=\"keyword\">new</span> Node&lt;T&gt;(item,top);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">pop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">              T result = top.item;</div><div class=\"line\">              <span class=\"keyword\">if</span>(!top.end())</div><div class=\"line\">                     top = top.next;</div><div class=\"line\">              <span class=\"keyword\">return</span> result;</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">              LinedStack&lt;String&gt; lss = <span class=\"keyword\">new</span> LinedStack&lt;String&gt;();</div><div class=\"line\">              </div><div class=\"line\">              <span class=\"keyword\">for</span>(String s : <span class=\"string\">\"wo xiang zhi dao zhege shi zen me hui shi\"</span>.split(<span class=\"string\">\" \"</span>))</div><div class=\"line\">                     lss.push(s);</div><div class=\"line\">              </div><div class=\"line\">              String s ;</div><div class=\"line\">              </div><div class=\"line\">              <span class=\"keyword\">while</span>((s = lss.pop()) != <span class=\"keyword\">null</span>)</div><div class=\"line\">                     System.out.println(s);</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>整体思路<br>以上面的例子来说明：<br>当我循环执行lss.push的时候，链表就开始了。<br>链表从<br>private Node<t> top = new Node<t>();<br>这句话开始。这句话生成了一个空的链表。<br>举个栗子:<br>就好像我们去食堂吃饭，食堂刚开始的时候是没有人排队的。但是这个队列是一直存在的，只要有人来了队列就会看的见了。<br>每一个Node对象有两个属性，一个是item 一个Node。<br>item就好比是我们包包里的钱，node就好比是我们后面的那个人。<br>我们后面那个人包包里肯定会有钱，但是他后面有没有人就说不清楚了。<br>所以大概就是这个样子。<br>push就是把我自己排进这个队列里，并拉住前面的人的手。 至于前面的人拉住谁的手我就不用去过问了。   </t></t></p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n","excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> javastaty;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinedStack</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">U</span>&gt; </span>&#123;</div><div class=\"line\">              U item; <span class=\"comment\">//链式存储的数据对象</span></div><div class=\"line\">              Node&lt;U&gt; next;<span class=\"comment\">//实体类对象 保存了自己和上面的item</span></div><div class=\"line\">              Node() &#123;<span class=\"comment\">//初始化</span></div><div class=\"line\">                     item = <span class=\"keyword\">null</span>;</div><div class=\"line\">                     next = <span class=\"keyword\">null</span>;</div><div class=\"line\">              &#125;</div><div class=\"line\">              Node(U item, Node&lt;U&gt; next) &#123;<span class=\"comment\">//存储</span></div><div class=\"line\">                     <span class=\"keyword\">this</span>.item = item;</div><div class=\"line\">                     <span class=\"keyword\">this</span>.next = next;</div><div class=\"line\">              &#125;</div><div class=\"line\">              <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//末端哨兵机制</span></div><div class=\"line\">                     <span class=\"keyword\">return</span> item == <span class=\"keyword\">null</span> &amp;&amp; next ==<span class=\"keyword\">null</span>;</div><div class=\"line\">              &#125;                          </div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\"><span class=\"comment\">/*************************************************************************************************/</span></div><div class=\"line\">       </div><div class=\"line\">       <span class=\"keyword\">private</span> Node&lt;T&gt; top = <span class=\"keyword\">new</span> Node&lt;T&gt;();</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(T item)</span></span>&#123;</div><div class=\"line\">              top = <span class=\"keyword\">new</span> Node&lt;T&gt;(item,top);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">pop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">              T result = top.item;</div><div class=\"line\">              <span class=\"keyword\">if</span>(!top.end())</div><div class=\"line\">                     top = top.next;</div><div class=\"line\">              <span class=\"keyword\">return</span> result;</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">              LinedStack&lt;String&gt; lss = <span class=\"keyword\">new</span> LinedStack&lt;String&gt;();</div><div class=\"line\">              </div><div class=\"line\">              <span class=\"keyword\">for</span>(String s : <span class=\"string\">\"wo xiang zhi dao zhege shi zen me hui shi\"</span>.split(<span class=\"string\">\" \"</span>))</div><div class=\"line\">                     lss.push(s);</div><div class=\"line\">              </div><div class=\"line\">              String s ;</div><div class=\"line\">              </div><div class=\"line\">              <span class=\"keyword\">while</span>((s = lss.pop()) != <span class=\"keyword\">null</span>)</div><div class=\"line\">                     System.out.println(s);</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>整体思路<br>以上面的例子来说明：<br>当我循环执行lss.push的时候，链表就开始了。<br>链表从<br>private Node<T> top = new Node<T>();<br>这句话开始。这句话生成了一个空的链表。<br>举个栗子:<br>就好像我们去食堂吃饭，食堂刚开始的时候是没有人排队的。但是这个队列是一直存在的，只要有人来了队列就会看的见了。<br>每一个Node对象有两个属性，一个是item 一个Node。<br>item就好比是我们包包里的钱，node就好比是我们后面的那个人。<br>我们后面那个人包包里肯定会有钱，但是他后面有没有人就说不清楚了。<br>所以大概就是这个样子。<br>push就是把我自己排进这个队列里，并拉住前面的人的手。 至于前面的人拉住谁的手我就不用去过问了。   </p>\n<p>以上内容为学习记录，若有疑问，请及时与我联系，谢谢<br>邮箱：yee.xin.work@gmail.com  </p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciznsfcxq00044jp540cojmrp","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcxt00074jp5mjiiremp"},{"post_id":"ciznsfcxa00004jp5325an8m1","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcxv00094jp5ce3pxruc"},{"post_id":"ciznsfcxr00054jp58ohhchtp","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcy0000c4jp575jnn7by"},{"post_id":"ciznsfcxu00084jp5cgh98j4v","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcy2000e4jp52avg9grj"},{"post_id":"ciznsfcxf00014jp5h8bqzgoh","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcy5000g4jp5ejetbzll"},{"post_id":"ciznsfcxx000a4jp5qhblrjl0","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcy6000i4jp59vjgc9gr"},{"post_id":"ciznsfcy0000d4jp57j4rhtv1","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcy9000k4jp5myju5l8x"},{"post_id":"ciznsfcxm00034jp53bjgzq98","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcyc000n4jp5cobogiz3"},{"post_id":"ciznsfcy3000f4jp5xdkh19xj","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcyf000p4jp5xw97fpjl"},{"post_id":"ciznsfcy5000h4jp58ojd48c6","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcyh000r4jp5m7gadrad"},{"post_id":"ciznsfcy6000j4jp5k4xi648t","tag_id":"ciznsfcyb000m4jp5dom3gq2w","_id":"ciznsfcyl000u4jp5pn492oph"},{"post_id":"ciznsfcyj000s4jp5tiqiorqv","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcyo000w4jp54565xnfy"},{"post_id":"ciznsfcyl000v4jp55lv70ni1","tag_id":"ciznsfcyk000t4jp5knevl0fk","_id":"ciznsfcyq000z4jp5nskdylvh"},{"post_id":"ciznsfcya000l4jp5nste5svm","tag_id":"ciznsfcyk000t4jp5knevl0fk","_id":"ciznsfcz000114jp5x59rb7oh"},{"post_id":"ciznsfcyp000x4jp5k7kdgg6i","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcz100144jp5u70l4whc"},{"post_id":"ciznsfcyq00104jp5ubhtb6qh","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcz200164jp584benkxl"},{"post_id":"ciznsfcyd000o4jp5i9k6qnkr","tag_id":"ciznsfcyk000t4jp5knevl0fk","_id":"ciznsfcz300194jp5qq2htov4"},{"post_id":"ciznsfcz000124jp5hfsqvqnb","tag_id":"ciznsfcxj00024jp5dfb79pg0","_id":"ciznsfcz4001b4jp5v38t6xnj"},{"post_id":"ciznsfcyf000q4jp5k67z7nqs","tag_id":"ciznsfcz100134jp5rszn7hjx","_id":"ciznsfcz6001d4jp59czklr42"},{"post_id":"ciznsfcz4001a4jp5mgihrb5u","tag_id":"ciznsfcyk000t4jp5knevl0fk","_id":"ciznsfcz8001f4jp5znqcklzo"},{"post_id":"ciznsfcz5001c4jp54tpytvw9","tag_id":"ciznsfcyk000t4jp5knevl0fk","_id":"ciznsfcz9001g4jp5wmhoqi93"},{"post_id":"ciznsfcz100154jp5ohkwjgic","tag_id":"ciznsfcz300184jp5253twzja","_id":"ciznsfcz9001h4jp58emj1bpd"},{"post_id":"ciznsfcz200174jp5y0bzd78b","tag_id":"ciznsfcz300184jp5253twzja","_id":"ciznsfcza001i4jp5bgzlaujv"}],"Tag":[{"name":"Android","_id":"ciznsfcxj00024jp5dfb79pg0"},{"name":"设计模式","_id":"ciznsfcyb000m4jp5dom3gq2w"},{"name":"JAVA","_id":"ciznsfcyk000t4jp5knevl0fk"},{"name":"Java","_id":"ciznsfcz100134jp5rszn7hjx"},{"name":"代码规范","_id":"ciznsfcz300184jp5253twzja"}]}}